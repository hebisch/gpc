diff -rc gcc-2.8.1.orig/Makefile.in gcc-2.8.1/Makefile.in
*** gcc-2.8.1.orig/Makefile.in	1998-03-03 02:54:31.000000000 +0100
--- gcc-2.8.1/Makefile.in	2006-03-13 23:21:10.000000000 +0100
***************
*** 189,194 ****
--- 189,196 ----
  PREMADE_ATTRTAB_MD = Makefile  # Guaranteed not to cmp equal to md.
  PREMADE_ATTRTAB = 
  
+ build=@build@
+ host=@host@
  target=@target@
  target_alias=@target_alias@
  xmake_file=@dep_host_xmake_file@
***************
*** 369,375 ****
  
  # List of things which should already be built whenever we try to use xgcc
  # to compile anything (without linking).
! GCC_PASSES=xgcc cc1 cpp $(EXTRA_PASSES)
  
  # List of things which should already be built whenever we try to use xgcc
  # to link anything.
--- 371,377 ----
  
  # List of things which should already be built whenever we try to use xgcc
  # to compile anything (without linking).
! GCC_PASSES=xgcc$(exeext) cc1$(exeext) cpp$(exeext) $(EXTRA_PASSES)
  
  # List of things which should already be built whenever we try to use xgcc
  # to link anything.
***************
*** 544,556 ****
  	"RANLIB_TEST_FOR_TARGET=$(RANLIB_TEST_FOR_TARGET)" \
  	"SHELL=$(SHELL)" \
  	"STAGE_PREFIX=@stage_prefix_set_by_configure@" \
  	"exeext=$(exeext)" \
  	"objext=$(objext)" \
! 	"exec_prefix=$(exec_prefix)" \
! 	"prefix=$(prefix)" \
! 	"tooldir=$(tooldir)" \
! 	"bindir=$(bindir)" \
! 	"libsubdir=$(libsubdir)"
  #
  # Lists of files for various purposes.
  
--- 546,562 ----
  	"RANLIB_TEST_FOR_TARGET=$(RANLIB_TEST_FOR_TARGET)" \
  	"SHELL=$(SHELL)" \
  	"STAGE_PREFIX=@stage_prefix_set_by_configure@" \
+ 	"target_alias=$(target_alias)" \
+ 	"program_transform_name=$(program_transform_name)" \
+ 	"program_transform_cross_name=$(program_transform_cross_name)" \
+ 	"version=$(version)" \
  	"exeext=$(exeext)" \
  	"objext=$(objext)" \
! 	"exec_prefix=`echo '$(exec_prefix)'|sed -e 's/\\$$/\\\\&&/g'`" \
! 	"prefix=`echo '$(prefix)'|sed -e 's/\\$$/\\\\&&/g'`" \
! 	"tooldir=`echo '$(tooldir)'|sed -e 's/\\$$/\\\\&&/g'`" \
! 	"bindir=`echo '$(bindir)'|sed -e 's/\\$$/\\\\&&/g'`" \
! 	"libsubdir=`echo '$(libsubdir)'|sed -e 's/\\$$/\\\\&&/g'`"
  #
  # Lists of files for various purposes.
  
***************
*** 688,694 ****
  	$(SHELL) $(srcdir)/configure.frag $(srcdir) "$(SUBDIRS)" \
  		"$(xmake_file)" "$(tmake_file)"
  	cp config.status config.run
! 	$(SHELL) config.run
  	rm -f config.run
  
  $(srcdir)/configure: $(srcdir)/configure.in
--- 694,700 ----
  	$(SHELL) $(srcdir)/configure.frag $(srcdir) "$(SUBDIRS)" \
  		"$(xmake_file)" "$(tmake_file)"
  	cp config.status config.run
! 	$(SHELL) config.run > /dev/null
  	rm -f config.run
  
  $(srcdir)/configure: $(srcdir)/configure.in
***************
*** 729,746 ****
  all.cross: native gcc-cross specs stmp-headers $(LIBGCC) $(STMP_FIXPROTO) \
  	$(LIBGCC1_TEST) $(EXTRA_PARTS) lang.all.cross
  # This is what to compile if making gcc with a cross-compiler.
! all.build: native xgcc $(EXTRA_PARTS) lang.all.build
  # This is what must be made before installing GCC and converting libraries.
! start.encap: native xgcc specs $(LIBGCC1) xlimits.h lang.start.encap
  # These can't be made until after GCC can run.
  rest.encap: stmp-headers $(LIBGCC) $(STMP_FIXPROTO) $(EXTRA_PARTS) lang.rest.encap
  # This is what is made with the host's compiler
  # whether making a cross compiler or not.
! native: config.status auto-config.h cpp $(LANGUAGES) \
  	$(EXTRA_PASSES) $(EXTRA_PROGRAMS) $(USE_COLLECT2)
  
  # Define the names for selecting languages in LANGUAGES.
! C c: cc1
  PROTO: proto
  
  # Tell GNU make these are phony targets.
--- 735,752 ----
  all.cross: native gcc-cross specs stmp-headers $(LIBGCC) $(STMP_FIXPROTO) \
  	$(LIBGCC1_TEST) $(EXTRA_PARTS) lang.all.cross
  # This is what to compile if making gcc with a cross-compiler.
! all.build: native xgcc$(exeext) $(EXTRA_PARTS) lang.all.build
  # This is what must be made before installing GCC and converting libraries.
! start.encap: native xgcc$(exeext) specs $(LIBGCC1) xlimits.h lang.start.encap
  # These can't be made until after GCC can run.
  rest.encap: stmp-headers $(LIBGCC) $(STMP_FIXPROTO) $(EXTRA_PARTS) lang.rest.encap
  # This is what is made with the host's compiler
  # whether making a cross compiler or not.
! native: config.status auto-config.h cpp$(exeext) $(LANGUAGES) \
  	$(EXTRA_PASSES) $(EXTRA_PROGRAMS) $(USE_COLLECT2)
  
  # Define the names for selecting languages in LANGUAGES.
! C c: cc1$(exeext)
  PROTO: proto
  
  # Tell GNU make these are phony targets.
***************
*** 753,762 ****
  # Verify that it works to compile and link libgcc1-test.
  # If it does, then there are sufficient replacements for libgcc1.a.
  libgcc1-test: libgcc1-test.o native $(GCC_PARTS)
- 	@echo "Testing libgcc1.  Ignore linker warning messages."
  	$(GCC_FOR_TARGET) $(GCC_CFLAGS) libgcc1-test.o -o libgcc1-test \
  	  -nostartfiles -nostdlib `$(GCC_FOR_TARGET) --print-libgcc-file-name`
! libgcc1-test.o: libgcc1-test.c native xgcc
  	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(ALL_CPPFLAGS) -c $(srcdir)/libgcc1-test.c
  
  # Recompile all the language-independent object files.
--- 759,767 ----
  # Verify that it works to compile and link libgcc1-test.
  # If it does, then there are sufficient replacements for libgcc1.a.
  libgcc1-test: libgcc1-test.o native $(GCC_PARTS)
  	$(GCC_FOR_TARGET) $(GCC_CFLAGS) libgcc1-test.o -o libgcc1-test \
  	  -nostartfiles -nostdlib `$(GCC_FOR_TARGET) --print-libgcc-file-name`
! libgcc1-test.o: libgcc1-test.c native xgcc$(exeext)
  	$(GCC_FOR_TARGET) $(GCC_CFLAGS) $(ALL_CPPFLAGS) -c $(srcdir)/libgcc1-test.c
  
  # Recompile all the language-independent object files.
***************
*** 771,793 ****
  # We call this executable `xgcc' rather than `gcc'
  # to avoid confusion if the current directory is in the path
  # and CC is `gcc'.  It is renamed to `gcc' when it is installed.
! xgcc: gcc.o version.o choose-temp.o pexecute.o prefix.o version.o \
     $(LIBDEPS) $(EXTRA_GCC_OBJS)
  	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ gcc.o prefix.o version.o \
  	  choose-temp.o pexecute.o $(EXTRA_GCC_OBJS) $(LIBS)
  
  # Dump a specs file to make -B./ read these specs over installed ones.
! specs: xgcc
  	$(GCC_FOR_TARGET) -dumpspecs > tmp-specs
! 	mv tmp-specs specs
  
  # We do want to create an executable named `xgcc', so we can use it to
  # compile libgcc2.a.
  # Also create gcc-cross, so that install-common will install properly.
! gcc-cross: xgcc
  	cp xgcc$(exeext) gcc-cross$(exeext)
  
! cc1: $(P) $(C_OBJS) $(OBJS) $(BC_OBJS) $(LIBDEPS)
  	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $(C_OBJS) $(OBJS) $(BC_OBJS) $(LIBS)
  
  # Copy float.h from its source.
--- 776,802 ----
  # We call this executable `xgcc' rather than `gcc'
  # to avoid confusion if the current directory is in the path
  # and CC is `gcc'.  It is renamed to `gcc' when it is installed.
! xgcc$(exeext): gcc.o version.o choose-temp.o pexecute.o prefix.o version.o \
     $(LIBDEPS) $(EXTRA_GCC_OBJS)
  	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ gcc.o prefix.o version.o \
  	  choose-temp.o pexecute.o $(EXTRA_GCC_OBJS) $(LIBS)
  
  # Dump a specs file to make -B./ read these specs over installed ones.
! specs: xgcc$(exeext)
  	$(GCC_FOR_TARGET) -dumpspecs > tmp-specs
! 	if [ $(target) = $(host) ]; \
!         then sed -e '/^\*cross_compile:/,/^$$/s/^[01]/0/'; \
! 	else sed -e '/^\*cross_compile:/,/^$$/s/^[01]/1/'; \
!         fi < tmp-specs > specs
! 	rm tmp-specs
  
  # We do want to create an executable named `xgcc', so we can use it to
  # compile libgcc2.a.
  # Also create gcc-cross, so that install-common will install properly.
! gcc-cross: xgcc$(exeext)
  	cp xgcc$(exeext) gcc-cross$(exeext)
  
! cc1$(exeext): $(P) $(C_OBJS) $(OBJS) $(BC_OBJS) $(LIBDEPS)
  	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ $(C_OBJS) $(OBJS) $(BC_OBJS) $(LIBS)
  
  # Copy float.h from its source.
***************
*** 851,856 ****
--- 860,866 ----
  libgcc1.null: $(GCC_PASSES)
  	echo "__foo () {}" > dummy.c
  	$(GCC_FOR_TARGET) $(GCC_CFLAGS) -c dummy.c
+ 	rm -f libgcc1.null
  	$(OLDAR) $(OLDAR_FLAGS) libgcc1.null dummy$(objext)
  	rm -f dummy$(objext) dummy.c
  
***************
*** 881,887 ****
  #	set -e;
  	for name in $(LIB1FUNCS); \
  	do \
- 	  echo $${name}; \
  	  rm -f $${name}$(objext); \
  	  $(OLDCC) -DIN_LIBGCC1 $(CCLIBFLAGS) $(INCLUDES) -c -DL$${name} $(srcdir)/libgcc1.c; \
  	  if [ $$? -eq 0 ] ; then true; else exit 1; fi; \
--- 891,896 ----
***************
*** 981,987 ****
  #	set -e;
  	for name in $(LIB2FUNCS); \
  	do \
- 	  echo $${name}; \
  	  $(GCC_FOR_TARGET) $(LIBGCC2_CFLAGS) $(INCLUDES) -c -DL$${name} \
  	      $(srcdir)/libgcc2.c -o $${name}$(objext); \
  	  if [ $$? -eq 0 ] ; then true; else exit 1; fi; \
--- 990,995 ----
***************
*** 1011,1017 ****
  	    else true; \
  	    fi; done; \
  	  else \
- 	    echo $${name}; \
  	    if [ $${name}.asm = $${file} ]; then \
  	      cp $${file} $${name}.s || exit 1; file=$${name}.s; \
  	    else true; fi; \
--- 1019,1024 ----
***************
*** 1336,1343 ****
--- 1343,1360 ----
     insn-flags.h insn-config.h insn-codes.h expr.h real.h regs.h function.h \
     bytecode.h output.h $(RECOG_H) except.h
  
+ # @@ GPC based on gcc-2.8.1 crashes (fjf559i.pas, compiling with `-O' or
+ #    higher) when jump.c is compiled with `-O3' (sic!). Since gcc-2.8.1 is
+ #    not maintained anymore, it might not be worth the effort to debug this
+ #    further (until the problem starts appearing with other GCC versions
+ #    ...), so "don't to that then". So I'm adding `-fno-inline-functions'
+ #    here. For the same reason, it's probably not worth making it conditional
+ #    on GPC (which would be more difficult than an `#ifdef' in the C files).
+ #    -- Frank
  jump.o : jump.c $(CONFIG_H) $(RTL_H) flags.h hard-reg-set.h regs.h \
     insn-config.h insn-flags.h $(RECOG_H) expr.h real.h except.h
+ 	$(CC) -c $(ALL_CFLAGS) $(ALL_CPPFLAGS) $(INCLUDES) -fno-inline-functions $<
+ 
  stupid.o : stupid.c $(CONFIG_H) $(RTL_H) regs.h hard-reg-set.h flags.h
  
  cse.o : cse.c $(CONFIG_H) $(RTL_H) regs.h hard-reg-set.h flags.h real.h \
***************
*** 1739,1749 ****
  # Remake cpp and protoize.
  
  # Making the preprocessor
! cpp: $(CCCP)
  	-rm -f cpp$(exeext)
  	ln $(CCCP)$(exeext) cpp$(exeext) > /dev/null 2>&1 \
  	 || cp $(CCCP)$(exeext) cpp$(exeext)
! cccp: cccp.o cexp.o version.o prefix.o $(LIBDEPS)
  	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ cccp.o cexp.o prefix.o \
  	  version.o $(LIBS)
  cexp.o: $(srcdir)/cexp.c $(CONFIG_H)
--- 1756,1766 ----
  # Remake cpp and protoize.
  
  # Making the preprocessor
! cpp$(exeext): $(CCCP)$(exeext)
  	-rm -f cpp$(exeext)
  	ln $(CCCP)$(exeext) cpp$(exeext) > /dev/null 2>&1 \
  	 || cp $(CCCP)$(exeext) cpp$(exeext)
! cccp$(exeext): cccp.o cexp.o version.o prefix.o $(LIBDEPS)
  	$(CC) $(ALL_CFLAGS) $(LDFLAGS) -o $@ cccp.o cexp.o prefix.o \
  	  version.o $(LIBS)
  cexp.o: $(srcdir)/cexp.c $(CONFIG_H)
***************
*** 1918,1924 ****
  	  for dir in $(SYSTEM_HEADER_DIR) $(OTHER_FIXINCLUDES_DIRS); do \
  	    if [ -d $$dir ]; \
  	    then \
! 	      $(SHELL) $(srcdir)/$(FIXINCLUDES) include $$dir; \
  	    else true; fi; \
  	  done; \
  	else true; \
--- 1935,1941 ----
  	  for dir in $(SYSTEM_HEADER_DIR) $(OTHER_FIXINCLUDES_DIRS); do \
  	    if [ -d $$dir ]; \
  	    then \
! 	      $(SHELL) $(srcdir)/$(FIXINCLUDES) include $$dir > fixincludes.log 2>&1; \
  	    else true; fi; \
  	  done; \
  	else true; \
***************
*** 2248,2254 ****
  
  # Install the driver program as $(target_alias)-gcc
  # and also as either gcc (if native) or $(tooldir)/bin/gcc.
! install-driver: xgcc
  	-if [ -f gcc-cross$(exeext) ] ; then \
  	  rm -f $(bindir)/$(GCC_CROSS_NAME)$(exeext); \
  	  $(INSTALL_PROGRAM) gcc-cross$(exeext) $(bindir)/$(GCC_CROSS_NAME)$(exeext); \
--- 2265,2271 ----
  
  # Install the driver program as $(target_alias)-gcc
  # and also as either gcc (if native) or $(tooldir)/bin/gcc.
! install-driver: xgcc$(exeext)
  	-if [ -f gcc-cross$(exeext) ] ; then \
  	  rm -f $(bindir)/$(GCC_CROSS_NAME)$(exeext); \
  	  $(INSTALL_PROGRAM) gcc-cross$(exeext) $(bindir)/$(GCC_CROSS_NAME)$(exeext); \
diff -rc gcc-2.8.1.orig/acconfig.h gcc-2.8.1/acconfig.h
*** gcc-2.8.1.orig/acconfig.h	1998-02-03 21:52:21.000000000 +0100
--- gcc-2.8.1/acconfig.h	2006-03-13 23:21:10.000000000 +0100
***************
*** 1,3 ****
--- 1,6 ----
+ /* Define if you can safely include both <string.h> and <strings.h>.  */
+ #undef STRING_WITH_STRINGS
+ 
  /* Define if you have a working <inttypes.h> header file.  */
  #undef HAVE_INTTYPES_H
  
diff -rc gcc-2.8.1.orig/aclocal.m4 gcc-2.8.1/aclocal.m4
*** gcc-2.8.1.orig/aclocal.m4	1997-11-22 12:55:05.000000000 +0100
--- gcc-2.8.1/aclocal.m4	2006-03-13 23:21:10.000000000 +0100
***************
*** 1,3 ****
--- 1,14 ----
+ dnl See whether we can include both string.h and strings.h.
+ AC_DEFUN(GCC_HEADER_STRING,
+ [AC_CACHE_CHECK([whether string.h and strings.h may both be included],
+   gcc_cv_header_string,
+ [AC_TRY_COMPILE([#include <string.h>
+ #include <strings.h>], , gcc_cv_header_string=yes, gcc_cv_header_string=no)])
+ if test $gcc_cv_header_string = yes; then
+   AC_DEFINE(STRING_WITH_STRINGS)
+ fi
+ ])
+ 
  dnl See whether we need a declaration for a function.
  AC_DEFUN(GCC_NEED_DECLARATION,
  [AC_MSG_CHECKING([whether $1 must be declared])
diff -rc gcc-2.8.1.orig/ansidecl.h gcc-2.8.1/ansidecl.h
*** gcc-2.8.1.orig/ansidecl.h	2006-03-25 00:15:19.000000000 +0100
--- gcc-2.8.1/ansidecl.h	2006-03-13 23:21:10.000000000 +0100
***************
*** 0 ****
--- 1,489 ----
+ /* ANSI and traditional C compatability macros
+    Copyright 1991, 1992, 1996 Free Software Foundation, Inc.
+    This file is part of the GNU C Library.
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+ 
+ /* ANSI and traditional C compatibility macros
+ 
+    ANSI C is assumed if __STDC__ is #defined.
+ 
+    Macro	ANSI C definition	Traditional C definition
+    -----	---- - ----------	----------- - ----------
+    PTR		`void *'		`char *'
+    LONG_DOUBLE	`long double'		`double'
+    VOLATILE	`volatile'		`'
+    SIGNED	`signed'		`'
+    PTRCONST	`void *const'		`char *'
+    ANSI_PROTOTYPES  1			not defined
+ 
+    CONST is also defined, but is obsolete.  Just use const.
+ 
+    obsolete --     DEFUN (name, arglist, args)
+ 
+ 	Defines function NAME.
+ 
+ 	ARGLIST lists the arguments, separated by commas and enclosed in
+ 	parentheses.  ARGLIST becomes the argument list in traditional C.
+ 
+ 	ARGS list the arguments with their types.  It becomes a prototype in
+ 	ANSI C, and the type declarations in traditional C.  Arguments should
+ 	be separated with `AND'.  For functions with a variable number of
+ 	arguments, the last thing listed should be `DOTS'.
+ 
+    obsolete --     DEFUN_VOID (name)
+ 
+ 	Defines a function NAME, which takes no arguments.
+ 
+    obsolete --     EXFUN (name, (prototype))	-- obsolete.
+ 
+ 	Replaced by PARAMS.  Do not use; will disappear someday soon.
+ 	Was used in external function declarations.
+ 	In ANSI C it is `NAME PROTOTYPE' (so PROTOTYPE should be enclosed in
+ 	parentheses).  In traditional C it is `NAME()'.
+ 	For a function that takes no arguments, PROTOTYPE should be `(void)'.
+ 
+    obsolete --     PROTO (type, name, (prototype)    -- obsolete.
+ 
+ 	This one has also been replaced by PARAMS.  Do not use.
+ 
+    PARAMS ((args))
+ 
+ 	We could use the EXFUN macro to handle prototype declarations, but
+ 	the name is misleading and the result is ugly.  So we just define a
+ 	simple macro to handle the parameter lists, as in:
+ 
+ 	      static int foo PARAMS ((int, char));
+ 
+ 	This produces:  `static int foo();' or `static int foo (int, char);'
+ 
+ 	EXFUN would have done it like this:
+ 
+ 	      static int EXFUN (foo, (int, char));
+ 
+ 	but the function is not external...and it's hard to visually parse
+ 	the function name out of the mess.   EXFUN should be considered
+ 	obsolete; new code should be written to use PARAMS.
+ 
+    DOTS is also obsolete.
+ 
+    Examples:
+ 
+ 	extern int printf PARAMS ((const char *format, ...));
+ */
+ 
+ #ifndef	_ANSIDECL_H
+ 
+ #define	_ANSIDECL_H	1
+ 
+ 
+ /* Every source file includes this file,
+    so they will all get the switch for lint.  */
+ /* LINTLIBRARY */
+ 
+ 
+ #if defined (__STDC__) || defined (_AIX) || (defined (__mips) && defined (_SYSTYPE_SVR4)) || defined(_WIN32)
+ /* All known AIX compilers implement these things (but don't always
+    define __STDC__).  The RISC/OS MIPS compiler defines these things
+    in SVR4 mode, but does not define __STDC__.  */
+ 
+ #define	PTR		void *
+ #define	PTRCONST	void *CONST
+ #define	LONG_DOUBLE	long double
+ 
+ #ifndef IN_GCC
+ #define	AND		,
+ #define	NOARGS		void
+ #define	VOLATILE	volatile
+ #define	SIGNED		signed
+ #endif /* ! IN_GCC */
+ 
+ #define PARAMS(paramlist)		paramlist
+ #define ANSI_PROTOTYPES			1
+ 
+ #define VPARAMS(ARGS)			ARGS
+ #define VA_START(va_list,var)		va_start(va_list,var)
+ 
+ /* These are obsolete.  Do not use.  */
+ #ifndef IN_GCC
+ #define CONST				const
+ #define DOTS				, ...
+ #define PROTO(type, name, arglist)	type name arglist
+ #define EXFUN(name, proto)		name proto
+ #define DEFUN(name, arglist, args)	name(args)
+ #define DEFUN_VOID(name)		name(void)
+ #endif /* ! IN_GCC */
+ 
+ #else	/* Not ANSI C.  */
+ 
+ #define	PTR		char *
+ #define	PTRCONST	PTR
+ #define	LONG_DOUBLE	double
+ 
+ #ifndef IN_GCC
+ #define	AND		;
+ #define	NOARGS
+ #define	VOLATILE
+ #define	SIGNED
+ #endif /* !IN_GCC */
+ 
+ #ifndef const /* some systems define it in header files for non-ansi mode */
+ #define	const
+ #endif
+ 
+ #define PARAMS(paramlist)		()
+ 
+ #define VPARAMS(ARGS)			(va_alist) va_dcl
+ #define VA_START(va_list,var)		va_start(va_list)
+ 
+ /* These are obsolete.  Do not use.  */
+ #ifndef IN_GCC
+ #define CONST
+ #define DOTS
+ #define PROTO(type, name, arglist)	type name ()
+ #define EXFUN(name, proto)		name()
+ #define DEFUN(name, arglist, args)	name arglist args;
+ #define DEFUN_VOID(name)		name()
+ #endif /* ! IN_GCC */
+ 
+ #endif	/* ANSI C.  */
+ 
+ #endif	/* ansidecl.h	*/
+ /* ANSI and traditional C compatability macros
+    Copyright 1991, 1992, 1996 Free Software Foundation, Inc.
+    This file is part of the GNU C Library.
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+ 
+ /* ANSI and traditional C compatibility macros
+ 
+    ANSI C is assumed if __STDC__ is #defined.
+ 
+    Macro	ANSI C definition	Traditional C definition
+    -----	---- - ----------	----------- - ----------
+    PTR		`void *'		`char *'
+    LONG_DOUBLE	`long double'		`double'
+    VOLATILE	`volatile'		`'
+    SIGNED	`signed'		`'
+    PTRCONST	`void *const'		`char *'
+    ANSI_PROTOTYPES  1			not defined
+ 
+    CONST is also defined, but is obsolete.  Just use const.
+ 
+    obsolete --     DEFUN (name, arglist, args)
+ 
+ 	Defines function NAME.
+ 
+ 	ARGLIST lists the arguments, separated by commas and enclosed in
+ 	parentheses.  ARGLIST becomes the argument list in traditional C.
+ 
+ 	ARGS list the arguments with their types.  It becomes a prototype in
+ 	ANSI C, and the type declarations in traditional C.  Arguments should
+ 	be separated with `AND'.  For functions with a variable number of
+ 	arguments, the last thing listed should be `DOTS'.
+ 
+    obsolete --     DEFUN_VOID (name)
+ 
+ 	Defines a function NAME, which takes no arguments.
+ 
+    obsolete --     EXFUN (name, (prototype))	-- obsolete.
+ 
+ 	Replaced by PARAMS.  Do not use; will disappear someday soon.
+ 	Was used in external function declarations.
+ 	In ANSI C it is `NAME PROTOTYPE' (so PROTOTYPE should be enclosed in
+ 	parentheses).  In traditional C it is `NAME()'.
+ 	For a function that takes no arguments, PROTOTYPE should be `(void)'.
+ 
+    obsolete --     PROTO (type, name, (prototype)    -- obsolete.
+ 
+ 	This one has also been replaced by PARAMS.  Do not use.
+ 
+    PARAMS ((args))
+ 
+ 	We could use the EXFUN macro to handle prototype declarations, but
+ 	the name is misleading and the result is ugly.  So we just define a
+ 	simple macro to handle the parameter lists, as in:
+ 
+ 	      static int foo PARAMS ((int, char));
+ 
+ 	This produces:  `static int foo();' or `static int foo (int, char);'
+ 
+ 	EXFUN would have done it like this:
+ 
+ 	      static int EXFUN (foo, (int, char));
+ 
+ 	but the function is not external...and it's hard to visually parse
+ 	the function name out of the mess.   EXFUN should be considered
+ 	obsolete; new code should be written to use PARAMS.
+ 
+    DOTS is also obsolete.
+ 
+    Examples:
+ 
+ 	extern int printf PARAMS ((const char *format, ...));
+ */
+ 
+ #ifndef	_ANSIDECL_H
+ 
+ #define	_ANSIDECL_H	1
+ 
+ 
+ /* Every source file includes this file,
+    so they will all get the switch for lint.  */
+ /* LINTLIBRARY */
+ 
+ 
+ #if defined (__STDC__) || defined (_AIX) || (defined (__mips) && defined (_SYSTYPE_SVR4)) || defined(_WIN32)
+ /* All known AIX compilers implement these things (but don't always
+    define __STDC__).  The RISC/OS MIPS compiler defines these things
+    in SVR4 mode, but does not define __STDC__.  */
+ 
+ #define	PTR		void *
+ #define	PTRCONST	void *CONST
+ #define	LONG_DOUBLE	long double
+ 
+ #ifndef IN_GCC
+ #define	AND		,
+ #define	NOARGS		void
+ #define	VOLATILE	volatile
+ #define	SIGNED		signed
+ #endif /* ! IN_GCC */
+ 
+ #define PARAMS(paramlist)		paramlist
+ #define ANSI_PROTOTYPES			1
+ 
+ #define VPARAMS(ARGS)			ARGS
+ #define VA_START(va_list,var)		va_start(va_list,var)
+ 
+ /* These are obsolete.  Do not use.  */
+ #ifndef IN_GCC
+ #define CONST				const
+ #define DOTS				, ...
+ #define PROTO(type, name, arglist)	type name arglist
+ #define EXFUN(name, proto)		name proto
+ #define DEFUN(name, arglist, args)	name(args)
+ #define DEFUN_VOID(name)		name(void)
+ #endif /* ! IN_GCC */
+ 
+ #else	/* Not ANSI C.  */
+ 
+ #define	PTR		char *
+ #define	PTRCONST	PTR
+ #define	LONG_DOUBLE	double
+ 
+ #ifndef IN_GCC
+ #define	AND		;
+ #define	NOARGS
+ #define	VOLATILE
+ #define	SIGNED
+ #endif /* !IN_GCC */
+ 
+ #ifndef const /* some systems define it in header files for non-ansi mode */
+ #define	const
+ #endif
+ 
+ #define PARAMS(paramlist)		()
+ 
+ #define VPARAMS(ARGS)			(va_alist) va_dcl
+ #define VA_START(va_list,var)		va_start(va_list)
+ 
+ /* These are obsolete.  Do not use.  */
+ #ifndef IN_GCC
+ #define CONST
+ #define DOTS
+ #define PROTO(type, name, arglist)	type name ()
+ #define EXFUN(name, proto)		name()
+ #define DEFUN(name, arglist, args)	name arglist args;
+ #define DEFUN_VOID(name)		name()
+ #endif /* ! IN_GCC */
+ 
+ #endif	/* ANSI C.  */
+ 
+ #endif	/* ansidecl.h	*/
+ /* ANSI and traditional C compatability macros
+    Copyright 1991, 1992, 1996 Free Software Foundation, Inc.
+    This file is part of the GNU C Library.
+ 
+ This program is free software; you can redistribute it and/or modify
+ it under the terms of the GNU General Public License as published by
+ the Free Software Foundation; either version 2 of the License, or
+ (at your option) any later version.
+ 
+ This program is distributed in the hope that it will be useful,
+ but WITHOUT ANY WARRANTY; without even the implied warranty of
+ MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ GNU General Public License for more details.
+ 
+ You should have received a copy of the GNU General Public License
+ along with this program; if not, write to the Free Software
+ Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
+ 
+ /* ANSI and traditional C compatibility macros
+ 
+    ANSI C is assumed if __STDC__ is #defined.
+ 
+    Macro	ANSI C definition	Traditional C definition
+    -----	---- - ----------	----------- - ----------
+    PTR		`void *'		`char *'
+    LONG_DOUBLE	`long double'		`double'
+    VOLATILE	`volatile'		`'
+    SIGNED	`signed'		`'
+    PTRCONST	`void *const'		`char *'
+    ANSI_PROTOTYPES  1			not defined
+ 
+    CONST is also defined, but is obsolete.  Just use const.
+ 
+    obsolete --     DEFUN (name, arglist, args)
+ 
+ 	Defines function NAME.
+ 
+ 	ARGLIST lists the arguments, separated by commas and enclosed in
+ 	parentheses.  ARGLIST becomes the argument list in traditional C.
+ 
+ 	ARGS list the arguments with their types.  It becomes a prototype in
+ 	ANSI C, and the type declarations in traditional C.  Arguments should
+ 	be separated with `AND'.  For functions with a variable number of
+ 	arguments, the last thing listed should be `DOTS'.
+ 
+    obsolete --     DEFUN_VOID (name)
+ 
+ 	Defines a function NAME, which takes no arguments.
+ 
+    obsolete --     EXFUN (name, (prototype))	-- obsolete.
+ 
+ 	Replaced by PARAMS.  Do not use; will disappear someday soon.
+ 	Was used in external function declarations.
+ 	In ANSI C it is `NAME PROTOTYPE' (so PROTOTYPE should be enclosed in
+ 	parentheses).  In traditional C it is `NAME()'.
+ 	For a function that takes no arguments, PROTOTYPE should be `(void)'.
+ 
+    obsolete --     PROTO (type, name, (prototype)    -- obsolete.
+ 
+ 	This one has also been replaced by PARAMS.  Do not use.
+ 
+    PARAMS ((args))
+ 
+ 	We could use the EXFUN macro to handle prototype declarations, but
+ 	the name is misleading and the result is ugly.  So we just define a
+ 	simple macro to handle the parameter lists, as in:
+ 
+ 	      static int foo PARAMS ((int, char));
+ 
+ 	This produces:  `static int foo();' or `static int foo (int, char);'
+ 
+ 	EXFUN would have done it like this:
+ 
+ 	      static int EXFUN (foo, (int, char));
+ 
+ 	but the function is not external...and it's hard to visually parse
+ 	the function name out of the mess.   EXFUN should be considered
+ 	obsolete; new code should be written to use PARAMS.
+ 
+    DOTS is also obsolete.
+ 
+    Examples:
+ 
+ 	extern int printf PARAMS ((const char *format, ...));
+ */
+ 
+ #ifndef	_ANSIDECL_H
+ 
+ #define	_ANSIDECL_H	1
+ 
+ 
+ /* Every source file includes this file,
+    so they will all get the switch for lint.  */
+ /* LINTLIBRARY */
+ 
+ 
+ #if defined (__STDC__) || defined (_AIX) || (defined (__mips) && defined (_SYSTYPE_SVR4)) || defined(_WIN32)
+ /* All known AIX compilers implement these things (but don't always
+    define __STDC__).  The RISC/OS MIPS compiler defines these things
+    in SVR4 mode, but does not define __STDC__.  */
+ 
+ #define	PTR		void *
+ #define	PTRCONST	void *CONST
+ #define	LONG_DOUBLE	long double
+ 
+ #ifndef IN_GCC
+ #define	AND		,
+ #define	NOARGS		void
+ #define	VOLATILE	volatile
+ #define	SIGNED		signed
+ #endif /* ! IN_GCC */
+ 
+ #define PARAMS(paramlist)		paramlist
+ #define ANSI_PROTOTYPES			1
+ 
+ #define VPARAMS(ARGS)			ARGS
+ #define VA_START(va_list,var)		va_start(va_list,var)
+ 
+ /* These are obsolete.  Do not use.  */
+ #ifndef IN_GCC
+ #define CONST				const
+ #define DOTS				, ...
+ #define PROTO(type, name, arglist)	type name arglist
+ #define EXFUN(name, proto)		name proto
+ #define DEFUN(name, arglist, args)	name(args)
+ #define DEFUN_VOID(name)		name(void)
+ #endif /* ! IN_GCC */
+ 
+ #else	/* Not ANSI C.  */
+ 
+ #define	PTR		char *
+ #define	PTRCONST	PTR
+ #define	LONG_DOUBLE	double
+ 
+ #ifndef IN_GCC
+ #define	AND		;
+ #define	NOARGS
+ #define	VOLATILE
+ #define	SIGNED
+ #endif /* !IN_GCC */
+ 
+ #ifndef const /* some systems define it in header files for non-ansi mode */
+ #define	const
+ #endif
+ 
+ #define PARAMS(paramlist)		()
+ 
+ #define VPARAMS(ARGS)			(va_alist) va_dcl
+ #define VA_START(va_list,var)		va_start(va_list)
+ 
+ /* These are obsolete.  Do not use.  */
+ #ifndef IN_GCC
+ #define CONST
+ #define DOTS
+ #define PROTO(type, name, arglist)	type name ()
+ #define EXFUN(name, proto)		name()
+ #define DEFUN(name, arglist, args)	name arglist args;
+ #define DEFUN_VOID(name)		name()
+ #endif /* ! IN_GCC */
+ 
+ #endif	/* ANSI C.  */
+ 
+ #endif	/* ansidecl.h	*/
diff -rc gcc-2.8.1.orig/bc-emit.c gcc-2.8.1/bc-emit.c
*** gcc-2.8.1.orig/bc-emit.c	1997-08-22 19:32:03.000000000 +0200
--- gcc-2.8.1/bc-emit.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 39,46 ****
  #include "bc-typecd.h"
  #include "bi-run.h"
  
- extern char *xmalloc (), *xrealloc ();
- 
  extern struct obstack *rtl_obstack;
  
  /* Indexed by mode class, gives the narrowest mode for each class.  */
--- 39,44 ----
diff -rc gcc-2.8.1.orig/bc-optab.c gcc-2.8.1/bc-optab.c
*** gcc-2.8.1.orig/bc-optab.c	1997-11-27 22:22:13.000000000 +0100
--- gcc-2.8.1/bc-optab.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 36,43 ****
  #define obstack_chunk_alloc xmalloc
  #define obstack_chunk_free free
  
- extern char *xmalloc ();
- 
  /* Table relating interpreter typecodes to machine modes.  */
  #define GET_TYPECODE_MODE(CODE) (typecode_mode[((int) CODE)])
  enum machine_mode typecode_mode[] = {
--- 36,41 ----
diff -rc gcc-2.8.1.orig/bc-typecd.def gcc-2.8.1/bc-typecd.def
*** gcc-2.8.1.orig/bc-typecd.def	1996-10-09 13:24:17.000000000 +0200
--- gcc-2.8.1/bc-typecd.def	2006-03-13 23:21:10.000000000 +0100
***************
*** 14,20 ****
  DEFTYPECODE (SUcode, "SU", SImode, SUtype)
  DEFTYPECODE (DIcode, "DI", DImode, DItype)
  DEFTYPECODE (DUcode, "DU", DImode, DUtype)
! DEFTYPECODE (SFcode, "SF", SFmode, SFtype)
  DEFTYPECODE (DFcode, "DF", DFmode, DFtype)
  DEFTYPECODE (XFcode, "XF", XFmode, XFtype)
  DEFTYPECODE (Pcode, "P", PSImode, Ptype)
--- 14,20 ----
  DEFTYPECODE (SUcode, "SU", SImode, SUtype)
  DEFTYPECODE (DIcode, "DI", DImode, DItype)
  DEFTYPECODE (DUcode, "DU", DImode, DUtype)
! DEFTYPECODE (SFcode, "SF", SFmode, /*SFtype*/ double)
  DEFTYPECODE (DFcode, "DF", DFmode, DFtype)
  DEFTYPECODE (XFcode, "XF", XFmode, XFtype)
  DEFTYPECODE (Pcode, "P", PSImode, Ptype)
diff -rc gcc-2.8.1.orig/bi-opcode.c gcc-2.8.1/bi-opcode.c
*** gcc-2.8.1.orig/bi-opcode.c	1998-02-18 20:46:05.000000000 +0100
--- gcc-2.8.1/bi-opcode.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 52,58 ****
    if (i > 256)
      fprintf (stderr, "%s: warning, number of opcodes is %d\n", *argv, i);
    else
!     fprintf (stderr, "(Number of opcodes is %d)\n", i);
  
    fflush (stdout);
    exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);
--- 52,58 ----
    if (i > 256)
      fprintf (stderr, "%s: warning, number of opcodes is %d\n", *argv, i);
    else
!     /*fprintf (stderr, "(Number of opcodes is %d)\n", i)*/;
  
    fflush (stdout);
    exit (ferror (stdout) != 0 ? FATAL_EXIT_CODE : SUCCESS_EXIT_CODE);
diff -rc gcc-2.8.1.orig/c-aux-info.c gcc-2.8.1/c-aux-info.c
*** gcc-2.8.1.orig/c-aux-info.c	1997-12-02 00:43:32.000000000 +0100
--- gcc-2.8.1/c-aux-info.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 27,34 ****
  #include "tree.h"
  #include "c-tree.h"
  
- extern char *xmalloc ();
- 
  enum formals_style_enum {
    ansi,
    k_and_r_names,
--- 27,32 ----
diff -rc gcc-2.8.1.orig/choose-temp.c gcc-2.8.1/choose-temp.c
*** gcc-2.8.1.orig/choose-temp.c	1997-12-04 15:17:56.000000000 +0100
--- gcc-2.8.1/choose-temp.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 17,22 ****
--- 17,24 ----
  write to the Free Software Foundation, Inc., 59 Temple Place - Suite 330,
  Boston, MA 02111-1307, USA.  */
  
+ extern char *getenv (const char *);
+ 
  /* This file exports one function: choose_temp_base.  */
  
  /* This file lives in at least two places: libiberty and gcc.
diff -rc gcc-2.8.1.orig/config/i386/freebsd.h gcc-2.8.1/config/i386/freebsd.h
*** gcc-2.8.1.orig/config/i386/freebsd.h	1997-10-19 18:31:05.000000000 +0200
--- gcc-2.8.1/config/i386/freebsd.h	2006-03-13 23:21:10.000000000 +0100
***************
*** 21,27 ****
--- 21,29 ----
  Boston, MA 02111-1307, USA.  */
  
  /* This goes away when the math-emulator is fixed */
+ #ifndef TARGET_CPU_DEFAULT
  #define TARGET_CPU_DEFAULT 0400		/* TARGET_NO_FANCY_MATH_387 */
+ #endif
  
  /* This is tested by i386gas.h.  */
  #define YES_UNDERSCORES
diff -rc gcc-2.8.1.orig/config/i386/go32.h gcc-2.8.1/config/i386/go32.h
*** gcc-2.8.1.orig/config/i386/go32.h	1997-08-08 22:18:23.000000000 +0200
--- gcc-2.8.1/config/i386/go32.h	2006-03-13 23:21:10.000000000 +0100
***************
*** 16,24 ****
  #ifdef CPP_PREDEFINES
  #undef CPP_PREDEFINES
  #endif
! #define CPP_PREDEFINES "-Dunix -Di386 -DGO32 -DMSDOS \
    -Asystem(unix) -Asystem(msdos) -Acpu(i386) -Amachine(i386)"
  
  #undef EXTRA_SECTIONS
  #define EXTRA_SECTIONS in_ctor, in_dtor
  
--- 16,32 ----
  #ifdef CPP_PREDEFINES
  #undef CPP_PREDEFINES
  #endif
! #define CPP_PREDEFINES "-Dunix -Di386 -DGO32 -DMSDOS -DDJGPP=2 \
    -Asystem(unix) -Asystem(msdos) -Acpu(i386) -Amachine(i386)"
  
+ #define LINK_COMMAND_SPEC \
+   "%{!c:%{!M:%{!MM:%{!E:%{!S:ld %l %X %{o*} %{A} %{d} %{e*} %{m} %{N} %{n}" \
+   "       %{r} %{s} %{t} %{u*} %{x} %{z}" \
+   "       %{!A:%{!nostartfiles:%{!nostdlib:%S}}} %{static:}" \
+   "       %{L*} %D %{T*} %o -Tdjgpp.djl" \
+   "       %{!nostdlib:-lgcc %L -lgcc %{!A:%E}}}}}}}\n" \
+   "%{!c:%{!M:%{!MM:%{!E:%{!S:stubify %{v} %{o*:%*} %{!o*:a.out} }}}}}"
+ 
  #undef EXTRA_SECTIONS
  #define EXTRA_SECTIONS in_ctor, in_dtor
  
diff -rc gcc-2.8.1.orig/config/i386/xm-dos.h gcc-2.8.1/config/i386/xm-dos.h
*** gcc-2.8.1.orig/config/i386/xm-dos.h	1997-11-20 21:29:01.000000000 +0100
--- gcc-2.8.1/config/i386/xm-dos.h	2006-03-13 23:21:10.000000000 +0100
***************
*** 1,3 ****
--- 1,7 ----
+ #define __MSDOS__ 1
+ 
+ #define NO_STAB_H
+ 
  #include "i386/xm-i386.h"
  
  /* Use semicolons to separate elements of a path.  */
diff -rc gcc-2.8.1.orig/config/i386/xm-go32.h gcc-2.8.1/config/i386/xm-go32.h
*** gcc-2.8.1.orig/config/i386/xm-go32.h	1998-02-12 13:15:12.000000000 +0100
--- gcc-2.8.1/config/i386/xm-go32.h	2006-03-13 23:21:10.000000000 +0100
***************
*** 27,30 ****
--- 27,38 ----
  /* Use semicolons to separate elements of a path.  */
  #define PATH_SEPARATOR ';'
  
+ /* Use backslashs to separate levels of directory.  */
+ #define DIR_SEPARATOR '\\'
+ 
+ /* Suffix for executable file names.  */
  #define EXECUTABLE_SUFFIX ".exe"
+ 
+ #define MKTEMP_EACH_FILE 1
+ 
+ #define NO_PRECOMPILES 1
diff -rc gcc-2.8.1.orig/config/sparc/t-sol2 gcc-2.8.1/config/sparc/t-sol2
*** gcc-2.8.1.orig/config/sparc/t-sol2	1997-06-10 01:06:39.000000000 +0200
--- gcc-2.8.1/config/sparc/t-sol2	2006-03-13 23:21:10.000000000 +0100
***************
*** 12,24 ****
  
  # Assemble startup files.
  crt1.o: $(srcdir)/config/sparc/sol2-c1.asm $(GCC_PASSES)
! 	$(GCC_FOR_TARGET) -c -o crt1.o -x assembler $(srcdir)/config/sparc/sol2-c1.asm
  crti.o: $(srcdir)/config/sparc/sol2-ci.asm $(GCC_PASSES)
! 	$(GCC_FOR_TARGET) -c -o crti.o -x assembler $(srcdir)/config/sparc/sol2-ci.asm
  crtn.o: $(srcdir)/config/sparc/sol2-cn.asm $(GCC_PASSES)
! 	$(GCC_FOR_TARGET) -c -o crtn.o -x assembler $(srcdir)/config/sparc/sol2-cn.asm
  gcrt1.o: $(srcdir)/config/sparc/sol2-g1.asm $(GCC_PASSES)
! 	$(GCC_FOR_TARGET) -c -o gcrt1.o -x assembler $(srcdir)/config/sparc/sol2-g1.asm
  
  # We need to use -fPIC when we are using gcc to compile the routines in
  # crtstuff.c.  This is only really needed when we are going to use gcc/g++
--- 12,24 ----
  
  # Assemble startup files.
  crt1.o: $(srcdir)/config/sparc/sol2-c1.asm $(GCC_PASSES)
! 	$(GCC_FOR_TARGET) -c -o crt1.o -x assembler $(srcdir)/config/sparc/sol2-c1.asm 2>tmpfile || (cat tmpfile && false)
  crti.o: $(srcdir)/config/sparc/sol2-ci.asm $(GCC_PASSES)
! 	$(GCC_FOR_TARGET) -c -o crti.o -x assembler $(srcdir)/config/sparc/sol2-ci.asm 2>tmpfile || (cat tmpfile && false)
  crtn.o: $(srcdir)/config/sparc/sol2-cn.asm $(GCC_PASSES)
! 	$(GCC_FOR_TARGET) -c -o crtn.o -x assembler $(srcdir)/config/sparc/sol2-cn.asm 2>tmpfile || (cat tmpfile && false)
  gcrt1.o: $(srcdir)/config/sparc/sol2-g1.asm $(GCC_PASSES)
! 	$(GCC_FOR_TARGET) -c -o gcrt1.o -x assembler $(srcdir)/config/sparc/sol2-g1.asm 2>tmpfile || (cat tmpfile && false)
  
  # We need to use -fPIC when we are using gcc to compile the routines in
  # crtstuff.c.  This is only really needed when we are going to use gcc/g++
diff -rc gcc-2.8.1.orig/config.in gcc-2.8.1/config.in
*** gcc-2.8.1.orig/config.in	1998-02-06 19:51:33.000000000 +0100
--- gcc-2.8.1/config.in	2006-03-13 23:26:18.000000000 +0100
***************
*** 1,4 ****
! /* config.in.  Generated automatically from configure.in by autoheader.  */
  /* Define if you have a working <inttypes.h> header file.  */
  #undef HAVE_INTTYPES_H
  
--- 1,7 ----
! /* config.in.  Generated automatically from configure.in by autoheader 2.13.  */
! /* Define if you can safely include both <string.h> and <strings.h>.  */
! #undef STRING_WITH_STRINGS
! 
  /* Define if you have a working <inttypes.h> header file.  */
  #undef HAVE_INTTYPES_H
  
diff -rc gcc-2.8.1.orig/configure gcc-2.8.1/configure
*** gcc-2.8.1.orig/configure	1998-03-01 03:02:02.000000000 +0100
--- gcc-2.8.1/configure	2006-03-13 23:21:10.000000000 +0100
***************
*** 5597,5603 ****
  			echo "${srcdir}/$s/config-lang.in doesn't set \$language." 1>&2
  			exit 1
  		fi
! 		all_lang_makefiles="$all_lang_makefiles ${srcdir}/$s/Make-lang.in ${srcdir}/$s/Makefile.in"
  		all_languages="$all_languages $language"
  		if [ "x$boot_language" = xyes ]
  		then
--- 5597,5606 ----
  			echo "${srcdir}/$s/config-lang.in doesn't set \$language." 1>&2
  			exit 1
  		fi
! 		all_lang_makefiles="$all_lang_makefiles ${srcdir}/$s/Make-lang.in"
! 		if test -f ${srcdir}/$s/Makefile.in
! 		then all_lang_makefiles="$all_lang_makefiles ${srcdir}/$s/Makefile.in"
! 		fi
  		all_languages="$all_languages $language"
  		if [ "x$boot_language" = xyes ]
  		then
diff -rc gcc-2.8.1.orig/configure.in gcc-2.8.1/configure.in
*** gcc-2.8.1.orig/configure.in	1998-02-28 21:58:12.000000000 +0100
--- gcc-2.8.1/configure.in	2006-03-13 23:21:10.000000000 +0100
***************
*** 134,139 ****
--- 134,140 ----
  
  AC_HEADER_STDC
  AC_HEADER_TIME
+ GCC_HEADER_STRING
  AC_CHECK_HEADERS(limits.h stddef.h string.h strings.h stdlib.h time.h fcntl.h unistd.h sys/file.h sys/time.h sys/resource.h sys/param.h sys/times.h)
  
  # Use <inttypes.h> only if it exists,
diff -rc gcc-2.8.1.orig/configure.lang gcc-2.8.1/configure.lang
*** gcc-2.8.1.orig/configure.lang	1997-12-03 14:10:19.000000000 +0100
--- gcc-2.8.1/configure.lang	2006-03-13 23:21:10.000000000 +0100
***************
*** 50,55 ****
--- 50,56 ----
  	test -d $subdir || mkdir $subdir
  	cd $subdir
  
+ if test -f Makefile.in; then
  	# Create Makefile.tem from Makefile.in.
  	# Make it set VPATH if necessary so that the sources are found.
  	# Also change its value of srcdir.
***************
*** 157,162 ****
--- 158,164 ----
  		mv Makefile.xx Makefile.tem
  		rm -f Makefile.ll
  	fi
+ fi
  
  	# If the host supports
  	# symlinks, point stage[123] at ../stage[123] so bootstrapping and the
***************
*** 169,174 ****
--- 171,177 ----
  		$symbolic_link ../$t $t 2>/dev/null
  	done
  
+ if test -f Makefile.in; then
  	# Remove all formfeeds, since some Makes get confused by them.
  	# Also arrange to give the variables `target', `target_alias',
  	# `host_xmake_file', `tmake_file', `prefix', `local_prefix',
***************
*** 225,230 ****
--- 228,234 ----
  	rm -f Makefile
  	mv Makefile.tem Makefile
  	echo "Created \`$subdir/Makefile'."
+ fi
  
  	cd $STARTDIR
  done   # end of current-dir SUBDIRS loop
diff -rc gcc-2.8.1.orig/convert.c gcc-2.8.1/convert.c
*** gcc-2.8.1.orig/convert.c	1997-08-07 12:44:17.000000000 +0200
--- gcc-2.8.1/convert.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 288,294 ****
--- 288,299 ----
  
  		/* Can't do arithmetic in enumeral types
  		   so use an integer type that will hold the values.  */
+ #ifdef GPC
+ 		if (TREE_CODE (typex) == ENUMERAL_TYPE
+ 		    || TREE_CODE (typex) == BOOLEAN_TYPE)
+ #else /* not GPC */
  		if (TREE_CODE (typex) == ENUMERAL_TYPE)
+ #endif /* not GPC */
  		  typex = type_for_size (TYPE_PRECISION (typex),
  					 TREE_UNSIGNED (typex));
  
***************
*** 326,332 ****
--- 331,343 ----
  
  	    /* Can't do arithmetic in enumeral types
  	       so use an integer type that will hold the values.  */
+ #ifdef GPC
+ 	    if (TREE_CODE (typex) == ENUMERAL_TYPE
+ 		|| TREE_CODE (typex) == CHAR_TYPE
+ 		|| TREE_CODE (typex) == BOOLEAN_TYPE)
+ #else /* not GPC */
  	    if (TREE_CODE (typex) == ENUMERAL_TYPE)
+ #endif /* not GPC */
  	      typex = type_for_size (TYPE_PRECISION (typex),
  				     TREE_UNSIGNED (typex));
  
diff -rc gcc-2.8.1.orig/dbxout.c gcc-2.8.1/dbxout.c
*** gcc-2.8.1.orig/dbxout.c	1997-10-23 14:03:03.000000000 +0200
--- gcc-2.8.1/dbxout.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 780,793 ****
    tree type_encoding;
    register tree fndecl;
    register tree last;
    char formatted_type_identifier_length[16];
    register int type_identifier_length;
! 
    if (methods == NULL_TREE)
      return;
  
    type_encoding = DECL_NAME (TYPE_NAME (type));
! 
  #if 0
    /* C++: Template classes break some assumptions made by this code about
       the class names, constructor names, and encodings for assembler
--- 780,797 ----
    tree type_encoding;
    register tree fndecl;
    register tree last;
+ #ifndef GPC
    char formatted_type_identifier_length[16];
    register int type_identifier_length;
! #endif
!   
    if (methods == NULL_TREE)
      return;
  
+ #ifndef GPC
    type_encoding = DECL_NAME (TYPE_NAME (type));
! #endif
!   
  #if 0
    /* C++: Template classes break some assumptions made by this code about
       the class names, constructor names, and encodings for assembler
***************
*** 812,821 ****
    }
  #endif
  
    type_identifier_length = IDENTIFIER_LENGTH (type_encoding);
  
    sprintf(formatted_type_identifier_length, "%d", type_identifier_length);
! 
    if (TREE_CODE (methods) == FUNCTION_DECL)
      fndecl = methods;
    else if (TREE_VEC_ELT (methods, 0) != NULL_TREE)
--- 816,827 ----
    }
  #endif
  
+ #ifndef GPC
    type_identifier_length = IDENTIFIER_LENGTH (type_encoding);
  
    sprintf(formatted_type_identifier_length, "%d", type_identifier_length);
! #endif
!   
    if (TREE_CODE (methods) == FUNCTION_DECL)
      fndecl = methods;
    else if (TREE_VEC_ELT (methods, 0) != NULL_TREE)
***************
*** 849,854 ****
--- 855,861 ----
  	  if (DECL_IGNORED_P (fndecl))
  	    continue;
  
+ #ifndef GPC
  	  if (flag_minimal_debug)
  	    {
  	      char marker;
***************
*** 914,919 ****
--- 921,927 ----
  		  need_prefix = 0;
  		}
  	    }
+ #endif
  
  	  dbxout_type (TREE_TYPE (fndecl), 0, show_arg_types);
  
***************
*** 1129,1134 ****
--- 1137,1146 ----
  	  fprintf (asmfile, ";0;127;");
  	}
        else if (use_gnu_debug_info_extensions
+ #ifdef GPC
+ 	       && TREE_CODE (TYPE_MIN_VALUE (type)) == INTEGER_CST
+ 	       && TREE_CODE (TYPE_MAX_VALUE (type)) == INTEGER_CST
+ #endif
  	       && (TYPE_PRECISION (type) > TYPE_PRECISION (integer_type_node)
  		   || TYPE_PRECISION (type) > HOST_BITS_PER_WIDE_INT))
  	{
***************
*** 1158,1164 ****
  
      case CHAR_TYPE:
        if (use_gnu_debug_info_extensions)
! 	fprintf (asmfile, "@s%d;-20;",
  		 BITS_PER_UNIT * int_size_in_bytes (type));
        else
  	{
--- 1170,1176 ----
  
      case CHAR_TYPE:
        if (use_gnu_debug_info_extensions)
! 	fprintf (asmfile, "@s%d;-20",
  		 BITS_PER_UNIT * int_size_in_bytes (type));
        else
  	{
***************
*** 1173,1179 ****
  
      case BOOLEAN_TYPE:
        if (use_gnu_debug_info_extensions)
! 	fprintf (asmfile, "@s%d;-16;",
  		 BITS_PER_UNIT * int_size_in_bytes (type));
        else /* Define as enumeral type (False, True) */
  	fprintf (asmfile, "eFalse:0,True:1,;");
--- 1185,1191 ----
  
      case BOOLEAN_TYPE:
        if (use_gnu_debug_info_extensions)
! 	fprintf (asmfile, "@s%d;-16",
  		 BITS_PER_UNIT * int_size_in_bytes (type));
        else /* Define as enumeral type (False, True) */
  	fprintf (asmfile, "eFalse:0,True:1,;");
diff -rc gcc-2.8.1.orig/demangle.h gcc-2.8.1/demangle.h
*** gcc-2.8.1.orig/demangle.h	1997-07-30 21:02:03.000000000 +0200
--- gcc-2.8.1/demangle.h	2006-03-13 23:21:10.000000000 +0100
***************
*** 22,28 ****
  
  #ifdef IN_GCC
  #include "gansidecl.h"
- #define PARAMS(ARGS) PROTO(ARGS)
  #else /* ! IN_GCC */
  #include <ansidecl.h>
  #endif /* IN_GCC */
--- 22,27 ----
diff -rc gcc-2.8.1.orig/dwarf2out.c gcc-2.8.1/dwarf2out.c
*** gcc-2.8.1.orig/dwarf2out.c	1998-02-28 21:58:13.000000000 +0100
--- gcc-2.8.1/dwarf2out.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 7068,7082 ****
        /* Else leave out the attribute.  */
        break;
  
-     case MAX_EXPR:
      case VAR_DECL:
      case COMPONENT_REF:
!       /* ??? These types of bounds can be created by the Ada front end,
! 	 and it isn't clear how to emit debug info for them.  */
        break;
  
      default:
!       abort ();
      }
  }
  
--- 7068,7084 ----
        /* Else leave out the attribute.  */
        break;
  
      case VAR_DECL:
      case COMPONENT_REF:
!     case PARM_DECL:
!       /* ??? These types of bounds as well as all kinds of expressions
!              can be created by the Ada and Pascal front ends,
!              and it isn't clear how to emit debug info for them.  */
        break;
  
      default:
!       if (TREE_CODE_CLASS (TREE_CODE (bound)) != 'e')
!         abort ();
      }
  }
  
***************
*** 7414,7420 ****
        if (i == 0)
  	{
  	  assert (scope_die == comp_unit_die);
! 	  assert (TREE_CODE_CLASS (TREE_CODE (containing_scope)) == 't');
  	  if (debug_info_level > DINFO_LEVEL_TERSE)
  	    assert (TREE_ASM_WRITTEN (containing_scope));
  	}
--- 7416,7423 ----
        if (i == 0)
  	{
  	  assert (scope_die == comp_unit_die);
! 	  assert (TREE_CODE_CLASS (TREE_CODE (containing_scope)) == 't'
! 	          || TREE_CODE_CLASS (TREE_CODE (containing_scope)) == 'd');
  	  if (debug_info_level > DINFO_LEVEL_TERSE)
  	    assert (TREE_ASM_WRITTEN (containing_scope));
  	}
diff -rc gcc-2.8.1.orig/dwarfout.h gcc-2.8.1/dwarfout.h
*** gcc-2.8.1.orig/dwarfout.h	2006-03-25 00:16:07.000000000 +0100
--- gcc-2.8.1/dwarfout.h	2006-03-13 23:21:10.000000000 +0100
***************
*** 0 ****
--- 1,4 ----
+ extern void dwarfout_define PARAMS((register unsigned, register char *));
+ extern void dwarfout_undef PARAMS((register unsigned, register char *));
+ extern void dwarfout_start_new_source_file PARAMS((register char *));
+ extern void dwarfout_resume_previous_source_file PARAMS((register unsigned));
diff -rc gcc-2.8.1.orig/expr.c gcc-2.8.1/expr.c
*** gcc-2.8.1.orig/expr.c	1998-03-04 03:32:19.000000000 +0100
--- gcc-2.8.1/expr.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 3961,3966 ****
--- 3961,3973 ----
  
        domain_min = convert (sizetype, TYPE_MIN_VALUE (domain));
        domain_max = convert (sizetype, TYPE_MAX_VALUE (domain));
+ 
+ #ifdef GPC
+       /* Align the set.  */
+       if (set_alignment)
+         domain_min = size_binop (BIT_AND_EXPR, domain_min, size_int (-set_alignment));
+ #endif /* GPC */
+ 
        bitlength = size_binop (PLUS_EXPR,
  			      size_binop (MINUS_EXPR, domain_max, domain_min),
  			      size_one_node);
***************
*** 3975,3981 ****
--- 3982,3990 ----
        if (GET_MODE (target) != BLKmode || nbits <= 2 * BITS_PER_WORD
  	  || (nbytes <= 32 && TREE_CHAIN (elt) != NULL_TREE))
  	{
+ #ifndef GPC
  	  int set_word_size = TYPE_ALIGN (TREE_TYPE (exp));
+ #endif /* not GPC */
  	  enum machine_mode mode = mode_for_size (set_word_size, MODE_INT, 1);
  	  char *bit_buffer = (char *) alloca (nbits);
  	  HOST_WIDE_INT word = 0;
***************
*** 3987,3996 ****
  	    {
  	      if (bit_buffer[ibit])
  		{
  		  if (BYTES_BIG_ENDIAN)
! 		    word |= (1 << (set_word_size - 1 - bit_pos));
  		  else
! 		    word |= 1 << bit_pos;
  		}
  	      bit_pos++;  ibit++;
  	      if (bit_pos >= set_word_size || ibit == nbits)
--- 3996,4009 ----
  	    {
  	      if (bit_buffer[ibit])
  		{
+ #ifdef GPC
+                   if (set_words_big_endian)
+ #else /* not GPC */
  		  if (BYTES_BIG_ENDIAN)
! #endif /* not GPC */
! 		    word |= ((HOST_WIDE_INT) 1 << (set_word_size - 1 - bit_pos));
  		  else
! 		    word |= (HOST_WIDE_INT) 1 << bit_pos;
  		}
  	      bit_pos++;  ibit++;
  	      if (bit_pos >= set_word_size || ibit == nbits)
***************
*** 4023,4028 ****
--- 4036,4043 ----
  	}
        else if (!cleared)
  	{
+    /* GPC expects bits outside the range to be cleared. (fjf1010.pas) */
+ #ifndef GPC
  	  /* Don't bother clearing storage if the set is all ones.  */
  	  if (TREE_CHAIN (elt) != NULL_TREE
  	      || (TREE_PURPOSE (elt) == NULL_TREE
***************
*** 4032,4037 ****
--- 4047,4053 ----
  		     || (TREE_INT_CST_LOW (TREE_VALUE (elt))
  			 - TREE_INT_CST_LOW (TREE_PURPOSE (elt)) + 1
  			 != nbits))))
+ #endif
  	    clear_storage (target, expr_size (exp),
  			   TYPE_ALIGN (type) / BITS_PER_UNIT);
  	}
***************
*** 4087,4092 ****
--- 4103,4114 ----
  	      && (startb = TREE_INT_CST_LOW (startbit)) % BITS_PER_UNIT == 0
  	      && (endb = TREE_INT_CST_LOW (endbit) + 1) % BITS_PER_UNIT == 0)
  	    {
+ #ifdef GPC
+               /* The language-specific run time library must provide
+                  a suitable `__setbits()' function whose action coincides
+                  with the values of `set_word_size', `set_alignment', and
+                  `set_words_big_endian'.  */
+ #endif /* GPC */
  	      emit_library_call (memset_libfunc, 0,
  				 VOIDmode, 3,
  				 plus_constant (XEXP (targetx, 0),
***************
*** 4412,4418 ****
--- 4434,4447 ----
  	  tree index_type = TREE_TYPE (index);
  
  	  if (! integer_zerop (low_bound))
+ #ifdef GPC
+ 	    index = convert (sizetype,
+ 	              size_binop (MINUS_EXPR,
+ 	                convert (integer_type_node, index),
+ 	                convert (integer_type_node, low_bound)));
+ #else
  	    index = fold (build (MINUS_EXPR, index_type, index, low_bound));
+ #endif
  
  	  if (TYPE_PRECISION (index_type) != TYPE_PRECISION (sizetype))
  	    {
***************
*** 5453,5458 ****
--- 5482,5501 ----
  	 store directly into the target unless the type is large enough
  	 that memcpy will be used.  If we are making an initializer and
  	 all operands are constant, put it in memory as well.  */
+ #ifdef GPC
+       else if (TREE_CODE (TREE_TYPE (exp)) != SET_TYPE
+ 	       &&
+ 	       ((TREE_STATIC (exp)
+ 		&& ((mode == BLKmode
+ 		     && !(target != 0 && safe_from_p (target, exp, 1)))
+ 		    || TREE_ADDRESSABLE (exp)
+ 		    || (TREE_CODE (TYPE_SIZE (type)) == INTEGER_CST
+ 			&& (move_by_pieces_ninsns
+ 			    (TREE_INT_CST_LOW (TYPE_SIZE (type)),
+ 			     TYPE_ALIGN (type))
+ 			    > MOVE_RATIO))))
+ 	       || (modifier == EXPAND_INITIALIZER && TREE_CONSTANT (exp))))
+ #else /* not GPC */
        else if ((TREE_STATIC (exp)
  		&& ((mode == BLKmode
  		     && ! (target != 0 && safe_from_p (target, exp, 1)))
***************
*** 5464,5469 ****
--- 5507,5513 ----
  			    > MOVE_RATIO)
  			&& ! mostly_zeros_p (exp))))
  	       || (modifier == EXPAND_INITIALIZER && TREE_CONSTANT (exp)))
+ #endif /* not GPC */
  	{
  	  rtx constructor = output_constant_def (exp);
  	  if (modifier != EXPAND_CONST_ADDRESS
***************
*** 5485,5492 ****
  	  if (target == 0 || ! safe_from_p (target, exp, 1)
  	      || GET_CODE (target) == PARALLEL)
  	    {
! 	      if (mode != BLKmode && ! TREE_ADDRESSABLE (exp))
! 		target = gen_reg_rtx (tmode != VOIDmode ? tmode : mode);
  	      else
  		target = assign_temp (type, 0, 1, 1);
  	    }
--- 5529,5537 ----
  	  if (target == 0 || ! safe_from_p (target, exp, 1)
  	      || GET_CODE (target) == PARALLEL)
  	    {
! 	      if (mode != BLKmode && tmode != BLKmode 
! 	          && ! TREE_ADDRESSABLE (exp))
! 		target = gen_reg_rtx ((tmode != VOIDmode)? tmode : mode);
  	      else
  		target = assign_temp (type, 0, 1, 1);
  	    }
***************
*** 6122,6127 ****
--- 6167,6182 ----
        if (modifier == EXPAND_INITIALIZER)
  	return gen_rtx (unsignedp ? ZERO_EXTEND : SIGN_EXTEND, mode, op0);
  
+       if (mode == BLKmode && GET_MODE (op0) != BLKmode 
+           && GET_CODE (op0) == MEM)
+ 	{
+           /* @@@@ ATM we should get here only for fake packed arrays
+ 	     constructors, for which alignment is OK */
+           op0 = copy_rtx (op0);
+           op0 = change_address (op0, TYPE_MODE (type), 0);
+ 	  return op0;
+         }
+       
        if (target == 0)
  	return
  	  convert_to_mode (mode, op0,
***************
*** 9051,9057 ****
  	  || (TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist))))
  	      != INTEGER_TYPE)
  	  || TREE_CHAIN (TREE_CHAIN (arglist)) == 0
! 	  || (INTEGER_CST
  	      != (TREE_CODE (TREE_TYPE
  			     (TREE_VALUE
  			      (TREE_CHAIN (TREE_CHAIN (arglist))))))))
--- 9106,9112 ----
  	  || (TREE_CODE (TREE_TYPE (TREE_VALUE (TREE_CHAIN (arglist))))
  	      != INTEGER_TYPE)
  	  || TREE_CHAIN (TREE_CHAIN (arglist)) == 0
! 	  || (INTEGER_TYPE
  	      != (TREE_CODE (TREE_TYPE
  			     (TREE_VALUE
  			      (TREE_CHAIN (TREE_CHAIN (arglist))))))))
diff -rc gcc-2.8.1.orig/fold-const.c gcc-2.8.1/fold-const.c
*** gcc-2.8.1.orig/fold-const.c	1998-02-28 21:58:15.000000000 +0100
--- gcc-2.8.1/fold-const.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 1225,1232 ****
--- 1225,1236 ----
      }
  
    TREE_OVERFLOW (t)
+ #ifdef GPC
+     = ((notrunc ? overflow : force_fit_type (t, overflow))
+ #else /* not GPC */
      = ((notrunc ? (!uns || forsize) && overflow
  	: force_fit_type (t, (!uns || forsize) && overflow) && ! no_overflow)
+ #endif /* not GPC */
         | TREE_OVERFLOW (arg1)
         | TREE_OVERFLOW (arg2));
    /* If we're doing a size calculation, unsigned arithmetic does overflow.
***************
*** 4201,4210 ****
  				    TREE_TYPE (TREE_TYPE (arg0)),
  				    TREE_OPERAND (arg0, 1))));
        else if (TREE_CODE (arg0) == COMPLEX_CST)
! 	return build_complex (type, TREE_OPERAND (arg0, 0),
  			      fold (build1 (NEGATE_EXPR,
  					    TREE_TYPE (TREE_TYPE (arg0)),
! 					    TREE_OPERAND (arg0, 1))));
        else if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)
  	return fold (build (TREE_CODE (arg0), type,
  			    fold (build1 (CONJ_EXPR, type,
--- 4205,4214 ----
  				    TREE_TYPE (TREE_TYPE (arg0)),
  				    TREE_OPERAND (arg0, 1))));
        else if (TREE_CODE (arg0) == COMPLEX_CST)
! 	return build_complex (type, TREE_REALPART (arg0),
  			      fold (build1 (NEGATE_EXPR,
  					    TREE_TYPE (TREE_TYPE (arg0)),
! 					    TREE_IMAGPART (arg0))));
        else if (TREE_CODE (arg0) == PLUS_EXPR || TREE_CODE (arg0) == MINUS_EXPR)
  	return fold (build (TREE_CODE (arg0), type,
  			    fold (build1 (CONJ_EXPR, type,
diff -rc gcc-2.8.1.orig/function.c gcc-2.8.1/function.c
*** gcc-2.8.1.orig/function.c	1998-02-28 21:58:16.000000000 +0100
--- gcc-2.8.1/function.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 1377,1383 ****
  
    /* If this is a variable-size object with a pseudo to address it,
       put that pseudo into the stack, if the var is nonlocal.  */
!   if (DECL_NONLOCAL (decl)
        && GET_CODE (reg) == MEM
        && GET_CODE (XEXP (reg, 0)) == REG
        && REGNO (XEXP (reg, 0)) > LAST_VIRTUAL_REGISTER)
--- 1377,1383 ----
  
    /* If this is a variable-size object with a pseudo to address it,
       put that pseudo into the stack, if the var is nonlocal.  */
!   if (TREE_CODE (decl) != SAVE_EXPR && DECL_NONLOCAL (decl)
        && GET_CODE (reg) == MEM
        && GET_CODE (XEXP (reg, 0)) == REG
        && REGNO (XEXP (reg, 0)) > LAST_VIRTUAL_REGISTER)
diff -rc gcc-2.8.1.orig/gansidecl.h gcc-2.8.1/gansidecl.h
*** gcc-2.8.1.orig/gansidecl.h	1998-02-14 17:31:43.000000000 +0100
--- gcc-2.8.1/gansidecl.h	2006-03-13 23:21:10.000000000 +0100
***************
*** 22,107 ****
     in binutils and gdb releases.
     ??? Over time the two should be merged into one.  */
  
! #ifndef	ANSIDECL_H
! #define	ANSIDECL_H
  
! /* Add prototype support.  */
! #ifndef PROTO
! #if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
! #define PROTO(ARGS) ARGS
! #else
! #define PROTO(ARGS) ()
! #endif
! #endif
  
! #ifndef VPROTO
! #ifdef __STDC__
! #define PVPROTO(ARGS)		ARGS
! #define VPROTO(ARGS)            ARGS
! #define VA_START(va_list,var)  va_start(va_list,var)
! #else
! #define PVPROTO(ARGS)		()
! #define VPROTO(ARGS)            (va_alist) va_dcl
! #define VA_START(va_list,var)  va_start(va_list)
! #endif
! #endif
! 
! /* Define a generic NULL if one hasn't already been defined.  */
! 
! #ifndef NULL
! #define NULL 0
! #endif
  
! #ifndef GENERIC_PTR
! #if defined (USE_PROTOTYPES) ? USE_PROTOTYPES : defined (__STDC__)
! #define GENERIC_PTR void *
! #else
! #define GENERIC_PTR char *
! #endif
! #endif
  
  #ifndef NULL_PTR
! #define NULL_PTR ((GENERIC_PTR) 0)
! #endif
! 
! #ifdef __STDC__
! 
! #define	PTR void *
! 
! #else
! 
! #define	PTR char *
! #ifndef const
! #define const
  #endif
  
! #endif /* ! __STDC__ */
! 
! /* We don't have autoconf for libgcc2.c since it's a target, so don't
!    define these functions, which aren't used there anyway.  */
! 
! #ifndef IN_LIBGCC2
! 
! #ifndef HAVE_BCOPY
! #define bcopy(src,dst,len) memcpy ((dst),(src),(len))
! #endif
! 
! #ifndef HAVE_BZERO
! #define bzero(dst,len) memset ((dst),0,(len))
! #endif
! 
! #ifndef HAVE_BCMP
! #define bcmp(left,right,len) memcmp ((left),(right),(len))
! #endif
! 
! #ifndef HAVE_RINDEX
! #define rindex strrchr
! #endif
! 
! #ifndef HAVE_INDEX
! #define index strchr
! #endif
! 
! #endif /* IN_LIBGCC2 */
! 
! #endif /* ANSIDECL_H */
--- 22,64 ----
     in binutils and gdb releases.
     ??? Over time the two should be merged into one.  */
  
! #ifndef	__GANSIDECL_H__
! #define	__GANSIDECL_H__
  
! #include "ansidecl.h"
  
! /* Undef ansidecl.h's "obsolete" version. */
! #undef PROTO
! /* These macros are deprecated, use ansidecl.h's PARAMS style instead. */
! #define PROTO(ARGS) PARAMS(ARGS)
! #define VPROTO(ARGS) VPARAMS(ARGS)
! #define PVPROTO(ARGS) PARAMS(ARGS)
! 
! #if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
! # define __attribute__(x)
! #endif
! 
! #ifndef ATTRIBUTE_UNUSED
! #define ATTRIBUTE_UNUSED __attribute__ ((__unused__))
! #endif /* ATTRIBUTE_UNUSED */
! 
! #ifndef ATTRIBUTE_NORETURN
! #define ATTRIBUTE_NORETURN __attribute__ ((__noreturn__))
! #endif /* ATTRIBUTE_NORETURN */
! 
! #ifndef ATTRIBUTE_PRINTF
! #define ATTRIBUTE_PRINTF(m, n) __attribute__ ((format (__printf__, m, n)))
! #define ATTRIBUTE_PRINTF_1 ATTRIBUTE_PRINTF(1, 2)
! #define ATTRIBUTE_PRINTF_2 ATTRIBUTE_PRINTF(2, 3)
! #define ATTRIBUTE_PRINTF_3 ATTRIBUTE_PRINTF(3, 4)
! #define ATTRIBUTE_PRINTF_4 ATTRIBUTE_PRINTF(4, 5)
! #define ATTRIBUTE_PRINTF_5 ATTRIBUTE_PRINTF(5, 6)
! #endif /* ATTRIBUTE_PRINTF */
  
! #define GENERIC_PTR PTR
  
  #ifndef NULL_PTR
! #define NULL_PTR ((PTR) 0)
  #endif
  
! #endif /* __GANSIDECL_H__ */
diff -rc gcc-2.8.1.orig/gcc.c gcc-2.8.1/gcc.c
*** gcc-2.8.1.orig/gcc.c	1998-02-28 21:58:17.000000000 +0100
--- gcc-2.8.1/gcc.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 710,715 ****
--- 710,720 ----
  /* We want %{T*} after %{L*} and %D so that it can be used to specify linker
     scripts which exist in user specified directories, or in standard
     directories.  */
+ #ifdef LINK_COMMAND_SPEC
+ /* Provide option to override link_command_spec from machine specific
+    configuration files.  */
+ static char *link_command_spec = LINK_COMMAND_SPEC;
+ #else /* not LINK_COMMAND_SPEC */
  #ifdef LINK_LIBGCC_SPECIAL
  /* Don't generate -L options.  */
  static char *link_command_spec = "\
***************
*** 722,728 ****
  			%{!A:%{!nostdlib:%{!nostartfiles:%E}}}\
  			%{T*}\
  			\n }}}}}}";
! #else
  /* Use -L.  */
  static char *link_command_spec = "\
  %{!fsyntax-only: \
--- 727,733 ----
  			%{!A:%{!nostdlib:%{!nostartfiles:%E}}}\
  			%{T*}\
  			\n }}}}}}";
! #else /* not LINK_LIBGCC_SPECIAL */
  /* Use -L.  */
  static char *link_command_spec = "\
  %{!fsyntax-only: \
***************
*** 734,740 ****
  			%{!A:%{!nostdlib:%{!nostartfiles:%E}}}\
  			%{T*}\
  			\n }}}}}}";
! #endif
  
  /* A vector of options to give to the linker.
     These options are accumulated by %x,
--- 739,746 ----
  			%{!A:%{!nostdlib:%{!nostartfiles:%E}}}\
  			%{T*}\
  			\n }}}}}}";
! #endif /* not LINK_LIBGCC_SPECIAL */
! #endif /* not LINK_COMMAND_SPEC */
  
  /* A vector of options to give to the linker.
     These options are accumulated by %x,
***************
*** 2529,2534 ****
--- 2535,2542 ----
  	  init_spec ();
  	  for (sl = specs; sl; sl = sl->next)
  	    printf ("*%s:\n%s\n\n", sl->name, *(sl->ptr_spec));
+           if (link_command_spec)
+             printf ("*link_command:\n%s\n\n", link_command_spec);
  	  exit (0);
  	}
        else if (! strcmp (argv[i], "-dumpversion"))
***************
*** 2848,2854 ****
       directories, so that we can search both the user specified directory
       and the standard place.  */
  
!   if (*tooldir_prefix != '/' && *tooldir_prefix != DIR_SEPARATOR)
      {
        if (gcc_exec_prefix)
  	{
--- 2856,2863 ----
       directories, so that we can search both the user specified directory
       and the standard place.  */
  
!   if (*tooldir_prefix != '/' && *tooldir_prefix != DIR_SEPARATOR
!       && *tooldir_prefix != '$')
      {
        if (gcc_exec_prefix)
  	{
diff -rc gcc-2.8.1.orig/genattr.c gcc-2.8.1/genattr.c
*** gcc-2.8.1.orig/genattr.c	1996-10-09 13:25:39.000000000 +0200
--- gcc-2.8.1/genattr.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 34,41 ****
  extern void free PROTO((void *));
  extern rtx read_rtx PROTO((FILE *));
  
! char *xmalloc PROTO((unsigned));
! static void fatal ();
  void fancy_abort PROTO((void));
  
  /* A range of values.  */
--- 34,41 ----
  extern void free PROTO((void *));
  extern rtx read_rtx PROTO((FILE *));
  
! static void fatal PROTO((const char *));
! static void fatal1 PROTO((const char *, const char *));
  void fancy_abort PROTO((void));
  
  /* A range of values.  */
***************
*** 191,224 ****
    printf ("#define INSN_QUEUE_SIZE %d\n", q_size);
  }
  
! char *
  xmalloc (size)
       unsigned size;
  {
!   register char *val = (char *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
    return val;
  }
  
! char *
  xrealloc (ptr, size)
!      char *ptr;
       unsigned size;
  {
!   char * result = (char *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
  }
  
  static void
! fatal (s, a1, a2)
!      char *s;
  {
    fprintf (stderr, "genattr: ");
!   fprintf (stderr, s, a1, a2);
    fprintf (stderr, "\n");
    exit (FATAL_EXIT_CODE);
  }
--- 191,234 ----
    printf ("#define INSN_QUEUE_SIZE %d\n", q_size);
  }
  
! void *
  xmalloc (size)
       unsigned size;
  {
!   register void *val = (void *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
    return val;
  }
  
! void *
  xrealloc (ptr, size)
!      void *ptr;
       unsigned size;
  {
!   void * result = (void *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
  }
  
  static void
! fatal (s)
!      const char *s;
  {
    fprintf (stderr, "genattr: ");
!   fprintf (stderr, s);
!   fprintf (stderr, "\n");
!   exit (FATAL_EXIT_CODE);
! }
! 
! static void
! fatal1 (s, a1)
!      const char *s, *a1;
! {
!   fprintf (stderr, "genattr: ");
!   fprintf (stderr, s, a1);
    fprintf (stderr, "\n");
    exit (FATAL_EXIT_CODE);
  }
***************
*** 353,359 ****
  	    }
  	  else if (unit->multiplicity != multiplicity
  		   || unit->simultaneity != simultaneity)
! 	    fatal ("Differing specifications given for `%s' function unit.",
  		   unit->name);
  
  	  extend_range (&unit->ready_cost, ready_cost, ready_cost);
--- 363,369 ----
  	    }
  	  else if (unit->multiplicity != multiplicity
  		   || unit->simultaneity != simultaneity)
! 	    fatal1 ("Differing specifications given for `%s' function unit.",
  		   unit->name);
  
  	  extend_range (&unit->ready_cost, ready_cost, ready_cost);
diff -rc gcc-2.8.1.orig/genattrtab.c gcc-2.8.1/genattrtab.c
*** gcc-2.8.1.orig/genattrtab.c	1998-02-06 21:18:02.000000000 +0100
--- gcc-2.8.1/genattrtab.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 106,111 ****
--- 106,113 ----
  #include "rtl.h"
  #include "insn-config.h"	/* For REGISTER_CONSTRAINTS */
  
+ #include "auto-config.h"
+ 
  #ifdef TIME_WITH_SYS_TIME
  # include <sys/time.h>
  # include <time.h>
***************
*** 461,468 ****
  static rtx find_single_value	PROTO((struct attr_desc *));
  static rtx make_numeric_value	PROTO((int));
  static void extend_range	PROTO((struct range *, int, int));
- char *xrealloc			PROTO((char *, unsigned));
- char *xmalloc			PROTO((unsigned));
  
  #define oballoc(size) obstack_alloc (hash_obstack, size)
  
--- 463,468 ----
***************
*** 5460,5481 ****
    if (range->max < max) range->max = max;
  }
  
! char *
  xrealloc (ptr, size)
!      char *ptr;
       unsigned size;
  {
!   char *result = (char *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
  }
  
! char *
  xmalloc (size)
       unsigned size;
  {
!   register char *val = (char *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
--- 5460,5481 ----
    if (range->max < max) range->max = max;
  }
  
! void *
  xrealloc (ptr, size)
!      void *ptr;
       unsigned size;
  {
!   void *result = (void *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
  }
  
! void *
  xmalloc (size)
       unsigned size;
  {
!   register void *val = (void *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
diff -rc gcc-2.8.1.orig/gencodes.c gcc-2.8.1/gencodes.c
*** gcc-2.8.1.orig/gencodes.c	1996-10-09 13:25:41.000000000 +0200
--- gcc-2.8.1/gencodes.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 36,42 ****
  extern void free ();
  extern rtx read_rtx ();
  
- char *xmalloc ();
  static void fatal ();
  void fancy_abort ();
  
--- 36,41 ----
***************
*** 54,76 ****
  	    insn_code_number);
  }
  
! char *
  xmalloc (size)
       unsigned size;
  {
!   register char *val = (char *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
    return val;
  }
  
! char *
  xrealloc (ptr, size)
!      char *ptr;
       unsigned size;
  {
!   char *result = (char *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
--- 53,75 ----
  	    insn_code_number);
  }
  
! void *
  xmalloc (size)
       unsigned size;
  {
!   register void *val = (void *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
    return val;
  }
  
! void *
  xrealloc (ptr, size)
!      void *ptr;
       unsigned size;
  {
!   void *result = (void *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
diff -rc gcc-2.8.1.orig/genconfig.c gcc-2.8.1/genconfig.c
*** gcc-2.8.1.orig/genconfig.c	1997-08-07 12:50:10.000000000 +0200
--- gcc-2.8.1/genconfig.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 49,55 ****
  static int clobbers_seen_this_insn;
  static int dup_operands_seen_this_insn;
  
- char *xmalloc ();
  static void fatal ();
  void fancy_abort ();
  
--- 49,54 ----
***************
*** 238,248 ****
      walk_insn_part (XVECEXP (peep, 0, i), 1, 0);
  }
  
! char *
  xmalloc (size)
       unsigned size;
  {
!   register char *val = (char *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
--- 237,247 ----
      walk_insn_part (XVECEXP (peep, 0, i), 1, 0);
  }
  
! void *
  xmalloc (size)
       unsigned size;
  {
!   register void *val = (void *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
***************
*** 250,261 ****
    return val;
  }
  
! char *
  xrealloc (ptr, size)
!      char *ptr;
       unsigned size;
  {
!   char *result = (char *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
--- 249,260 ----
    return val;
  }
  
! void *
  xrealloc (ptr, size)
!      void *ptr;
       unsigned size;
  {
!   void *result = (void *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
diff -rc gcc-2.8.1.orig/genemit.c gcc-2.8.1/genemit.c
*** gcc-2.8.1.orig/genemit.c	1997-08-15 12:55:49.000000000 +0200
--- gcc-2.8.1/genemit.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 33,39 ****
  extern void free ();
  extern rtx read_rtx ();
  
- char *xmalloc ();
  static void fatal ();
  void fancy_abort ();
  
--- 33,38 ----
***************
*** 668,678 ****
  #endif
  }
  
! char *
  xmalloc (size)
       unsigned size;
  {
!   register char *val = (char *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
--- 667,677 ----
  #endif
  }
  
! void *
  xmalloc (size)
       unsigned size;
  {
!   register void *val = (void *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
***************
*** 680,691 ****
    return val;
  }
  
! char *
  xrealloc (ptr, size)
!      char *ptr;
       unsigned size;
  {
!   char *result = (char *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
--- 679,690 ----
    return val;
  }
  
! void *
  xrealloc (ptr, size)
!      void *ptr;
       unsigned size;
  {
!   void *result = (void *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
diff -rc gcc-2.8.1.orig/genextract.c gcc-2.8.1/genextract.c
*** gcc-2.8.1.orig/genextract.c	1997-08-08 22:09:02.000000000 +0200
--- gcc-2.8.1/genextract.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 100,107 ****
  
  static void walk_rtx ();
  static void print_path ();
- char *xmalloc ();
- char *xrealloc ();
  static void fatal ();
  static char *copystr ();
  static void mybzero ();
--- 100,105 ----
***************
*** 342,364 ****
      }
  }
  
! char *
  xmalloc (size)
       unsigned size;
  {
!   register char *val = (char *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
    return val;
  }
  
! char *
  xrealloc (ptr, size)
!      char *ptr;
       unsigned size;
  {
!   char *result = (char *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
--- 340,362 ----
      }
  }
  
! void *
  xmalloc (size)
       unsigned size;
  {
!   register void *val = (void *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
    return val;
  }
  
! void *
  xrealloc (ptr, size)
!      void *ptr;
       unsigned size;
  {
!   void *result = (void *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
diff -rc gcc-2.8.1.orig/genflags.c gcc-2.8.1/genflags.c
*** gcc-2.8.1.orig/genflags.c	1996-10-09 13:25:42.000000000 +0200
--- gcc-2.8.1/genflags.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 36,42 ****
  extern void free ();
  extern rtx read_rtx ();
  
- char *xmalloc ();
  static void fatal ();
  void fancy_abort ();
  
--- 36,41 ----
***************
*** 172,182 ****
    obstack_grow (obstack_ptr, &insn, sizeof (rtx));
  }
  
! char *
  xmalloc (size)
       unsigned size;
  {
!   register char *val = (char *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
--- 171,181 ----
    obstack_grow (obstack_ptr, &insn, sizeof (rtx));
  }
  
! void *
  xmalloc (size)
       unsigned size;
  {
!   register void *val = (void *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
***************
*** 184,195 ****
    return val;
  }
  
! char *
  xrealloc (ptr, size)
!      char *ptr;
       unsigned size;
  {
!   char *result = (char *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
--- 183,194 ----
    return val;
  }
  
! void *
  xrealloc (ptr, size)
!      void *ptr;
       unsigned size;
  {
!   void *result = (void *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
diff -rc gcc-2.8.1.orig/genopinit.c gcc-2.8.1/genopinit.c
*** gcc-2.8.1.orig/genopinit.c	1997-08-22 19:32:03.000000000 +0200
--- gcc-2.8.1/genopinit.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 34,40 ****
  extern void free ();
  extern rtx read_rtx ();
  
- char *xmalloc ();
  static void fatal ();
  void fancy_abort ();
  
--- 34,39 ----
***************
*** 283,293 ****
    printf (";\n");
  }
  
! char *
  xmalloc (size)
       unsigned size;
  {
!   register char *val = (char *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
--- 282,292 ----
    printf (";\n");
  }
  
! void *
  xmalloc (size)
       unsigned size;
  {
!   register void *val = (void *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
***************
*** 295,306 ****
    return val;
  }
  
! char *
  xrealloc (ptr, size)
!      char *ptr;
       unsigned size;
  {
!   char *result = (char *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
--- 294,305 ----
    return val;
  }
  
! void *
  xrealloc (ptr, size)
!      void *ptr;
       unsigned size;
  {
!   void *result = (void *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
diff -rc gcc-2.8.1.orig/genoutput.c gcc-2.8.1/genoutput.c
*** gcc-2.8.1.orig/genoutput.c	1997-12-04 12:58:15.000000000 +0100
--- gcc-2.8.1/genoutput.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 110,116 ****
  extern void free ();
  extern rtx read_rtx ();
  
- char *xmalloc ();
  static void fatal ();
  void fancy_abort ();
  static void error ();
--- 110,115 ----
***************
*** 870,892 ****
    d->outfun = 0;
  }
  
! char *
  xmalloc (size)
       unsigned size;
  {
!   register char *val = (char *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
    return val;
  }
  
! char *
  xrealloc (ptr, size)
!      char *ptr;
       unsigned size;
  {
!   char *result = (char *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
--- 869,891 ----
    d->outfun = 0;
  }
  
! void *
  xmalloc (size)
       unsigned size;
  {
!   register void *val = (void *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
    return val;
  }
  
! void *
  xrealloc (ptr, size)
!      void *ptr;
       unsigned size;
  {
!   void *result = (void *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
diff -rc gcc-2.8.1.orig/genpeep.c gcc-2.8.1/genpeep.c
*** gcc-2.8.1.orig/genpeep.c	1997-09-19 13:44:58.000000000 +0200
--- gcc-2.8.1/genpeep.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 46,52 ****
    int vecelt;
  };
  
- char *xmalloc ();
  static void match_rtx ();
  static void fatal ();
  void fancy_abort ();
--- 46,51 ----
***************
*** 387,409 ****
      }
  }
  
! char *
  xmalloc (size)
       unsigned size;
  {
!   register char *val = (char *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
    return val;
  }
  
! char *
  xrealloc (ptr, size)
!      char *ptr;
       unsigned size;
  {
!   char *result = (char *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
--- 386,408 ----
      }
  }
  
! void *
  xmalloc (size)
       unsigned size;
  {
!   register void *val = (void *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
    return val;
  }
  
! void *
  xrealloc (ptr, size)
!      void *ptr;
       unsigned size;
  {
!   void *result = (void *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
diff -rc gcc-2.8.1.orig/genrecog.c gcc-2.8.1/genrecog.c
*** gcc-2.8.1.orig/genrecog.c	1997-08-08 22:09:02.000000000 +0200
--- gcc-2.8.1/genrecog.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 193,200 ****
  static void mybcopy		PROTO((char *, char *, unsigned));
  static char *concat		PROTO((char *, char *));
  static void fatal		PROTO((char *));
- char *xrealloc			PROTO((char *, unsigned));
- char *xmalloc			PROTO((unsigned));
  void fancy_abort		PROTO((void));
  
  /* Construct and return a sequence of decisions
--- 193,198 ----
***************
*** 1669,1690 ****
    return tem;
  }
  
! char *
  xrealloc (ptr, size)
!      char *ptr;
       unsigned size;
  {
!   char *result = (char *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
  }
  
! char *
  xmalloc (size)
       unsigned size;
  {
!   register char *val = (char *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
--- 1667,1688 ----
    return tem;
  }
  
! void *
  xrealloc (ptr, size)
!      void *ptr;
       unsigned size;
  {
!   void *result = (void *) realloc (ptr, size);
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
  }
  
! void *
  xmalloc (size)
       unsigned size;
  {
!   register void *val = (void *) malloc (size);
  
    if (val == 0)
      fatal ("virtual memory exhausted");
diff -rc gcc-2.8.1.orig/libgcc2.c gcc-2.8.1/libgcc2.c
*** gcc-2.8.1.orig/libgcc2.c	1998-02-06 21:50:59.000000000 +0100
--- gcc-2.8.1/libgcc2.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 3704,3712 ****
       compiling __throw we don't know whether or not we will use the frame
       pointer register for the CFA, so we check our unwind info.  */
    if (udata->cfa_reg == __builtin_dwarf_fp_regnum ())
!     udata->cfa = __builtin_fp ();
    else
!     udata->cfa = __builtin_sp ();
    udata->cfa += udata->cfa_offset;
  
    memcpy (my_udata, udata, sizeof (*udata));
--- 3704,3712 ----
       compiling __throw we don't know whether or not we will use the frame
       pointer register for the CFA, so we check our unwind info.  */
    if (udata->cfa_reg == __builtin_dwarf_fp_regnum ())
!     udata->cfa = (void *) __builtin_fp ();
    else
!     udata->cfa = (void *) __builtin_sp ();
    udata->cfa += udata->cfa_offset;
  
    memcpy (my_udata, udata, sizeof (*udata));
***************
*** 3806,3812 ****
    /* udata now refers to the frame called by the handler frame.  */
  
    /* Emit the stub to adjust sp and jump to the handler.  */
!   retaddr = __builtin_eh_stub ();
  
    /* And then set our return address to point to the stub.  */
    if (my_udata->saved[my_udata->retaddr_column] == REG_SAVED_OFFSET)
--- 3806,3812 ----
    /* udata now refers to the frame called by the handler frame.  */
  
    /* Emit the stub to adjust sp and jump to the handler.  */
!   retaddr = (void *) __builtin_eh_stub ();
  
    /* And then set our return address to point to the stub.  */
    if (my_udata->saved[my_udata->retaddr_column] == REG_SAVED_OFFSET)
diff -rc gcc-2.8.1.orig/longlong.h gcc-2.8.1/longlong.h
*** gcc-2.8.1.orig/longlong.h	1997-10-18 19:47:49.000000000 +0200
--- gcc-2.8.1/longlong.h	2006-03-13 23:21:10.000000000 +0100
***************
*** 89,95 ****
  
  #if defined (__a29k__) || defined (_AM29K)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("add %1,%4,%5
  	addc %0,%2,%3"							\
  	   : "=r" ((USItype) (sh)),					\
  	    "=&r" ((USItype) (sl))					\
--- 89,95 ----
  
  #if defined (__a29k__) || defined (_AM29K)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("add %1,%4,%5\n\
  	addc %0,%2,%3"							\
  	   : "=r" ((USItype) (sh)),					\
  	    "=&r" ((USItype) (sl))					\
***************
*** 98,104 ****
  	     "%r" ((USItype) (al)),					\
  	     "rI" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("sub %1,%4,%5
  	subc %0,%2,%3"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
--- 98,104 ----
  	     "%r" ((USItype) (al)),					\
  	     "rI" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("sub %1,%4,%5\n\
  	subc %0,%2,%3"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
***************
*** 133,139 ****
  
  #if defined (__arc__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("add.f	%1, %4, %5
  	adc	%0, %2, %3"						\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
--- 133,139 ----
  
  #if defined (__arc__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("add.f	%1, %4, %5\n\
  	adc	%0, %2, %3"						\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
***************
*** 142,148 ****
  	     "%r" ((USItype) (al)),					\
  	     "rIJ" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("sub.f	%1, %4, %5
  	sbc	%0, %2, %3"						\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
--- 142,148 ----
  	     "%r" ((USItype) (al)),					\
  	     "rIJ" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("sub.f	%1, %4, %5\n\
  	sbc	%0, %2, %3"						\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
***************
*** 164,170 ****
  
  #if defined (__arm__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("adds	%1, %4, %5
  	adc	%0, %2, %3"						\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
--- 164,170 ----
  
  #if defined (__arm__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("adds	%1, %4, %5\n\
  	adc	%0, %2, %3"						\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
***************
*** 173,179 ****
  	     "%r" ((USItype) (al)),					\
  	     "rI" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("subs	%1, %4, %5
  	sbc	%0, %2, %3"						\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
--- 173,179 ----
  	     "%r" ((USItype) (al)),					\
  	     "rI" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("subs	%1, %4, %5\n\
  	sbc	%0, %2, %3"						\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
***************
*** 183,200 ****
  	     "rI" ((USItype) (bl)))
  #define umul_ppmm(xh, xl, a, b) \
  {register USItype __t0, __t1, __t2;					\
!   __asm__ ("%@ Inlined umul_ppmm
! 	mov	%2, %5, lsr #16
! 	mov	%0, %6, lsr #16
! 	bic	%3, %5, %2, lsl #16
! 	bic	%4, %6, %0, lsl #16
! 	mul	%1, %3, %4
! 	mul	%4, %2, %4
! 	mul	%3, %0, %3
! 	mul	%0, %2, %0
! 	adds	%3, %4, %3
! 	addcs	%0, %0, #65536
! 	adds	%1, %1, %3, lsl #16
  	adc	%0, %0, %3, lsr #16"					\
  	   : "=&r" ((USItype) (xh)),					\
  	     "=r" ((USItype) (xl)),					\
--- 183,200 ----
  	     "rI" ((USItype) (bl)))
  #define umul_ppmm(xh, xl, a, b) \
  {register USItype __t0, __t1, __t2;					\
!   __asm__ ("%@ Inlined umul_ppmm\n\
! 	mov	%2, %5, lsr #16\n\
! 	mov	%0, %6, lsr #16\n\
! 	bic	%3, %5, %2, lsl #16\n\
! 	bic	%4, %6, %0, lsl #16\n\
! 	mul	%1, %3, %4\n\
! 	mul	%4, %2, %4\n\
! 	mul	%3, %0, %3\n\
! 	mul	%0, %2, %0\n\
! 	adds	%3, %4, %3\n\
! 	addcs	%0, %0, #65536\n\
! 	adds	%1, %1, %3, lsl #16\n\
  	adc	%0, %0, %3, lsr #16"					\
  	   : "=&r" ((USItype) (xh)),					\
  	     "=r" ((USItype) (xl)),					\
***************
*** 235,241 ****
  
  #if defined (__gmicro__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("add.w %5,%1
  	addx %3,%0"							\
  	   : "=g" ((USItype) (sh)),					\
  	     "=&g" ((USItype) (sl))					\
--- 235,241 ----
  
  #if defined (__gmicro__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("add.w %5,%1\n\
  	addx %3,%0"							\
  	   : "=g" ((USItype) (sh)),					\
  	     "=&g" ((USItype) (sl))					\
***************
*** 244,250 ****
  	     "%1" ((USItype) (al)),					\
  	     "g" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("sub.w %5,%1
  	subx %3,%0"							\
  	   : "=g" ((USItype) (sh)),					\
  	     "=&g" ((USItype) (sl))					\
--- 244,250 ----
  	     "%1" ((USItype) (al)),					\
  	     "g" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("sub.w %5,%1\n\
  	subx %3,%0"							\
  	   : "=g" ((USItype) (sh)),					\
  	     "=&g" ((USItype) (sl))					\
***************
*** 274,280 ****
  
  #if defined (__hppa)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("add %4,%5,%1
  	addc %2,%3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
--- 274,280 ----
  
  #if defined (__hppa)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("add %4,%5,%1\n\
  	addc %2,%3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
***************
*** 283,289 ****
  	     "%rM" ((USItype) (al)),					\
  	     "rM" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("sub %4,%5,%1
  	subb %2,%3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
--- 283,289 ----
  	     "%rM" ((USItype) (al)),					\
  	     "rM" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("sub %4,%5,%1\n\
  	subb %2,%3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
***************
*** 315,342 ****
    do {									\
      USItype __tmp;							\
      __asm__ (								\
!        "ldi		1,%0
! 	extru,=		%1,15,16,%%r0		; Bits 31..16 zero?
! 	extru,tr	%1,15,16,%1		; No.  Shift down, skip add.
! 	ldo		16(%0),%0		; Yes.  Perform add.
! 	extru,=		%1,23,8,%%r0		; Bits 15..8 zero?
! 	extru,tr	%1,23,8,%1		; No.  Shift down, skip add.
! 	ldo		8(%0),%0		; Yes.  Perform add.
! 	extru,=		%1,27,4,%%r0		; Bits 7..4 zero?
! 	extru,tr	%1,27,4,%1		; No.  Shift down, skip add.
! 	ldo		4(%0),%0		; Yes.  Perform add.
! 	extru,=		%1,29,2,%%r0		; Bits 3..2 zero?
! 	extru,tr	%1,29,2,%1		; No.  Shift down, skip add.
! 	ldo		2(%0),%0		; Yes.  Perform add.
! 	extru		%1,30,1,%1		; Extract bit 1.
! 	sub		%0,%1,%0		; Subtract it.
  	" : "=r" (count), "=r" (__tmp) : "1" (x));			\
    } while (0)
  #endif
  
  #if defined (__i386__) || defined (__i486__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("addl %5,%1
  	adcl %3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
--- 315,342 ----
    do {									\
      USItype __tmp;							\
      __asm__ (								\
!        "ldi		1,%0\n\
! 	extru,=		%1,15,16,%%r0		; Bits 31..16 zero?\n\
! 	extru,tr	%1,15,16,%1		; No.  Shift down, skip add.\n\
! 	ldo		16(%0),%0		; Yes.  Perform add.\n\
! 	extru,=		%1,23,8,%%r0		; Bits 15..8 zero?\n\
! 	extru,tr	%1,23,8,%1		; No.  Shift down, skip add.\n\
! 	ldo		8(%0),%0		; Yes.  Perform add.\n\
! 	extru,=		%1,27,4,%%r0		; Bits 7..4 zero?\n\
! 	extru,tr	%1,27,4,%1		; No.  Shift down, skip add.\n\
! 	ldo		4(%0),%0		; Yes.  Perform add.\n\
! 	extru,=		%1,29,2,%%r0		; Bits 3..2 zero?\n\
! 	extru,tr	%1,29,2,%1		; No.  Shift down, skip add.\n\
! 	ldo		2(%0),%0		; Yes.  Perform add.\n\
! 	extru		%1,30,1,%1		; Extract bit 1.\n\
! 	sub		%0,%1,%0		; Subtract it.\n\
  	" : "=r" (count), "=r" (__tmp) : "1" (x));			\
    } while (0)
  #endif
  
  #if defined (__i386__) || defined (__i486__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("addl %5,%1\n\
  	adcl %3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
***************
*** 345,351 ****
  	     "%1" ((USItype) (al)),					\
  	     "g" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("subl %5,%1
  	sbbl %3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
--- 345,351 ----
  	     "%1" ((USItype) (al)),					\
  	     "g" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("subl %5,%1\n\
  	sbbl %3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
***************
*** 440,447 ****
  #if defined (__M32R__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
    /* The cmp clears the condition bit.  */ \
!   __asm__ ("cmp %0,%0
! 	addx %%5,%1
  	addx %%3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
--- 440,447 ----
  #if defined (__M32R__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
    /* The cmp clears the condition bit.  */ \
!   __asm__ ("cmp %0,%0\n\
! 	addx %%5,%1\n\
  	addx %%3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
***************
*** 452,459 ****
  	   : "cbit")
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
    /* The cmp clears the condition bit.  */ \
!   __asm__ ("cmp %0,%0
! 	subx %5,%1
  	subx %3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
--- 452,459 ----
  	   : "cbit")
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
    /* The cmp clears the condition bit.  */ \
!   __asm__ ("cmp %0,%0\n\
! 	subx %5,%1\n\
  	subx %3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
***************
*** 466,472 ****
  
  #if defined (__mc68000__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("add%.l %5,%1
  	addx%.l %3,%0"							\
  	   : "=d" ((USItype) (sh)),					\
  	     "=&d" ((USItype) (sl))					\
--- 466,472 ----
  
  #if defined (__mc68000__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("add%.l %5,%1\n\
  	addx%.l %3,%0"							\
  	   : "=d" ((USItype) (sh)),					\
  	     "=&d" ((USItype) (sl))					\
***************
*** 475,481 ****
  	     "%1" ((USItype) (al)),					\
  	     "g" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("sub%.l %5,%1
  	subx%.l %3,%0"							\
  	   : "=d" ((USItype) (sh)),					\
  	     "=&d" ((USItype) (sl))					\
--- 475,481 ----
  	     "%1" ((USItype) (al)),					\
  	     "g" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("sub%.l %5,%1\n\
  	subx%.l %3,%0"							\
  	   : "=d" ((USItype) (sh)),					\
  	     "=&d" ((USItype) (sl))					\
***************
*** 517,547 ****
  #if !defined(__mcf5200__)
  /* %/ inserts REGISTER_PREFIX, %# inserts IMMEDIATE_PREFIX.  */
  #define umul_ppmm(xh, xl, a, b) \
!   __asm__ ("| Inlined umul_ppmm
! 	move%.l	%2,%/d0
! 	move%.l	%3,%/d1
! 	move%.l	%/d0,%/d2
! 	swap	%/d0
! 	move%.l	%/d1,%/d3
! 	swap	%/d1
! 	move%.w	%/d2,%/d4
! 	mulu	%/d3,%/d4
! 	mulu	%/d1,%/d2
! 	mulu	%/d0,%/d3
! 	mulu	%/d0,%/d1
! 	move%.l	%/d4,%/d0
! 	eor%.w	%/d0,%/d0
! 	swap	%/d0
! 	add%.l	%/d0,%/d2
! 	add%.l	%/d3,%/d2
! 	jcc	1f
! 	add%.l	%#65536,%/d1
! 1:	swap	%/d2
! 	moveq	%#0,%/d0
! 	move%.w	%/d2,%/d0
! 	move%.w	%/d4,%/d2
! 	move%.l	%/d2,%1
! 	add%.l	%/d1,%/d0
  	move%.l	%/d0,%0"						\
  	   : "=g" ((USItype) (xh)),					\
  	     "=g" ((USItype) (xl))					\
--- 517,547 ----
  #if !defined(__mcf5200__)
  /* %/ inserts REGISTER_PREFIX, %# inserts IMMEDIATE_PREFIX.  */
  #define umul_ppmm(xh, xl, a, b) \
!   __asm__ ("| Inlined umul_ppmm\n\
! 	move%.l	%2,%/d0\n\
! 	move%.l	%3,%/d1\n\
! 	move%.l	%/d0,%/d2\n\
! 	swap	%/d0\n\
! 	move%.l	%/d1,%/d3\n\
! 	swap	%/d1\n\
! 	move%.w	%/d2,%/d4\n\
! 	mulu	%/d3,%/d4\n\
! 	mulu	%/d1,%/d2\n\
! 	mulu	%/d0,%/d3\n\
! 	mulu	%/d0,%/d1\n\
! 	move%.l	%/d4,%/d0\n\
! 	eor%.w	%/d0,%/d0\n\
! 	swap	%/d0\n\
! 	add%.l	%/d0,%/d2\n\
! 	add%.l	%/d3,%/d2\n\
! 	jcc	1f\n\
! 	add%.l	%#65536,%/d1\n\
! 1:	swap	%/d2\n\
! 	moveq	%#0,%/d0\n\
! 	move%.w	%/d2,%/d0\n\
! 	move%.w	%/d4,%/d2\n\
! 	move%.l	%/d2,%1\n\
! 	add%.l	%/d1,%/d0\n\
  	move%.l	%/d0,%0"						\
  	   : "=g" ((USItype) (xh)),					\
  	     "=g" ((USItype) (xl))					\
***************
*** 568,574 ****
  
  #if defined (__m88000__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("addu.co %1,%r4,%r5
  	addu.ci %0,%r2,%r3"						\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
--- 568,574 ----
  
  #if defined (__m88000__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("addu.co %1,%r4,%r5\n\
  	addu.ci %0,%r2,%r3"						\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
***************
*** 577,583 ****
  	     "%rJ" ((USItype) (al)),					\
  	     "rJ" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("subu.co %1,%r4,%r5
  	subu.ci %0,%r2,%r3"						\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
--- 577,583 ----
  	     "%rJ" ((USItype) (al)),					\
  	     "rJ" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("subu.co %1,%r4,%r5\n\
  	subu.ci %0,%r2,%r3"						\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
***************
*** 786,792 ****
  
  #if defined (__pyr__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("addw	%5,%1
  	addwc	%3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
--- 786,792 ----
  
  #if defined (__pyr__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("addw	%5,%1\n\
  	addwc	%3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
***************
*** 795,801 ****
  	     "%1" ((USItype) (al)),					\
  	     "g" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("subw	%5,%1
  	subwb	%3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
--- 795,801 ----
  	     "%1" ((USItype) (al)),					\
  	     "g" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("subw	%5,%1\n\
  	subwb	%3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
***************
*** 808,814 ****
    ({union {UDItype __ll;						\
  	   struct {USItype __h, __l;} __i;				\
  	  } __xx;							\
!   __asm__ ("movw %1,%R0
  	uemul %2,%0"							\
  	   : "=&r" (__xx.__ll)						\
  	   : "g" ((USItype) (u)),					\
--- 808,814 ----
    ({union {UDItype __ll;						\
  	   struct {USItype __h, __l;} __i;				\
  	  } __xx;							\
!   __asm__ ("movw %1,%R0\n\
  	uemul %2,%0"							\
  	   : "=&r" (__xx.__ll)						\
  	   : "g" ((USItype) (u)),					\
***************
*** 818,824 ****
  
  #if defined (__ibm032__) /* RT/ROMP */
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("a %1,%5
  	ae %0,%3"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
--- 818,824 ----
  
  #if defined (__ibm032__) /* RT/ROMP */
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("a %1,%5\n\
  	ae %0,%3"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
***************
*** 827,833 ****
  	     "%1" ((USItype) (al)),					\
  	     "r" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("s %1,%5
  	se %0,%3"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
--- 827,833 ----
  	     "%1" ((USItype) (al)),					\
  	     "r" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("s %1,%5\n\
  	se %0,%3"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
***************
*** 839,863 ****
    do {									\
      USItype __m0 = (m0), __m1 = (m1);					\
      __asm__ (								\
!        "s	r2,r2
! 	mts	r10,%2
! 	m	r2,%3
! 	m	r2,%3
! 	m	r2,%3
! 	m	r2,%3
! 	m	r2,%3
! 	m	r2,%3
! 	m	r2,%3
! 	m	r2,%3
! 	m	r2,%3
! 	m	r2,%3
! 	m	r2,%3
! 	m	r2,%3
! 	m	r2,%3
! 	m	r2,%3
! 	m	r2,%3
! 	m	r2,%3
! 	cas	%0,r2,r0
  	mfs	r10,%1"							\
  	     : "=r" ((USItype) (ph)),					\
  	       "=r" ((USItype) (pl))					\
--- 839,863 ----
    do {									\
      USItype __m0 = (m0), __m1 = (m1);					\
      __asm__ (								\
!        "s	r2,r2\n\
! 	mts	r10,%2\n\
! 	m	r2,%3\n\
! 	m	r2,%3\n\
! 	m	r2,%3\n\
! 	m	r2,%3\n\
! 	m	r2,%3\n\
! 	m	r2,%3\n\
! 	m	r2,%3\n\
! 	m	r2,%3\n\
! 	m	r2,%3\n\
! 	m	r2,%3\n\
! 	m	r2,%3\n\
! 	m	r2,%3\n\
! 	m	r2,%3\n\
! 	m	r2,%3\n\
! 	m	r2,%3\n\
! 	m	r2,%3\n\
! 	cas	%0,r2,r0\n\
  	mfs	r10,%1"							\
  	     : "=r" ((USItype) (ph)),					\
  	       "=r" ((USItype) (pl))					\
***************
*** 887,893 ****
  
  #if defined (__sparc__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("addcc %r4,%5,%1
  	addx %r2,%3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
--- 887,893 ----
  
  #if defined (__sparc__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("addcc %r4,%5,%1\n\
  	addx %r2,%3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
***************
*** 897,903 ****
  	     "rI" ((USItype) (bl))					\
  	   __CLOBBER_CC)
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("subcc %r4,%5,%1
  	subx %r2,%3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
--- 897,903 ----
  	     "rI" ((USItype) (bl))					\
  	   __CLOBBER_CC)
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("subcc %r4,%5,%1\n\
  	subx %r2,%3,%0"							\
  	   : "=r" ((USItype) (sh)),					\
  	     "=&r" ((USItype) (sl))					\
***************
*** 931,974 ****
  	   : "r" ((USItype) (u)),					\
  	     "r" ((USItype) (v)))
  #define udiv_qrnnd(q, r, n1, n0, d) \
!   __asm__ ("! Inlined udiv_qrnnd
! 	wr	%%g0,%2,%%y	! Not a delayed write for sparclite
! 	tst	%%g0
! 	divscc	%3,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%%g1
! 	divscc	%%g1,%4,%0
! 	rd	%%y,%1
! 	bl,a 1f
! 	add	%1,%4,%1
  1:	! End of inline udiv_qrnnd"					\
  	   : "=r" ((USItype) (q)),					\
  	     "=r" ((USItype) (r))					\
--- 931,974 ----
  	   : "r" ((USItype) (u)),					\
  	     "r" ((USItype) (v)))
  #define udiv_qrnnd(q, r, n1, n0, d) \
!   __asm__ ("! Inlined udiv_qrnnd\n\
! 	wr	%%g0,%2,%%y	! Not a delayed write for sparclite\n\
! 	tst	%%g0\n\
! 	divscc	%3,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%%g1\n\
! 	divscc	%%g1,%4,%0\n\
! 	rd	%%y,%1\n\
! 	bl,a 1f\n\
! 	add	%1,%4,%1\n\
  1:	! End of inline udiv_qrnnd"					\
  	   : "=r" ((USItype) (q)),					\
  	     "=r" ((USItype) (r))					\
***************
*** 985,1029 ****
  /* SPARC without integer multiplication and divide instructions.
     (i.e. at least Sun4/20,40,60,65,75,110,260,280,330,360,380,470,490) */
  #define umul_ppmm(w1, w0, u, v) \
!   __asm__ ("! Inlined umul_ppmm
! 	wr	%%g0,%2,%%y	! SPARC has 0-3 delay insn after a wr
! 	sra	%3,31,%%g2	! Don't move this insn
! 	and	%2,%%g2,%%g2	! Don't move this insn
! 	andcc	%%g0,0,%%g1	! Don't move this insn
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,%3,%%g1
! 	mulscc	%%g1,0,%%g1
! 	add	%%g1,%%g2,%0
  	rd	%%y,%1"							\
  	   : "=r" ((USItype) (w1)),					\
  	     "=r" ((USItype) (w0))					\
--- 985,1029 ----
  /* SPARC without integer multiplication and divide instructions.
     (i.e. at least Sun4/20,40,60,65,75,110,260,280,330,360,380,470,490) */
  #define umul_ppmm(w1, w0, u, v) \
!   __asm__ ("! Inlined umul_ppmm\n\
! 	wr	%%g0,%2,%%y	! SPARC has 0-3 delay insn after a wr\n\
! 	sra	%3,31,%%g2	! Don't move this insn\n\
! 	and	%2,%%g2,%%g2	! Don't move this insn\n\
! 	andcc	%%g0,0,%%g1	! Don't move this insn\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,%3,%%g1\n\
! 	mulscc	%%g1,0,%%g1\n\
! 	add	%%g1,%%g2,%0\n\
  	rd	%%y,%1"							\
  	   : "=r" ((USItype) (w1)),					\
  	     "=r" ((USItype) (w0))					\
***************
*** 1034,1062 ****
  /* It's quite necessary to add this much assembler for the sparc.
     The default udiv_qrnnd (in C) is more than 10 times slower!  */
  #define udiv_qrnnd(q, r, n1, n0, d) \
!   __asm__ ("! Inlined udiv_qrnnd
! 	mov	32,%%g1
! 	subcc	%1,%2,%%g0
! 1:	bcs	5f
! 	 addxcc %0,%0,%0	! shift n1n0 and a q-bit in lsb
! 	sub	%1,%2,%1	! this kills msb of n
! 	addx	%1,%1,%1	! so this can't give carry
! 	subcc	%%g1,1,%%g1
! 2:	bne	1b
! 	 subcc	%1,%2,%%g0
! 	bcs	3f
! 	 addxcc %0,%0,%0	! shift n1n0 and a q-bit in lsb
! 	b	3f
! 	 sub	%1,%2,%1	! this kills msb of n
! 4:	sub	%1,%2,%1
! 5:	addxcc	%1,%1,%1
! 	bcc	2b
! 	 subcc	%%g1,1,%%g1
! ! Got carry from n.  Subtract next step to cancel this carry.
! 	bne	4b
! 	 addcc	%0,%0,%0	! shift n1n0 and a 0-bit in lsb
! 	sub	%1,%2,%1
! 3:	xnor	%0,0,%0
  	! End of inline udiv_qrnnd"					\
  	   : "=&r" ((USItype) (q)),					\
  	     "=&r" ((USItype) (r))					\
--- 1034,1062 ----
  /* It's quite necessary to add this much assembler for the sparc.
     The default udiv_qrnnd (in C) is more than 10 times slower!  */
  #define udiv_qrnnd(q, r, n1, n0, d) \
!   __asm__ ("! Inlined udiv_qrnnd\n\
! 	mov	32,%%g1\n\
! 	subcc	%1,%2,%%g0\n\
! 1:	bcs	5f\n\
! 	 addxcc %0,%0,%0	! shift n1n0 and a q-bit in lsb\n\
! 	sub	%1,%2,%1	! this kills msb of n\n\
! 	addx	%1,%1,%1	! so this can't give carry\n\
! 	subcc	%%g1,1,%%g1\n\
! 2:	bne	1b\n\
! 	 subcc	%1,%2,%%g0\n\
! 	bcs	3f\n\
! 	 addxcc %0,%0,%0	! shift n1n0 and a q-bit in lsb\n\
! 	b	3f\n\
! 	 sub	%1,%2,%1	! this kills msb of n\n\
! 4:	sub	%1,%2,%1\n\
! 5:	addxcc	%1,%1,%1\n\
! 	bcc	2b\n\
! 	 subcc	%%g1,1,%%g1\n\
! ! Got carry from n.  Subtract next step to cancel this carry.\n\
! 	bne	4b\n\
! 	 addcc	%0,%0,%0	! shift n1n0 and a 0-bit in lsb\n\
! 	sub	%1,%2,%1\n\
! 3:	xnor	%0,0,%0\n\
  	! End of inline udiv_qrnnd"					\
  	   : "=&r" ((USItype) (q)),					\
  	     "=&r" ((USItype) (r))					\
***************
*** 1070,1076 ****
  
  #if defined (__vax__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("addl2 %5,%1
  	adwc %3,%0"							\
  	   : "=g" ((USItype) (sh)),					\
  	     "=&g" ((USItype) (sl))					\
--- 1070,1076 ----
  
  #if defined (__vax__)
  #define add_ssaaaa(sh, sl, ah, al, bh, bl) \
!   __asm__ ("addl2 %5,%1\n\
  	adwc %3,%0"							\
  	   : "=g" ((USItype) (sh)),					\
  	     "=&g" ((USItype) (sl))					\
***************
*** 1079,1085 ****
  	     "%1" ((USItype) (al)),					\
  	     "g" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("subl2 %5,%1
  	sbwc %3,%0"							\
  	   : "=g" ((USItype) (sh)),					\
  	     "=&g" ((USItype) (sl))					\
--- 1079,1085 ----
  	     "%1" ((USItype) (al)),					\
  	     "g" ((USItype) (bl)))
  #define sub_ddmmss(sh, sl, ah, al, bh, bl) \
!   __asm__ ("subl2 %5,%1\n\
  	sbwc %3,%0"							\
  	   : "=g" ((USItype) (sh)),					\
  	     "=&g" ((USItype) (sl))					\
diff -rc gcc-2.8.1.orig/mbchar.c gcc-2.8.1/mbchar.c
*** gcc-2.8.1.orig/mbchar.c	2006-03-25 00:16:52.000000000 +0100
--- gcc-2.8.1/mbchar.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 0 ****
--- 1 ----
+ /* empty */
diff -rc gcc-2.8.1.orig/optabs.c gcc-2.8.1/optabs.c
*** gcc-2.8.1.orig/optabs.c	1998-02-14 12:41:17.000000000 +0100
--- gcc-2.8.1/optabs.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 1379,1384 ****
--- 1379,1422 ----
  
  	      ok = 1;
  	    }
+ #ifdef GPC
+           /* Optimization if real part of divisor is zero.  */
+ 	  else if (real1 == 0)
+ 	    {
+ 	      /* (a+ib) / (0+id) == -i(a+ib) / d == (b/d + i(-a/d) */
+ 
+ 	      /* Fetch imag1 from memory only once.  */
+ 	      imag1 = force_reg (submode, imag1);
+ 
+ 	      if (class == MODE_COMPLEX_FLOAT)
+ 		res = expand_binop (submode, binoptab, imag0, imag1,
+ 				    realr, unsignedp, methods);
+ 	      else
+ 		res = expand_divmod (0, TRUNC_DIV_EXPR, submode,
+ 				     imag0, imag1, realr, unsignedp);
+ 	      if (res == 0)
+ 		break;
+ 	      else if (res != realr)
+ 		emit_move_insn (realr, res);
+ 
+ 	      if (class == MODE_COMPLEX_FLOAT)
+ 		res = expand_binop (submode, binoptab, real0,
+ 				    imag1, imagr, unsignedp, methods);
+ 	      else
+ 		res = expand_divmod (0, TRUNC_DIV_EXPR, submode,
+ 				     real0, imag1, imagr, unsignedp);
+ 
+ 	      /* Negate the imaginary part.  */
+ 	      res = expand_unop (submode, neg_optab,
+ 				 res, imagr, unsignedp);
+ 	      if (res == 0)
+ 		break;
+ 	      else if (res != imagr)
+ 		emit_move_insn (imagr, res);
+ 
+ 	      ok = 1;
+ 	    }
+ #endif /* GPC */
  	  else
  	    {
  	      /* Divisor is of complex type:
Tylko w gcc-2.8.1: p
diff -rc gcc-2.8.1.orig/pexecute.c gcc-2.8.1/pexecute.c
*** gcc-2.8.1.orig/pexecute.c	1998-01-07 23:40:36.000000000 +0100
--- gcc-2.8.1/pexecute.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 126,132 ****
       char * const *argv;
       const char *this_pname;
       const char *temp_base;
!      char **errmsg_fmt, **errmsg_arg;
       int flags;
  {
    int rc;
--- 126,132 ----
       char * const *argv;
       const char *this_pname;
       const char *temp_base;
!      const char **errmsg_fmt, **errmsg_arg;
       int flags;
  {
    int rc;
diff -rc gcc-2.8.1.orig/prefix.c gcc-2.8.1/prefix.c
*** gcc-2.8.1.orig/prefix.c	1998-02-06 15:04:22.000000000 +0100
--- gcc-2.8.1/prefix.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 232,238 ****
       char *name;
  {
    char code = name[0];
!   char *key, *prefix = 0;
    int keylen;
  
    if (code != '@' && code != '$')
--- 232,238 ----
       char *name;
  {
    char code = name[0];
!   char *key, *prefix = 0, *oldname = name;
    int keylen;
  
    if (code != '@' && code != '$')
***************
*** 272,278 ****
        prefix[strlen (prefix) - 1] = 0;
      }
  
!   return concat (prefix, name, NULL_PTR);
  }
  
  /* Update PATH using KEY if PATH starts with PREFIX.  */
--- 272,283 ----
        prefix[strlen (prefix) - 1] = 0;
      }
  
!   name = concat (prefix, name, NULL_PTR);
! 
!   if (!strcmp (name, oldname))
!     return 0;
! 
!   return name;
  }
  
  /* Update PATH using KEY if PATH starts with PREFIX.  */
diff -rc gcc-2.8.1.orig/print-tree.c gcc-2.8.1/print-tree.c
*** gcc-2.8.1.orig/print-tree.c	1997-08-07 12:54:37.000000000 +0200
--- gcc-2.8.1/print-tree.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 66,72 ****
  void
  print_node_brief (file, prefix, node, indent)
       FILE *file;
!      char *prefix;
       tree node;
       int indent;
  {
--- 66,72 ----
  void
  print_node_brief (file, prefix, node, indent)
       FILE *file;
!      const char *prefix;
       tree node;
       int indent;
  {
***************
*** 178,184 ****
  void
  print_node (file, prefix, node, indent)
       FILE *file;
!      char *prefix;
       tree node;
       int indent;
  {
--- 178,184 ----
  void
  print_node (file, prefix, node, indent)
       FILE *file;
!      const char *prefix;
       tree node;
       int indent;
  {
diff -rc gcc-2.8.1.orig/profile.c gcc-2.8.1/profile.c
*** gcc-2.8.1.orig/profile.c	1998-01-15 02:27:10.000000000 +0100
--- gcc-2.8.1/profile.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 52,58 ****
  #include "output.h"
  #include "gcov-io.h"
  
- extern char * xmalloc ();
  extern void free ();
  
  /* One of these is dynamically created whenever we identify an arc in the
--- 52,57 ----
diff -rc gcc-2.8.1.orig/rtl.h gcc-2.8.1/rtl.h
*** gcc-2.8.1.orig/rtl.h	1998-02-07 01:38:46.000000000 +0100
--- gcc-2.8.1/rtl.h	2006-03-13 23:21:10.000000000 +0100
***************
*** 685,692 ****
  extern char *xmalloc			PROTO((size_t));
  extern char *xrealloc			PROTO((void *, size_t));
  #else
! extern char *xmalloc ();
! extern char *xrealloc ();
  #endif
  
  extern char *oballoc			PROTO((int));
--- 685,692 ----
  extern char *xmalloc			PROTO((size_t));
  extern char *xrealloc			PROTO((void *, size_t));
  #else
! extern void *xmalloc ();
! extern void *xrealloc ();
  #endif
  
  extern char *oballoc			PROTO((int));
***************
*** 1002,1004 ****
--- 1002,1007 ----
  
  extern int computed_jump_p	PROTO((rtx));
  
+ extern int get_first_label_num PARAMS((void));
+ extern void set_new_first_and_last_label_num PARAMS((int, int));
+ extern int max_label_num PARAMS((void));
diff -rc gcc-2.8.1.orig/stor-layout.c gcc-2.8.1/stor-layout.c
*** gcc-2.8.1.orig/stor-layout.c	1997-11-08 15:12:07.000000000 +0100
--- gcc-2.8.1/stor-layout.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 19,24 ****
--- 19,26 ----
  Boston, MA 02111-1307, USA.  */
  
  
+ /* @@ PATCHED FOR GPC 20070903 @@ */
+ 
  #include "config.h"
  #include <stdio.h>
  
***************
*** 51,56 ****
--- 53,71 ----
     May be overridden by front-ends.  */
  int set_alignment = 0;
  
+ #ifdef GPC
+ /* The word size of a bitstring or (power-)set value, in bits.
+    Must be non-zero.
+    May be overridden by front-ends.  */
+ int set_word_size = BITS_PER_UNIT;
+ 
+ /* If non-zero, bits in (power-)sets start with the highest bit.
+    May be overridden by front-ends.
+    In order to be backward-compatible, the Chill frontend should
+    initialize this to BYTES_BIG_ENDIAN.  */
+ int set_words_big_endian = 0;
+ #endif /* GPC */
+ 
  static enum machine_mode smallest_mode_for_size  PROTO((unsigned int,
  							enum mode_class));
  static tree layout_record	PROTO((tree));
***************
*** 786,793 ****
--- 801,819 ----
  					 lb, 0))
  	      ub = TREE_OPERAND (ub, 0);
  
+ #ifdef GPC
+ 	    /* Taken from gcc-3.3.4 -- Frank */
+ 	    /* The initial subtraction should happen in the original type so
+ 	       that (possible) negative values are handled appropriately.  */
+ 	    length = size_binop (PLUS_EXPR, size_one_node,
+ 				 convert (sizetype,
+ 					  fold (build (MINUS_EXPR,
+ 						       TREE_TYPE (lb),
+ 						       ub, lb))));
+ #else
  	    length = size_binop (PLUS_EXPR, size_one_node,
  				 size_binop (MINUS_EXPR, ub, lb));
+ #endif
  
  	    /* If neither bound is a constant and sizetype is signed, make
  	       sure the size is never negative.  We should really do this
***************
*** 962,973 ****
--- 988,1014 ----
  #ifndef SET_WORD_SIZE
  #define SET_WORD_SIZE BITS_PER_WORD
  #endif
+ #ifdef GPC
+           int alignment = set_alignment ? set_alignment : set_word_size;
+           int lower_bound = TREE_INT_CST_LOW (TYPE_MIN_VALUE (TYPE_DOMAIN (type)));
+           int upper_bound = TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type)));
+           int size_in_bits, rounded_size;
+           if (set_alignment)
+             size_in_bits = upper_bound - (lower_bound & (-alignment)) + 1;
+           else
+             size_in_bits
+               = (TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))
+                  - TREE_INT_CST_LOW (TYPE_MIN_VALUE (TYPE_DOMAIN (type))) + 1);
+           rounded_size
+             = ((size_in_bits + alignment - 1) / alignment) * alignment;
+ #else /* not GPC */
  	  int alignment = set_alignment ? set_alignment : SET_WORD_SIZE;
  	  int size_in_bits
  	    = (TREE_INT_CST_LOW (TYPE_MAX_VALUE (TYPE_DOMAIN (type)))
  	       - TREE_INT_CST_LOW (TYPE_MIN_VALUE (TYPE_DOMAIN (type))) + 1);
  	  int rounded_size
  	    = ((size_in_bits + alignment - 1) / alignment) * alignment;
+ #endif /* not GPC */
  	  if (rounded_size > alignment)
  	    TYPE_MODE (type) = BLKmode;
  	  else
diff -rc gcc-2.8.1.orig/system.h gcc-2.8.1/system.h
*** gcc-2.8.1.orig/system.h	2006-03-25 00:17:36.000000000 +0100
--- gcc-2.8.1/system.h	2006-03-13 23:21:10.000000000 +0100
***************
*** 0 ****
--- 1,1179 ----
+ /* system.h - Get common system includes and various definitions and
+    declarations based on autoconf macros.
+    Copyright (C) 1998 Free Software Foundation, Inc.
+ 
+  */
+ 
+ #ifndef __GCC_SYSTEM_H__
+ #define __GCC_SYSTEM_H__
+ 
+ /* We must include stdarg.h/varargs.h before stdio.h. */
+ #ifdef ANSI_PROTOTYPES
+ #include <stdarg.h>
+ #else
+ #include <varargs.h>
+ #endif
+ 
+ #include <stdio.h>
+ 
+ /* Define a generic NULL if one hasn't already been defined.  */
+ #ifndef NULL
+ #define NULL 0
+ #endif
+ 
+ /* The compiler is not a multi-threaded application and therefore we
+    do not have to use the locking functions.  */
+ #ifdef HAVE_PUTC_UNLOCKED
+ # undef putc
+ # define putc(C, Stream) putc_unlocked (C, Stream)
+ #endif
+ #ifdef HAVE_FPUTC_UNLOCKED
+ # undef fputc
+ # define fputc(C, Stream) fputc_unlocked (C, Stream)
+ #endif
+ #ifdef HAVE_FPUTS_UNLOCKED
+ # undef fputs
+ # define fputs(String, Stream) fputs_unlocked (String, Stream)
+ #endif
+ 
+ #include <ctype.h>
+ 
+ /* Jim Meyering writes:
+ 
+    "... Some ctype macros are valid only for character codes that
+    isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
+    using /bin/cc or gcc but without giving an ansi option).  So, all
+    ctype uses should be through macros like ISPRINT...  If
+    STDC_HEADERS is defined, then autoconf has verified that the ctype
+    macros don't need to be guarded with references to isascii. ...
+    Defining isascii to 1 should let any compiler worth its salt
+    eliminate the && through constant folding."
+ 
+    Bruno Haible adds:
+ 
+    "... Furthermore, isupper(c) etc. have an undefined result if c is
+    outside the range -1 <= c <= 255. One is tempted to write isupper(c)
+    with c being of type `char', but this is wrong if c is an 8-bit
+    character >= 128 which gets sign-extended to a negative value.
+    The macro ISUPPER protects against this as well."  */
+ 
+ #if defined (STDC_HEADERS) || (!defined (isascii) && !defined (HAVE_ISASCII))
+ # define IN_CTYPE_DOMAIN(c) 1
+ #else
+ # define IN_CTYPE_DOMAIN(c) isascii(c)
+ #endif
+ 
+ #ifdef isblank
+ # define ISBLANK(c) (IN_CTYPE_DOMAIN (c) && isblank (c))
+ #else
+ # define ISBLANK(c) ((c) == ' ' || (c) == '\t')
+ #endif
+ #ifdef isgraph
+ # define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isgraph (c))
+ #else
+ # define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isprint (c) && !(isspace (c)))
+ #endif
+ 
+ #define ISPRINT(c) (IN_CTYPE_DOMAIN (c) && isprint (c))
+ #define ISALNUM(c) (IN_CTYPE_DOMAIN (c) && isalnum (c))
+ #define ISALPHA(c) (IN_CTYPE_DOMAIN (c) && isalpha (c))
+ #define ISCNTRL(c) (IN_CTYPE_DOMAIN (c) && iscntrl (c))
+ #define ISLOWER(c) (IN_CTYPE_DOMAIN (c) && islower (c))
+ #define ISPUNCT(c) (IN_CTYPE_DOMAIN (c) && ispunct (c))
+ #define ISSPACE(c) (IN_CTYPE_DOMAIN (c) && isspace (c))
+ #define ISUPPER(c) (IN_CTYPE_DOMAIN (c) && isupper (c))
+ #define ISXDIGIT(c) (IN_CTYPE_DOMAIN (c) && isxdigit (c))
+ #define ISDIGIT_LOCALE(c) (IN_CTYPE_DOMAIN (c) && isdigit (c))
+ 
+ /* ISDIGIT differs from ISDIGIT_LOCALE, as follows:
+    - Its arg may be any int or unsigned int; it need not be an unsigned char.
+    - It's guaranteed to evaluate its argument exactly once.
+    - It's typically faster.
+    Posix 1003.2-1992 section 2.5.2.1 page 50 lines 1556-1558 says that
+    only '0' through '9' are digits.  Prefer ISDIGIT to ISDIGIT_LOCALE unless
+    it's important to use the locale's definition of `digit' even when the
+    host does not conform to Posix.  */
+ #define ISDIGIT(c) ((unsigned) (c) - '0' <= 9)
+ 
+ 
+ #include <sys/types.h>
+ #include <errno.h>
+ 
+ #ifndef errno
+ extern int errno;
+ #endif
+ 
+ #ifdef STRING_WITH_STRINGS
+ # include <string.h>
+ # include <strings.h>
+ #else
+ # ifdef HAVE_STRING_H
+ #  include <string.h>
+ # else
+ #  ifdef HAVE_STRINGS_H
+ #   include <strings.h>
+ #  endif
+ # endif
+ #endif
+ 
+ #ifdef HAVE_STDLIB_H
+ # include <stdlib.h>
+ #endif
+ 
+ #ifdef HAVE_UNISTD_H
+ # include <unistd.h>
+ #endif
+ 
+ #ifdef HAVE_SYS_PARAM_H
+ # include <sys/param.h>
+ #endif
+ 
+ #if HAVE_LIMITS_H
+ # include <limits.h>
+ #endif
+ 
+ #ifdef TIME_WITH_SYS_TIME
+ # include <sys/time.h>
+ # include <time.h>
+ #else
+ # if HAVE_SYS_TIME_H
+ #  include <sys/time.h>
+ # else
+ #  ifdef HAVE_TIME_H
+ #   include <time.h>
+ #  endif
+ # endif
+ #endif
+ 
+ #ifdef HAVE_FCNTL_H
+ # include <fcntl.h>
+ #else
+ # ifdef HAVE_SYS_FILE_H
+ #  include <sys/file.h>
+ # endif
+ #endif
+ 
+ #ifndef SEEK_SET
+ # define SEEK_SET 0
+ # define SEEK_CUR 1
+ # define SEEK_END 2
+ #endif
+ #ifndef F_OK
+ # define F_OK 0
+ # define X_OK 1
+ # define W_OK 2
+ # define R_OK 4
+ #endif
+ #ifndef O_RDONLY
+ # define O_RDONLY 0
+ #endif
+ #ifndef O_WRONLY
+ # define O_WRONLY 1
+ #endif
+ 
+ #ifdef HAVE_SYS_WAIT_H
+ #include <sys/wait.h>
+ #endif
+ 
+ #ifndef WIFSIGNALED
+ #define WIFSIGNALED(S) (((S) & 0xff) != 0 && ((S) & 0xff) != 0x7f)
+ #endif
+ #ifndef WTERMSIG
+ #define WTERMSIG(S) ((S) & 0x7f)
+ #endif
+ #ifndef WIFEXITED
+ #define WIFEXITED(S) (((S) & 0xff) == 0)
+ #endif
+ #ifndef WEXITSTATUS
+ #define WEXITSTATUS(S) (((S) & 0xff00) >> 8)
+ #endif
+ 
+ 
+ 
+ #ifndef bcopy
+ # ifdef HAVE_BCOPY
+ #  ifdef NEED_DECLARATION_BCOPY
+ extern void bcopy ();
+ #  endif
+ # else /* ! HAVE_BCOPY */
+ #  define bcopy(src,dst,len) memcpy ((dst),(src),(len))
+ # endif
+ #endif
+ 
+ #ifndef bcmp
+ # ifdef HAVE_BCMP
+ #  ifdef NEED_DECLARATION_BCMP
+ extern int bcmp ();
+ #  endif
+ # else /* ! HAVE_BCMP */
+ #  define bcmp(left,right,len) memcmp ((left),(right),(len))
+ # endif
+ #endif
+ 
+ #ifndef bzero
+ # ifdef HAVE_BZERO
+ #  ifdef NEED_DECLARATION_BZERO
+ extern void bzero ();
+ #  endif
+ # else /* ! HAVE_BZERO */
+ #  define bzero(dst,len) memset ((dst),0,(len))
+ # endif
+ #endif
+ 
+ #ifndef index
+ # ifdef HAVE_INDEX
+ #  ifdef NEED_DECLARATION_INDEX
+ extern char *index ();
+ #  endif
+ # else /* ! HAVE_INDEX */
+ #  define index strchr
+ # endif
+ #endif
+ 
+ #ifndef rindex
+ # ifdef HAVE_RINDEX
+ #  ifdef NEED_DECLARATION_RINDEX
+ extern char *rindex ();
+ #  endif
+ # else /* ! HAVE_RINDEX */
+ #  define rindex strrchr
+ # endif
+ #endif
+ 
+ #ifdef NEED_DECLARATION_ATOF
+ extern double atof ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_ATOL
+ extern long atol();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_FREE
+ extern void free ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_GETCWD
+ extern char *getcwd ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_GETENV
+ extern char *getenv ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_GETWD
+ extern char *getwd ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_SBRK
+ extern char *sbrk ();
+ #endif
+ 
+ #ifdef HAVE_STRERROR
+ # ifdef NEED_DECLARATION_STRERROR
+ #  ifndef strerror
+ extern char *strerror ();
+ #  endif
+ # endif
+ #else /* ! HAVE_STRERROR */
+ extern int sys_nerr;
+ extern char *sys_errlist[];
+ #endif /* HAVE_STRERROR */
+ 
+ #ifdef HAVE_STRSIGNAL
+ # ifdef NEED_DECLARATION_STRSIGNAL
+ #  ifndef strsignal
+ extern char * strsignal ();
+ #  endif
+ # endif
+ #else /* ! HAVE_STRSIGNAL */
+ # ifndef SYS_SIGLIST_DECLARED
+ #  ifndef NO_SYS_SIGLIST
+ extern char * sys_siglist[];
+ #  endif
+ # endif
+ #endif /* HAVE_STRSIGNAL */
+ 
+ #ifdef HAVE_GETRLIMIT
+ # ifdef NEED_DECLARATION_GETRLIMIT
+ #  ifndef getrlimit
+ extern int getrlimit ();
+ #  endif
+ # endif
+ #endif
+ 
+ #ifdef HAVE_SETRLIMIT
+ # ifdef NEED_DECLARATION_SETRLIMIT
+ #  ifndef setrlimit
+ extern int setrlimit ();
+ #  endif
+ # endif
+ #endif
+ 
+ /* HAVE_VOLATILE only refers to the stage1 compiler.  We also check
+    __STDC__ and assume gcc sets it and has volatile in stage >=2. */
+ #if !defined(HAVE_VOLATILE) && !defined(__STDC__) && !defined(volatile)
+ #define volatile
+ #endif
+ 
+ /* Redefine abort to report an internal error w/o coredump, and reporting the
+    location of the error in the source file.  */
+ #ifndef abort
+ #ifndef __STDC__
+ #ifndef __GNUC__
+ #ifndef USE_SYSTEM_ABORT
+ #define USE_SYSTEM_ABORT
+ #endif /* !USE_SYSTEM_ABORT */
+ #endif /* !__GNUC__ */
+ #endif /* !__STDC__ */
+ 
+ #ifdef USE_SYSTEM_ABORT
+ # ifdef NEED_DECLARATION_ABORT
+ extern void abort ();
+ # endif
+ #else
+ #if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
+ #define abort()								\
+ (fprintf (stderr,							\
+ 	  "%s:%d: Internal compiler error\n", __FILE__, __LINE__),	\
+  exit (FATAL_EXIT_CODE))
+ 
+ #else
+ #define abort()								\
+ (fprintf (stderr,							\
+ 	  "%s:%d: Internal compiler error in function %s\n",		\
+ 	  __FILE__, __LINE__, __PRETTY_FUNCTION__),			\
+  exit (FATAL_EXIT_CODE))
+ 
+ #endif /* recent gcc */
+ #endif /* USE_SYSTEM_ABORT */
+ #endif /* !abort */
+ 
+ 
+ /* Define a STRINGIFY macro that's right for ANSI or traditional C.
+    HAVE_CPP_STRINGIFY only refers to the stage1 compiler.  Assume that
+    (non-traditional) gcc used in stage2 or later has this feature.
+ 
+    Note: if the argument passed to STRINGIFY is itself a macro, eg
+    #define foo bar, STRINGIFY(foo) will produce "foo", not "bar".
+    Although the __STDC__ case could be made to expand this via a layer
+    of indirection, the traditional C case can not do so.  Therefore
+    this behavior is not supported. */
+ #ifndef STRINGIFY
+ # if defined(HAVE_CPP_STRINGIFY) || (defined(__GNUC__) && defined(__STDC__))
+ #  define STRINGIFY(STRING) #STRING
+ # else
+ #  define STRINGIFY(STRING) "STRING"
+ # endif
+ #endif /* ! STRINGIFY */
+ 
+ 
+ /* These macros are here in preparation for the use of gettext in egcs.  */
+ #define _(String) String
+ #define N_(String) String
+ 
+ #if HAVE_SYS_STAT_H
+ # include <sys/stat.h>
+ #endif
+ 
+ /* Test if something is a normal file.  */
+ #ifndef S_ISREG
+ #define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
+ #endif
+ 
+ /* Test if something is a directory.  */
+ #ifndef S_ISDIR
+ #define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
+ #endif
+ 
+ #if !defined(GPC) || defined(EGCS)
+ /* Get libiberty declarations. */
+ #include "libiberty.h"
+ #endif
+ 
+ #endif /* __GCC_SYSTEM_H__ */
+ /* system.h - Get common system includes and various definitions and
+    declarations based on autoconf macros.
+    Copyright (C) 1998 Free Software Foundation, Inc.
+ 
+  */
+ 
+ #ifndef __GCC_SYSTEM_H__
+ #define __GCC_SYSTEM_H__
+ 
+ /* We must include stdarg.h/varargs.h before stdio.h. */
+ #ifdef ANSI_PROTOTYPES
+ #include <stdarg.h>
+ #else
+ #include <varargs.h>
+ #endif
+ 
+ #include <stdio.h>
+ 
+ /* Define a generic NULL if one hasn't already been defined.  */
+ #ifndef NULL
+ #define NULL 0
+ #endif
+ 
+ /* The compiler is not a multi-threaded application and therefore we
+    do not have to use the locking functions.  */
+ #ifdef HAVE_PUTC_UNLOCKED
+ # undef putc
+ # define putc(C, Stream) putc_unlocked (C, Stream)
+ #endif
+ #ifdef HAVE_FPUTC_UNLOCKED
+ # undef fputc
+ # define fputc(C, Stream) fputc_unlocked (C, Stream)
+ #endif
+ #ifdef HAVE_FPUTS_UNLOCKED
+ # undef fputs
+ # define fputs(String, Stream) fputs_unlocked (String, Stream)
+ #endif
+ 
+ #include <ctype.h>
+ 
+ /* Jim Meyering writes:
+ 
+    "... Some ctype macros are valid only for character codes that
+    isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
+    using /bin/cc or gcc but without giving an ansi option).  So, all
+    ctype uses should be through macros like ISPRINT...  If
+    STDC_HEADERS is defined, then autoconf has verified that the ctype
+    macros don't need to be guarded with references to isascii. ...
+    Defining isascii to 1 should let any compiler worth its salt
+    eliminate the && through constant folding."
+ 
+    Bruno Haible adds:
+ 
+    "... Furthermore, isupper(c) etc. have an undefined result if c is
+    outside the range -1 <= c <= 255. One is tempted to write isupper(c)
+    with c being of type `char', but this is wrong if c is an 8-bit
+    character >= 128 which gets sign-extended to a negative value.
+    The macro ISUPPER protects against this as well."  */
+ 
+ #if defined (STDC_HEADERS) || (!defined (isascii) && !defined (HAVE_ISASCII))
+ # define IN_CTYPE_DOMAIN(c) 1
+ #else
+ # define IN_CTYPE_DOMAIN(c) isascii(c)
+ #endif
+ 
+ #ifdef isblank
+ # define ISBLANK(c) (IN_CTYPE_DOMAIN (c) && isblank (c))
+ #else
+ # define ISBLANK(c) ((c) == ' ' || (c) == '\t')
+ #endif
+ #ifdef isgraph
+ # define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isgraph (c))
+ #else
+ # define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isprint (c) && !isspace (c))
+ #endif
+ 
+ #define ISPRINT(c) (IN_CTYPE_DOMAIN (c) && isprint (c))
+ #define ISALNUM(c) (IN_CTYPE_DOMAIN (c) && isalnum (c))
+ #define ISALPHA(c) (IN_CTYPE_DOMAIN (c) && isalpha (c))
+ #define ISCNTRL(c) (IN_CTYPE_DOMAIN (c) && iscntrl (c))
+ #define ISLOWER(c) (IN_CTYPE_DOMAIN (c) && islower (c))
+ #define ISPUNCT(c) (IN_CTYPE_DOMAIN (c) && ispunct (c))
+ #define ISSPACE(c) (IN_CTYPE_DOMAIN (c) && isspace (c))
+ #define ISUPPER(c) (IN_CTYPE_DOMAIN (c) && isupper (c))
+ #define ISXDIGIT(c) (IN_CTYPE_DOMAIN (c) && isxdigit (c))
+ #define ISDIGIT_LOCALE(c) (IN_CTYPE_DOMAIN (c) && isdigit (c))
+ 
+ /* ISDIGIT differs from ISDIGIT_LOCALE, as follows:
+    - Its arg may be any int or unsigned int; it need not be an unsigned char.
+    - It's guaranteed to evaluate its argument exactly once.
+    - It's typically faster.
+    Posix 1003.2-1992 section 2.5.2.1 page 50 lines 1556-1558 says that
+    only '0' through '9' are digits.  Prefer ISDIGIT to ISDIGIT_LOCALE unless
+    it's important to use the locale's definition of `digit' even when the
+    host does not conform to Posix.  */
+ #define ISDIGIT(c) ((unsigned) (c) - '0' <= 9)
+ 
+ 
+ #include <sys/types.h>
+ #include <errno.h>
+ 
+ #ifndef errno
+ extern int errno;
+ #endif
+ 
+ #ifdef STRING_WITH_STRINGS
+ # include <string.h>
+ # include <strings.h>
+ #else
+ # ifdef HAVE_STRING_H
+ #  include <string.h>
+ # else
+ #  ifdef HAVE_STRINGS_H
+ #   include <strings.h>
+ #  endif
+ # endif
+ #endif
+ 
+ #ifdef HAVE_STDLIB_H
+ # include <stdlib.h>
+ #endif
+ 
+ #ifdef HAVE_UNISTD_H
+ # include <unistd.h>
+ #endif
+ 
+ #ifdef HAVE_SYS_PARAM_H
+ # include <sys/param.h>
+ #endif
+ 
+ #if HAVE_LIMITS_H
+ # include <limits.h>
+ #endif
+ 
+ #ifdef TIME_WITH_SYS_TIME
+ # include <sys/time.h>
+ # include <time.h>
+ #else
+ # if HAVE_SYS_TIME_H
+ #  include <sys/time.h>
+ # else
+ #  ifdef HAVE_TIME_H
+ #   include <time.h>
+ #  endif
+ # endif
+ #endif
+ 
+ #ifdef HAVE_FCNTL_H
+ # include <fcntl.h>
+ #else
+ # ifdef HAVE_SYS_FILE_H
+ #  include <sys/file.h>
+ # endif
+ #endif
+ 
+ #ifndef SEEK_SET
+ # define SEEK_SET 0
+ # define SEEK_CUR 1
+ # define SEEK_END 2
+ #endif
+ #ifndef F_OK
+ # define F_OK 0
+ # define X_OK 1
+ # define W_OK 2
+ # define R_OK 4
+ #endif
+ #ifndef O_RDONLY
+ # define O_RDONLY 0
+ #endif
+ #ifndef O_WRONLY
+ # define O_WRONLY 1
+ #endif
+ 
+ #ifdef HAVE_SYS_WAIT_H
+ #include <sys/wait.h>
+ #endif
+ 
+ #ifndef WIFSIGNALED
+ #define WIFSIGNALED(S) (((S) & 0xff) != 0 && ((S) & 0xff) != 0x7f)
+ #endif
+ #ifndef WTERMSIG
+ #define WTERMSIG(S) ((S) & 0x7f)
+ #endif
+ #ifndef WIFEXITED
+ #define WIFEXITED(S) (((S) & 0xff) == 0)
+ #endif
+ #ifndef WEXITSTATUS
+ #define WEXITSTATUS(S) (((S) & 0xff00) >> 8)
+ #endif
+ 
+ 
+ 
+ #ifndef bcopy
+ # ifdef HAVE_BCOPY
+ #  ifdef NEED_DECLARATION_BCOPY
+ extern void bcopy ();
+ #  endif
+ # else /* ! HAVE_BCOPY */
+ #  define bcopy(src,dst,len) memcpy ((dst),(src),(len))
+ # endif
+ #endif
+ 
+ #ifndef bcmp
+ # ifdef HAVE_BCMP
+ #  ifdef NEED_DECLARATION_BCMP
+ extern int bcmp ();
+ #  endif
+ # else /* ! HAVE_BCMP */
+ #  define bcmp(left,right,len) memcmp ((left),(right),(len))
+ # endif
+ #endif
+ 
+ #ifndef bzero
+ # ifdef HAVE_BZERO
+ #  ifdef NEED_DECLARATION_BZERO
+ extern void bzero ();
+ #  endif
+ # else /* ! HAVE_BZERO */
+ #  define bzero(dst,len) memset ((dst),0,(len))
+ # endif
+ #endif
+ 
+ #ifndef index
+ # ifdef HAVE_INDEX
+ #  ifdef NEED_DECLARATION_INDEX
+ extern char *index ();
+ #  endif
+ # else /* ! HAVE_INDEX */
+ #  define index strchr
+ # endif
+ #endif
+ 
+ #ifndef rindex
+ # ifdef HAVE_RINDEX
+ #  ifdef NEED_DECLARATION_RINDEX
+ extern char *rindex ();
+ #  endif
+ # else /* ! HAVE_RINDEX */
+ #  define rindex strrchr
+ # endif
+ #endif
+ 
+ #ifdef NEED_DECLARATION_ATOF
+ extern double atof ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_ATOL
+ extern long atol();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_FREE
+ extern void free ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_GETCWD
+ extern char *getcwd ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_GETENV
+ extern char *getenv ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_GETWD
+ extern char *getwd ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_SBRK
+ extern char *sbrk ();
+ #endif
+ 
+ #ifdef HAVE_STRERROR
+ # ifdef NEED_DECLARATION_STRERROR
+ #  ifndef strerror
+ extern char *strerror ();
+ #  endif
+ # endif
+ #else /* ! HAVE_STRERROR */
+ extern int sys_nerr;
+ extern char *sys_errlist[];
+ #endif /* HAVE_STRERROR */
+ 
+ #ifdef HAVE_STRSIGNAL
+ # ifdef NEED_DECLARATION_STRSIGNAL
+ #  ifndef strsignal
+ extern char * strsignal ();
+ #  endif
+ # endif
+ #else /* ! HAVE_STRSIGNAL */
+ # ifndef SYS_SIGLIST_DECLARED
+ #  ifndef NO_SYS_SIGLIST
+ extern char * sys_siglist[];
+ #  endif
+ # endif
+ #endif /* HAVE_STRSIGNAL */
+ 
+ #ifdef HAVE_GETRLIMIT
+ # ifdef NEED_DECLARATION_GETRLIMIT
+ #  ifndef getrlimit
+ extern int getrlimit ();
+ #  endif
+ # endif
+ #endif
+ 
+ #ifdef HAVE_SETRLIMIT
+ # ifdef NEED_DECLARATION_SETRLIMIT
+ #  ifndef setrlimit
+ extern int setrlimit ();
+ #  endif
+ # endif
+ #endif
+ 
+ /* HAVE_VOLATILE only refers to the stage1 compiler.  We also check
+    __STDC__ and assume gcc sets it and has volatile in stage >=2. */
+ #if !defined(HAVE_VOLATILE) && !defined(__STDC__) && !defined(volatile)
+ #define volatile
+ #endif
+ 
+ /* Redefine abort to report an internal error w/o coredump, and reporting the
+    location of the error in the source file.  */
+ #ifndef abort
+ #ifndef __STDC__
+ #ifndef __GNUC__
+ #ifndef USE_SYSTEM_ABORT
+ #define USE_SYSTEM_ABORT
+ #endif /* !USE_SYSTEM_ABORT */
+ #endif /* !__GNUC__ */
+ #endif /* !__STDC__ */
+ 
+ #ifdef USE_SYSTEM_ABORT
+ # ifdef NEED_DECLARATION_ABORT
+ extern void abort ();
+ # endif
+ #else
+ #if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
+ #define abort()								\
+ (fprintf (stderr,							\
+ 	  "%s:%d: Internal compiler error\n", __FILE__, __LINE__),	\
+  exit (FATAL_EXIT_CODE))
+ 
+ #else
+ #define abort()								\
+ (fprintf (stderr,							\
+ 	  "%s:%d: Internal compiler error in function %s\n",		\
+ 	  __FILE__, __LINE__, __PRETTY_FUNCTION__),			\
+  exit (FATAL_EXIT_CODE))
+ 
+ #endif /* recent gcc */
+ #endif /* USE_SYSTEM_ABORT */
+ #endif /* !abort */
+ 
+ 
+ /* Define a STRINGIFY macro that's right for ANSI or traditional C.
+    HAVE_CPP_STRINGIFY only refers to the stage1 compiler.  Assume that
+    (non-traditional) gcc used in stage2 or later has this feature.
+ 
+    Note: if the argument passed to STRINGIFY is itself a macro, eg
+    #define foo bar, STRINGIFY(foo) will produce "foo", not "bar".
+    Although the __STDC__ case could be made to expand this via a layer
+    of indirection, the traditional C case can not do so.  Therefore
+    this behavior is not supported. */
+ #ifndef STRINGIFY
+ # if defined(HAVE_CPP_STRINGIFY) || (defined(__GNUC__) && defined(__STDC__))
+ #  define STRINGIFY(STRING) #STRING
+ # else
+ #  define STRINGIFY(STRING) "STRING"
+ # endif
+ #endif /* ! STRINGIFY */
+ 
+ 
+ /* These macros are here in preparation for the use of gettext in egcs.  */
+ #define _(String) String
+ #define N_(String) String
+ 
+ #if HAVE_SYS_STAT_H
+ # include <sys/stat.h>
+ #endif
+ 
+ /* Test if something is a normal file.  */
+ #ifndef S_ISREG
+ #define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
+ #endif
+ 
+ /* Test if something is a directory.  */
+ #ifndef S_ISDIR
+ #define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
+ #endif
+ 
+ #if !defined(GPC) || defined(EGCS)
+ /* Get libiberty declarations. */
+ #include "libiberty.h"
+ #endif
+ 
+ #endif /* __GCC_SYSTEM_H__ */
+ /* system.h - Get common system includes and various definitions and
+    declarations based on autoconf macros.
+    Copyright (C) 1998 Free Software Foundation, Inc.
+ 
+  */
+ 
+ #ifndef __GCC_SYSTEM_H__
+ #define __GCC_SYSTEM_H__
+ 
+ /* We must include stdarg.h/varargs.h before stdio.h. */
+ #ifdef ANSI_PROTOTYPES
+ #include <stdarg.h>
+ #else
+ #include <varargs.h>
+ #endif
+ 
+ #include <stdio.h>
+ 
+ /* Define a generic NULL if one hasn't already been defined.  */
+ #ifndef NULL
+ #define NULL 0
+ #endif
+ 
+ /* The compiler is not a multi-threaded application and therefore we
+    do not have to use the locking functions.  */
+ #ifdef HAVE_PUTC_UNLOCKED
+ # undef putc
+ # define putc(C, Stream) putc_unlocked (C, Stream)
+ #endif
+ #ifdef HAVE_FPUTC_UNLOCKED
+ # undef fputc
+ # define fputc(C, Stream) fputc_unlocked (C, Stream)
+ #endif
+ #ifdef HAVE_FPUTS_UNLOCKED
+ # undef fputs
+ # define fputs(String, Stream) fputs_unlocked (String, Stream)
+ #endif
+ 
+ #include <ctype.h>
+ 
+ /* Jim Meyering writes:
+ 
+    "... Some ctype macros are valid only for character codes that
+    isascii says are ASCII (SGI's IRIX-4.0.5 is one such system --when
+    using /bin/cc or gcc but without giving an ansi option).  So, all
+    ctype uses should be through macros like ISPRINT...  If
+    STDC_HEADERS is defined, then autoconf has verified that the ctype
+    macros don't need to be guarded with references to isascii. ...
+    Defining isascii to 1 should let any compiler worth its salt
+    eliminate the && through constant folding."
+ 
+    Bruno Haible adds:
+ 
+    "... Furthermore, isupper(c) etc. have an undefined result if c is
+    outside the range -1 <= c <= 255. One is tempted to write isupper(c)
+    with c being of type `char', but this is wrong if c is an 8-bit
+    character >= 128 which gets sign-extended to a negative value.
+    The macro ISUPPER protects against this as well."  */
+ 
+ #if defined (STDC_HEADERS) || (!defined (isascii) && !defined (HAVE_ISASCII))
+ # define IN_CTYPE_DOMAIN(c) 1
+ #else
+ # define IN_CTYPE_DOMAIN(c) isascii(c)
+ #endif
+ 
+ #ifdef isblank
+ # define ISBLANK(c) (IN_CTYPE_DOMAIN (c) && isblank (c))
+ #else
+ # define ISBLANK(c) ((c) == ' ' || (c) == '\t')
+ #endif
+ #ifdef isgraph
+ # define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isgraph (c))
+ #else
+ # define ISGRAPH(c) (IN_CTYPE_DOMAIN (c) && isprint (c) && !isspace (c))
+ #endif
+ 
+ #define ISPRINT(c) (IN_CTYPE_DOMAIN (c) && isprint (c))
+ #define ISALNUM(c) (IN_CTYPE_DOMAIN (c) && isalnum (c))
+ #define ISALPHA(c) (IN_CTYPE_DOMAIN (c) && isalpha (c))
+ #define ISCNTRL(c) (IN_CTYPE_DOMAIN (c) && iscntrl (c))
+ #define ISLOWER(c) (IN_CTYPE_DOMAIN (c) && islower (c))
+ #define ISPUNCT(c) (IN_CTYPE_DOMAIN (c) && ispunct (c))
+ #define ISSPACE(c) (IN_CTYPE_DOMAIN (c) && isspace (c))
+ #define ISUPPER(c) (IN_CTYPE_DOMAIN (c) && isupper (c))
+ #define ISXDIGIT(c) (IN_CTYPE_DOMAIN (c) && isxdigit (c))
+ #define ISDIGIT_LOCALE(c) (IN_CTYPE_DOMAIN (c) && isdigit (c))
+ 
+ /* ISDIGIT differs from ISDIGIT_LOCALE, as follows:
+    - Its arg may be any int or unsigned int; it need not be an unsigned char.
+    - It's guaranteed to evaluate its argument exactly once.
+    - It's typically faster.
+    Posix 1003.2-1992 section 2.5.2.1 page 50 lines 1556-1558 says that
+    only '0' through '9' are digits.  Prefer ISDIGIT to ISDIGIT_LOCALE unless
+    it's important to use the locale's definition of `digit' even when the
+    host does not conform to Posix.  */
+ #define ISDIGIT(c) ((unsigned) (c) - '0' <= 9)
+ 
+ 
+ #include <sys/types.h>
+ #include <errno.h>
+ 
+ #ifndef errno
+ extern int errno;
+ #endif
+ 
+ #ifdef STRING_WITH_STRINGS
+ # include <string.h>
+ # include <strings.h>
+ #else
+ # ifdef HAVE_STRING_H
+ #  include <string.h>
+ # else
+ #  ifdef HAVE_STRINGS_H
+ #   include <strings.h>
+ #  endif
+ # endif
+ #endif
+ 
+ #ifdef HAVE_STDLIB_H
+ # include <stdlib.h>
+ #endif
+ 
+ #ifdef HAVE_UNISTD_H
+ # include <unistd.h>
+ #endif
+ 
+ #ifdef HAVE_SYS_PARAM_H
+ # include <sys/param.h>
+ #endif
+ 
+ #if HAVE_LIMITS_H
+ # include <limits.h>
+ #endif
+ 
+ #ifdef TIME_WITH_SYS_TIME
+ # include <sys/time.h>
+ # include <time.h>
+ #else
+ # if HAVE_SYS_TIME_H
+ #  include <sys/time.h>
+ # else
+ #  ifdef HAVE_TIME_H
+ #   include <time.h>
+ #  endif
+ # endif
+ #endif
+ 
+ #ifdef HAVE_FCNTL_H
+ # include <fcntl.h>
+ #else
+ # ifdef HAVE_SYS_FILE_H
+ #  include <sys/file.h>
+ # endif
+ #endif
+ 
+ #ifndef SEEK_SET
+ # define SEEK_SET 0
+ # define SEEK_CUR 1
+ # define SEEK_END 2
+ #endif
+ #ifndef F_OK
+ # define F_OK 0
+ # define X_OK 1
+ # define W_OK 2
+ # define R_OK 4
+ #endif
+ #ifndef O_RDONLY
+ # define O_RDONLY 0
+ #endif
+ #ifndef O_WRONLY
+ # define O_WRONLY 1
+ #endif
+ 
+ #ifdef HAVE_SYS_WAIT_H
+ #include <sys/wait.h>
+ #endif
+ 
+ #ifndef WIFSIGNALED
+ #define WIFSIGNALED(S) (((S) & 0xff) != 0 && ((S) & 0xff) != 0x7f)
+ #endif
+ #ifndef WTERMSIG
+ #define WTERMSIG(S) ((S) & 0x7f)
+ #endif
+ #ifndef WIFEXITED
+ #define WIFEXITED(S) (((S) & 0xff) == 0)
+ #endif
+ #ifndef WEXITSTATUS
+ #define WEXITSTATUS(S) (((S) & 0xff00) >> 8)
+ #endif
+ 
+ 
+ 
+ #ifndef bcopy
+ # ifdef HAVE_BCOPY
+ #  ifdef NEED_DECLARATION_BCOPY
+ extern void bcopy ();
+ #  endif
+ # else /* ! HAVE_BCOPY */
+ #  define bcopy(src,dst,len) memcpy ((dst),(src),(len))
+ # endif
+ #endif
+ 
+ #ifndef bcmp
+ # ifdef HAVE_BCMP
+ #  ifdef NEED_DECLARATION_BCMP
+ extern int bcmp ();
+ #  endif
+ # else /* ! HAVE_BCMP */
+ #  define bcmp(left,right,len) memcmp ((left),(right),(len))
+ # endif
+ #endif
+ 
+ #ifndef bzero
+ # ifdef HAVE_BZERO
+ #  ifdef NEED_DECLARATION_BZERO
+ extern void bzero ();
+ #  endif
+ # else /* ! HAVE_BZERO */
+ #  define bzero(dst,len) memset ((dst),0,(len))
+ # endif
+ #endif
+ 
+ #ifndef index
+ # ifdef HAVE_INDEX
+ #  ifdef NEED_DECLARATION_INDEX
+ extern char *index ();
+ #  endif
+ # else /* ! HAVE_INDEX */
+ #  define index strchr
+ # endif
+ #endif
+ 
+ #ifndef rindex
+ # ifdef HAVE_RINDEX
+ #  ifdef NEED_DECLARATION_RINDEX
+ extern char *rindex ();
+ #  endif
+ # else /* ! HAVE_RINDEX */
+ #  define rindex strrchr
+ # endif
+ #endif
+ 
+ #ifdef NEED_DECLARATION_ATOF
+ extern double atof ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_ATOL
+ extern long atol();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_FREE
+ extern void free ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_GETCWD
+ extern char *getcwd ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_GETENV
+ extern char *getenv ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_GETWD
+ extern char *getwd ();
+ #endif
+ 
+ #ifdef NEED_DECLARATION_SBRK
+ extern char *sbrk ();
+ #endif
+ 
+ #ifdef HAVE_STRERROR
+ # ifdef NEED_DECLARATION_STRERROR
+ #  ifndef strerror
+ extern char *strerror ();
+ #  endif
+ # endif
+ #else /* ! HAVE_STRERROR */
+ extern int sys_nerr;
+ extern char *sys_errlist[];
+ #endif /* HAVE_STRERROR */
+ 
+ #ifdef HAVE_STRSIGNAL
+ # ifdef NEED_DECLARATION_STRSIGNAL
+ #  ifndef strsignal
+ extern char * strsignal ();
+ #  endif
+ # endif
+ #else /* ! HAVE_STRSIGNAL */
+ # ifndef SYS_SIGLIST_DECLARED
+ #  ifndef NO_SYS_SIGLIST
+ extern char * sys_siglist[];
+ #  endif
+ # endif
+ #endif /* HAVE_STRSIGNAL */
+ 
+ #ifdef HAVE_GETRLIMIT
+ # ifdef NEED_DECLARATION_GETRLIMIT
+ #  ifndef getrlimit
+ extern int getrlimit ();
+ #  endif
+ # endif
+ #endif
+ 
+ #ifdef HAVE_SETRLIMIT
+ # ifdef NEED_DECLARATION_SETRLIMIT
+ #  ifndef setrlimit
+ extern int setrlimit ();
+ #  endif
+ # endif
+ #endif
+ 
+ /* HAVE_VOLATILE only refers to the stage1 compiler.  We also check
+    __STDC__ and assume gcc sets it and has volatile in stage >=2. */
+ #if !defined(HAVE_VOLATILE) && !defined(__STDC__) && !defined(volatile)
+ #define volatile
+ #endif
+ 
+ /* Redefine abort to report an internal error w/o coredump, and reporting the
+    location of the error in the source file.  */
+ #ifndef abort
+ #ifndef __STDC__
+ #ifndef __GNUC__
+ #ifndef USE_SYSTEM_ABORT
+ #define USE_SYSTEM_ABORT
+ #endif /* !USE_SYSTEM_ABORT */
+ #endif /* !__GNUC__ */
+ #endif /* !__STDC__ */
+ 
+ #ifdef USE_SYSTEM_ABORT
+ # ifdef NEED_DECLARATION_ABORT
+ extern void abort ();
+ # endif
+ #else
+ #if __GNUC__ < 2 || (__GNUC__ == 2 && __GNUC_MINOR__ < 7)
+ #define abort()								\
+ (fprintf (stderr,							\
+ 	  "%s:%d: Internal compiler error\n", __FILE__, __LINE__),	\
+  exit (FATAL_EXIT_CODE))
+ 
+ #else
+ #define abort()								\
+ (fprintf (stderr,							\
+ 	  "%s:%d: Internal compiler error in function %s\n",		\
+ 	  __FILE__, __LINE__, __PRETTY_FUNCTION__),			\
+  exit (FATAL_EXIT_CODE))
+ 
+ #endif /* recent gcc */
+ #endif /* USE_SYSTEM_ABORT */
+ #endif /* !abort */
+ 
+ 
+ /* Define a STRINGIFY macro that's right for ANSI or traditional C.
+    HAVE_CPP_STRINGIFY only refers to the stage1 compiler.  Assume that
+    (non-traditional) gcc used in stage2 or later has this feature.
+ 
+    Note: if the argument passed to STRINGIFY is itself a macro, eg
+    #define foo bar, STRINGIFY(foo) will produce "foo", not "bar".
+    Although the __STDC__ case could be made to expand this via a layer
+    of indirection, the traditional C case can not do so.  Therefore
+    this behavior is not supported. */
+ #ifndef STRINGIFY
+ # if defined(HAVE_CPP_STRINGIFY) || (defined(__GNUC__) && defined(__STDC__))
+ #  define STRINGIFY(STRING) #STRING
+ # else
+ #  define STRINGIFY(STRING) "STRING"
+ # endif
+ #endif /* ! STRINGIFY */
+ 
+ 
+ /* These macros are here in preparation for the use of gettext in egcs.  */
+ #define _(String) String
+ #define N_(String) String
+ 
+ #if HAVE_SYS_STAT_H
+ # include <sys/stat.h>
+ #endif
+ 
+ /* Test if something is a normal file.  */
+ #ifndef S_ISREG
+ #define S_ISREG(m) (((m) & S_IFMT) == S_IFREG)
+ #endif
+ 
+ /* Test if something is a directory.  */
+ #ifndef S_ISDIR
+ #define S_ISDIR(m) (((m) & S_IFMT) == S_IFDIR)
+ #endif
+ 
+ #if !defined(GPC) || defined(EGCS)
+ /* Get libiberty declarations. */
+ #include "libiberty.h"
+ #endif
+ 
+ #endif /* __GCC_SYSTEM_H__ */
diff -rc gcc-2.8.1.orig/toplev.c gcc-2.8.1/toplev.c
*** gcc-2.8.1.orig/toplev.c	1998-02-26 03:04:46.000000000 +0100
--- gcc-2.8.1/toplev.c	2006-03-13 23:21:10.000000000 +0100
***************
*** 111,117 ****
  #endif
  
  /* If more than one debugging type is supported, you must define
!    PREFERRED_DEBUGGING_TYPE to choose a format in a system-dependent way. 
  
     This is one long line cause VAXC can't handle a \-newline.  */
  #if 1 < (defined (DBX_DEBUGGING_INFO) + defined (SDB_DEBUGGING_INFO) + defined (DWARF_DEBUGGING_INFO) + defined (DWARF2_DEBUGGING_INFO) + defined (XCOFF_DEBUGGING_INFO))
--- 111,117 ----
  #endif
  
  /* If more than one debugging type is supported, you must define
!    PREFERRED_DEBUGGING_TYPE to choose a format in a system-dependent way.
  
     This is one long line cause VAXC can't handle a \-newline.  */
  #if 1 < (defined (DBX_DEBUGGING_INFO) + defined (SDB_DEBUGGING_INFO) + defined (DWARF_DEBUGGING_INFO) + defined (DWARF2_DEBUGGING_INFO) + defined (XCOFF_DEBUGGING_INFO))
***************
*** 171,177 ****
  extern void regset_release_memory ();
  
  void rest_of_decl_compilation ();
! void error_with_file_and_line PVPROTO((char *file, int line, char *s, ...));
  void error_with_decl PVPROTO((tree decl, char *s, ...));
  void error_for_asm PVPROTO((rtx insn, char *s, ...));
  void error PVPROTO((char *s, ...));
--- 171,177 ----
  extern void regset_release_memory ();
  
  void rest_of_decl_compilation ();
! void error_with_file_and_line PVPROTO((const char *file, int line, const char *s, ...));
  void error_with_decl PVPROTO((tree decl, char *s, ...));
  void error_for_asm PVPROTO((rtx insn, char *s, ...));
  void error PVPROTO((char *s, ...));
***************
*** 585,591 ****
  int flag_schedule_insns_after_reload = 0;
  
  /* -finhibit-size-directive inhibits output of .size for ELF.
!    This is used only for compiling crtstuff.c, 
     and it may be extended to other effects
     needed for crtstuff.c on other systems.  */
  int flag_inhibit_size_directive = 0;
--- 585,591 ----
  int flag_schedule_insns_after_reload = 0;
  
  /* -finhibit-size-directive inhibits output of .size for ELF.
!    This is used only for compiling crtstuff.c,
     and it may be extended to other effects
     needed for crtstuff.c on other systems.  */
  int flag_inhibit_size_directive = 0;
***************
*** 854,860 ****
  /* Nonzero means warn about any objects definitions whose size is larger
     than N bytes.  Also want about function definitions whose returned
     values are larger than N bytes. The value N is in `larger_than_size'.  */
!  
  int warn_larger_than;
  unsigned larger_than_size;
  
--- 854,860 ----
  /* Nonzero means warn about any objects definitions whose size is larger
     than N bytes.  Also want about function definitions whose returned
     values are larger than N bytes. The value N is in `larger_than_size'.  */
! 
  int warn_larger_than;
  unsigned larger_than_size;
  
***************
*** 1151,1157 ****
  
  void
  default_print_error_function (file)
!      char *file;
  {
    if (last_error_function != current_function_decl)
      {
--- 1151,1157 ----
  
  void
  default_print_error_function (file)
!      const char *file;
  {
    if (last_error_function != current_function_decl)
      {
***************
*** 1178,1191 ****
  /* Called by report_error_function to print out function name.
   * Default may be overridden by language front-ends.  */
  
! void (*print_error_function) PROTO((char *)) = default_print_error_function;
  
  /* Prints out, if necessary, the name of the current function
    that caused an error.  Called from all error and warning functions.  */
  
  void
  report_error_function (file)
!      char *file;
  {
    struct file_stack *p;
  
--- 1178,1191 ----
  /* Called by report_error_function to print out function name.
   * Default may be overridden by language front-ends.  */
  
! void (*print_error_function) PROTO((const char *)) = default_print_error_function;
  
  /* Prints out, if necessary, the name of the current function
    that caused an error.  Called from all error and warning functions.  */
  
  void
  report_error_function (file)
!      const char *file;
  {
    struct file_stack *p;
  
***************
*** 1241,1250 ****
  
  static void
  v_message_with_file_and_line (file, line, prefix, s, ap)
!      char *file;
       int line;
       char *prefix;
!      char *s;
       va_list ap;
  {
    if (file)
--- 1241,1250 ----
  
  static void
  v_message_with_file_and_line (file, line, prefix, s, ap)
!      const char *file;
       int line;
       char *prefix;
!      const char *s;
       va_list ap;
  {
    if (file)
***************
*** 1252,1258 ****
    else
      fprintf (stderr, "%s: ", progname);
  
!   vmessage (prefix, s, ap);
    fputc ('\n', stderr);
  }
  
--- 1252,1258 ----
    else
      fprintf (stderr, "%s: ", progname);
  
!   vmessage (prefix, (char *) s, ap);
    fputc ('\n', stderr);
  }
  
***************
*** 1292,1298 ****
      {
        char fmt[sizeof "%.255s"];
        long width = p - s;
!              
        if (width > 255L) width = 255L;	/* arbitrary */
        sprintf (fmt, "%%.%lds", width);
        fprintf (stderr, fmt, s);
--- 1292,1298 ----
      {
        char fmt[sizeof "%.255s"];
        long width = p - s;
! 
        if (width > 255L) width = 255L;	/* arbitrary */
        sprintf (fmt, "%%.%lds", width);
        fprintf (stderr, fmt, s);
***************
*** 1359,1367 ****
  
  static void
  v_error_with_file_and_line (file, line, s, ap)
!      char *file;
       int line;
!      char *s;
       va_list ap;
  {
    count_error (0);
--- 1359,1367 ----
  
  static void
  v_error_with_file_and_line (file, line, s, ap)
!      const char *file;
       int line;
!      const char *s;
       va_list ap;
  {
    count_error (0);
***************
*** 1370,1390 ****
  }
  
  void
! error_with_file_and_line VPROTO((char *file, int line, char *s, ...))
  {
  #ifndef __STDC__
!   char *file;
    int line;
!   char *s;
  #endif
    va_list ap;
  
    VA_START (ap, s);
  
  #ifndef __STDC__
!   file = va_arg (ap, char *);
    line = va_arg (ap, int);
!   s = va_arg (ap, char *);
  #endif
  
    v_error_with_file_and_line (file, line, s, ap);
--- 1370,1390 ----
  }
  
  void
! error_with_file_and_line VPROTO((const char *file, int line, const char *s, ...))
  {
  #ifndef __STDC__
!   const char *file;
    int line;
!   const char *s;
  #endif
    va_list ap;
  
    VA_START (ap, s);
  
  #ifndef __STDC__
!   file = va_arg (ap, const char *);
    line = va_arg (ap, int);
!   s = va_arg (ap, const char *);
  #endif
  
    v_error_with_file_and_line (file, line, s, ap);
***************
*** 1877,1903 ****
  
  /* Same as `malloc' but report error if no memory available.  */
  
! char *
  xmalloc (size)
       unsigned size;
  {
!   register char *value = (char *) malloc (size);
    if (value == 0 && size != 0)
      fatal ("virtual memory exhausted");
    return value;
  }
  
! /* Same as `realloc' but report error if no memory available.  
     Also handle null PTR even if the vendor realloc gets it wrong.  */
  
! char *
  xrealloc (ptr, size)
!      char *ptr;
       int size;
  {
!   char *result = (ptr
! 		  ? (char *) realloc (ptr, size)
! 		  : (char *) malloc (size));
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
--- 1877,1903 ----
  
  /* Same as `malloc' but report error if no memory available.  */
  
! void *
  xmalloc (size)
       unsigned size;
  {
!   register void *value = (void *) malloc (size);
    if (value == 0 && size != 0)
      fatal ("virtual memory exhausted");
    return value;
  }
  
! /* Same as `realloc' but report error if no memory available.
     Also handle null PTR even if the vendor realloc gets it wrong.  */
  
! void *
  xrealloc (ptr, size)
!      void *ptr;
       int size;
  {
!   void *result = (ptr
! 		  ? (void *) realloc (ptr, size)
! 		  : (void *) malloc (size));
    if (!result)
      fatal ("virtual memory exhausted");
    return result;
***************
*** 2195,2202 ****
--- 2195,2211 ----
  #if USE_CPPLIB
    init_parse (name);
  #else
+ #ifdef GPC
+   {
+ 	  char * save_ifn = input_filename;
+ 	  input_filename = name;
+ 	  init_lex ();
+ 	  input_filename = save_ifn;
+   }
+ #else
    init_lex ();
  #endif
+ #endif
    /* Some of these really don't need to be called when generating bytecode,
       but the options would have to be parsed first to know that. -bson */
    init_rtl ();
***************
*** 2348,2361 ****
       When our EH mechanism is low enough overhead that we can enable
       it by default for languages other than C++, then all this braindamage
       will go away.  */
!   
    /* Perform language-specific initialization.
       This may set main_input_filename.  */
    lang_init ();
  
    if (flag_exceptions == 2)
      flag_exceptions = 0;
!      
    /* If the input doesn't start with a #line, use the input name
       as the official input file name.  */
    if (main_input_filename == 0)
--- 2357,2370 ----
       When our EH mechanism is low enough overhead that we can enable
       it by default for languages other than C++, then all this braindamage
       will go away.  */
! 
    /* Perform language-specific initialization.
       This may set main_input_filename.  */
    lang_init ();
  
    if (flag_exceptions == 2)
      flag_exceptions = 0;
! 
    /* If the input doesn't start with a #line, use the input name
       as the official input file name.  */
    if (main_input_filename == 0)
***************
*** 2431,2437 ****
  	 Therefore, I took out that change.
  	 In future versions we should find another way to solve
  	 that dbx problem.  -- rms, 23 May 93.  */
!       
        /* Don't let the first function fall at the same address
  	 as gcc_compiled., if profiling.  */
        if (profile_flag || profile_block_flag)
--- 2440,2446 ----
  	 Therefore, I took out that change.
  	 In future versions we should find another way to solve
  	 that dbx problem.  -- rms, 23 May 93.  */
! 
        /* Don't let the first function fall at the same address
  	 as gcc_compiled., if profiling.  */
        if (profile_flag || profile_block_flag)
***************
*** 2625,2631 ****
  	    && ! DECL_ARTIFICIAL (decl)
  	    && ! TREE_PUBLIC (decl))
  	  {
! 	    pedwarn_with_decl (decl, 
  			       "`%s' declared `static' but never defined");
  	    /* This symbol is effectively an "extern" declaration now.  */
  	    TREE_PUBLIC (decl) = 1;
--- 2634,2640 ----
  	    && ! DECL_ARTIFICIAL (decl)
  	    && ! TREE_PUBLIC (decl))
  	  {
! 	    pedwarn_with_decl (decl,
  			       "`%s' declared `static' but never defined");
  	    /* This symbol is effectively an "extern" declaration now.  */
  	    TREE_PUBLIC (decl) = 1;
***************
*** 2895,2901 ****
  		 /* Don't output anything
  		    when a tentative file-scope definition is seen.
  		    But at end of compilation, do output code for them.  */
! 		 if (! (! at_end && top_level
  			&& (DECL_INITIAL (decl) == 0
  			    || DECL_INITIAL (decl) == error_mark_node)))
  		   assemble_variable (decl, top_level, at_end, 0);
--- 2904,2910 ----
  		 /* Don't output anything
  		    when a tentative file-scope definition is seen.
  		    But at end of compilation, do output code for them.  */
! 	       if (! (! at_end && top_level
  			&& (DECL_INITIAL (decl) == 0
  			    || DECL_INITIAL (decl) == error_mark_node)))
  		   assemble_variable (decl, top_level, at_end, 0);
***************
*** 3835,3845 ****
--- 3844,3884 ----
    /* Initialize register usage now so switches may override.  */
    init_reg_sets ();
  
+ #ifdef GPC
+   pascal_init_options ();
+ #endif
+ 
    for (i = 1; i < argc; i++)
      {
        int j;
        /* If this is a language-specific option,
  	 decode it in a language-specific way.  */
+ #ifdef GPC
+       {
+ 	char * p = argv[i];
+ 	if (p[0] == '-')
+ 	  {
+ 	     const char * const iopts[] = { "idirafter", "imacros", "include",
+ 		 "iprefix", "isystem", "iwithprefix", "iwithprefixbefore", 0 };
+ 	     switch (p[1])
+ 	       {
+                  int j;
+ 	         case 'D':
+ 	         case 'U':
+ 	         case 'I':
+ 	             i += p[2]? 0 : 1;
+ 		     continue;
+ 		 case 'i':
+ 		      for (j = 0; iopts[j] && strcmp (iopts[j], p + 1); j++);
+                       if (iopts[j])
+ 		        {
+ 		           i++;
+ 			   continue;
+ 			}
+ 	       }
+ 	  }
+       }
+ #endif
        for (j = 0; lang_options[j] != 0; j++)
  	if (!strncmp (argv[i], lang_options[j],
  		      strlen (lang_options[j])))
***************
*** 4102,4108 ****
  #if !defined (FUNCTION_BLOCK_PROFILER_EXIT) || !defined (BLOCK_PROFILER) || !defined (FUNCTION_BLOCK_PROFILER)
  	      warning ("`-ax' option (jump profiling) not supported");
  #else
! 	      profile_block_flag = (!profile_block_flag 
  	                               || profile_block_flag == 2) ? 2 : 3;
  #endif
  	    }
--- 4141,4147 ----
  #if !defined (FUNCTION_BLOCK_PROFILER_EXIT) || !defined (BLOCK_PROFILER) || !defined (FUNCTION_BLOCK_PROFILER)
  	      warning ("`-ax' option (jump profiling) not supported");
  #else
! 	      profile_block_flag = (!profile_block_flag
  	                               || profile_block_flag == 2) ? 2 : 3;
  #endif
  	    }
***************
*** 4484,4490 ****
    pos += len;
    return pos;
  }
!      
  /* Print active target switches to FILE.
     POS is the current cursor position and MAX is the size of a "line".
     Each line begins with INDENT and ends with TERM.
--- 4523,4529 ----
    pos += len;
    return pos;
  }
! 
  /* Print active target switches to FILE.
     POS is the current cursor position and MAX is the size of a "line".
     Each line begins with INDENT and ends with TERM.
***************
*** 4585,4591 ****
    if (debug_info_level == DINFO_LEVEL_VERBOSE
        && write_symbols == DWARF2_DEBUG)
      dwarf2out_start_source_file (filename);
! #endif /* DWARF2_DEBUGGING_INFO */  
  #ifdef SDB_DEBUGGING_INFO
    if (write_symbols == SDB_DEBUG)
      sdbout_start_new_source_file (filename);
--- 4624,4630 ----
    if (debug_info_level == DINFO_LEVEL_VERBOSE
        && write_symbols == DWARF2_DEBUG)
      dwarf2out_start_source_file (filename);
! #endif /* DWARF2_DEBUGGING_INFO */
  #ifdef SDB_DEBUGGING_INFO
    if (write_symbols == SDB_DEBUG)
      sdbout_start_new_source_file (filename);
diff -rc gcc-2.8.1.orig/toplev.h gcc-2.8.1/toplev.h
*** gcc-2.8.1.orig/toplev.h	2006-03-25 00:19:03.000000000 +0100
--- gcc-2.8.1/toplev.h	2006-03-13 23:21:10.000000000 +0100
***************
*** 0 ****
--- 1,10 ----
+ extern void warning_with_decl PARAMS((tree decl, char *s, ...));
+ extern void pedwarn_with_decl PARAMS((tree decl, char *s, ...));
+ extern void pedwarn_with_file_and_line PARAMS((char *file, int line, char *s, ...));
+ extern void error_with_file_and_line PARAMS((const char *file, int line, const char *s, ...));
+ extern void announce_function PARAMS((tree));
+ extern void rest_of_compilation PARAMS((tree));
+ extern void debug_start_source_file PARAMS ((char *));
+ extern void debug_end_source_file PARAMS ((unsigned));
+ extern void debug_define PARAMS ((unsigned, char *));
+ extern void debug_undef PARAMS ((unsigned, char *));
diff -rc gcc-2.8.1.orig/tree.c gcc-2.8.1/tree.c
*** gcc-2.8.1.orig/tree.c	1998-03-03 01:37:46.000000000 +0100
--- gcc-2.8.1/tree.c	2006-03-14 03:47:27.000000000 +0100
***************
*** 645,650 ****
--- 645,667 ----
      = (char *) obstack_alloc (function_maybepermanent_obstack, 0);
  }
  
+ #ifdef GPC
+ /* When building a type copy or something similar, and the original
+    type (whose obstack is used, which is done by the caller) is
+    placed on the function_maybepermanent_obstack *before* its limit
+    (maybepermanent_firstobj), the new type must be there as well
+    because it is kept as a variant of the original type, i.e. we
+    must set the limit here. */
+ static void
+ check_type_obstack (type)
+      tree type;
+ {
+   if (TYPE_OBSTACK (type) == function_maybepermanent_obstack
+       && (char *) type < maybepermanent_firstobj)
+     preserve_data ();
+ }
+ #endif
+ 
  void
  preserve_initializer ()
  {
***************
*** 1264,1270 ****
  
  tree
  get_identifier (text)
!      register char *text;
  {
    register int hi;
    register int i;
--- 1281,1287 ----
  
  tree
  get_identifier (text)
!      register const char *text;
  {
    register int hi;
    register int i;
***************
*** 1522,1528 ****
  tree
  build_string (len, str)
       int len;
!      char *str;
  {
    /* Put the string in saveable_obstack since it will be placed in the RTL
       for an "asm" statement and will also be kept around a while if
--- 1539,1545 ----
  tree
  build_string (len, str)
       int len;
!      const char *str;
  {
    /* Put the string in saveable_obstack since it will be placed in the RTL
       for an "asm" statement and will also be kept around a while if
***************
*** 3196,3201 ****
--- 3213,3221 ----
  
        ntype = copy_node (ttype);
        current_obstack = ambient_obstack;
+ #ifdef GPC
+       check_type_obstack (ttype);
+ #endif
  
        TYPE_POINTER_TO (ntype) = 0;
        TYPE_REFERENCE_TO (ntype) = 0;
***************
*** 3495,3500 ****
--- 3515,3523 ----
    current_obstack = TYPE_OBSTACK (type);
    t = copy_node (type);
    current_obstack = ambient_obstack;
+ #ifdef GPC
+   check_type_obstack (type);
+ #endif
  
    TYPE_POINTER_TO (t) = 0;
    TYPE_REFERENCE_TO (t) = 0;
***************
*** 3950,3955 ****
--- 3973,3981 ----
    push_obstacks (TYPE_OBSTACK (to_type), TYPE_OBSTACK (to_type));
    t = make_node (POINTER_TYPE);
    pop_obstacks ();
+ #ifdef GPC
+   check_type_obstack (to_type);
+ #endif
  
    TREE_TYPE (t) = to_type;
  
***************
*** 3985,3990 ****
--- 4011,4019 ----
    push_obstacks (TYPE_OBSTACK (itype), TYPE_OBSTACK (itype));
    TYPE_MAX_VALUE (itype) = convert (sizetype, maxval);
    pop_obstacks ();
+ #ifdef GPC
+   check_type_obstack (itype);
+ #endif
  
    TYPE_MODE (itype) = TYPE_MODE (sizetype);
    TYPE_SIZE (itype) = TYPE_SIZE (sizetype);
***************
*** 4024,4034 ****
--- 4053,4070 ----
    TYPE_MIN_VALUE (itype) = convert (type, lowval);
    TYPE_MAX_VALUE (itype) = convert (type, highval);
    pop_obstacks ();
+ #ifdef GPC
+   check_type_obstack (itype);
+ #endif
  
    TYPE_PRECISION (itype) = TYPE_PRECISION (type);
    TYPE_MODE (itype) = TYPE_MODE (type);
    TYPE_SIZE (itype) = TYPE_SIZE (type);
    TYPE_ALIGN (itype) = TYPE_ALIGN (type);
+ #ifdef GPC
+   TREE_UNSIGNED (itype) = TREE_UNSIGNED (type);
+ #endif
+ 
    if ((TREE_CODE (lowval) == INTEGER_CST)
        && (TREE_CODE (highval) == INTEGER_CST))
      {
***************
*** 4169,4174 ****
--- 4205,4213 ----
    push_obstacks (TYPE_OBSTACK (to_type), TYPE_OBSTACK (to_type));
    t = make_node (REFERENCE_TYPE);
    pop_obstacks ();
+ #ifdef GPC
+   check_type_obstack (to_type);
+ #endif
  
    TREE_TYPE (t) = to_type;
  
***************
*** 4436,4442 ****
  
    if (TREE_CODE (op) == COMPONENT_REF
        /* Since type_for_size always gives an integer type.  */
!       && TREE_CODE (TREE_TYPE (op)) != REAL_TYPE)
      {
        unsigned innerprec = TREE_INT_CST_LOW (DECL_SIZE (TREE_OPERAND (op, 1)));
        tree type = type_for_size (innerprec, TREE_UNSIGNED (op));
--- 4475,4483 ----
  
    if (TREE_CODE (op) == COMPONENT_REF
        /* Since type_for_size always gives an integer type.  */
!       && TREE_CODE (TREE_TYPE (op)) != REAL_TYPE
!       /* Ensure field is laid out already.  */
!       && DECL_SIZE (TREE_OPERAND (op, 1)) != 0)
      {
        unsigned innerprec = TREE_INT_CST_LOW (DECL_SIZE (TREE_OPERAND (op, 1)));
        tree type = type_for_size (innerprec, TREE_UNSIGNED (op));
***************
*** 4739,4744 ****
--- 4780,4794 ----
    HOST_WIDE_INT domain_min
      = TREE_INT_CST_LOW (TYPE_MIN_VALUE (TYPE_DOMAIN (TREE_TYPE (init))));
    tree non_const_bits = NULL_TREE;
+ 
+ #ifdef GPC
+   /* Align the set.  */
+   if (set_alignment)
+     /* Note: `domain_min -= domain_min % set_alignment' would be wrong for negative
+        numbers (rounding towards 0, while we have to round towards -inf). */
+     domain_min &= -set_alignment;
+ #endif /* GPC */
+ 
    for (i = 0; i < bit_size; i++)
      buffer[i] = 0;
  
***************
*** 4758,4765 ****
  	  HOST_WIDE_INT hi_index
  	    = TREE_INT_CST_LOW (TREE_VALUE (vals)) - domain_min;
  	  if (lo_index < 0 || lo_index >= bit_size
! 	    || hi_index < 0 || hi_index >= bit_size)
! 	    abort ();
  	  for ( ; lo_index <= hi_index; lo_index++)
  	    buffer[lo_index] = 1;
  	}
--- 4808,4818 ----
  	  HOST_WIDE_INT hi_index
  	    = TREE_INT_CST_LOW (TREE_VALUE (vals)) - domain_min;
  	  if (lo_index < 0 || lo_index >= bit_size
! 	      || hi_index < 0 || hi_index >= bit_size)
! 	    {
! 	      error ("invalid set initializer");
! 	      return NULL_TREE;
! 	    }
  	  for ( ; lo_index <= hi_index; lo_index++)
  	    buffer[lo_index] = 1;
  	}
***************
*** 4770,4776 ****
  	    = TREE_INT_CST_LOW (TREE_VALUE (vals)) - domain_min;
  	  if (index < 0 || index >= bit_size)
  	    {
! 	      error ("invalid initializer for bit string");
  	      return NULL_TREE;
  	    }
  	  buffer[index] = 1;
--- 4823,4829 ----
  	    = TREE_INT_CST_LOW (TREE_VALUE (vals)) - domain_min;
  	  if (index < 0 || index >= bit_size)
  	    {
! 	      error ("invalid set initializer");
  	      return NULL_TREE;
  	    }
  	  buffer[index] = 1;
***************
*** 4792,4799 ****
--- 4845,4856 ----
  {
    int i;
    tree vals = TREE_OPERAND (init, 1);
+ #ifdef GPC
+   int bit_size = wd_size * BITS_PER_UNIT;
+ #else /* not GPC */
    int set_word_size = BITS_PER_UNIT;
    int bit_size = wd_size * set_word_size;
+ #endif /* not GPC */
    int bit_pos = 0;
    unsigned char *bytep = buffer;
    char *bit_buffer = (char *) alloca(bit_size);
***************
*** 4804,4809 ****
--- 4861,4884 ----
  
    for (i = 0; i < bit_size; i++)
      {
+ #ifdef GPC
+       if (bit_buffer[i])
+         {
+           int k = bit_pos / BITS_PER_UNIT;
+           if (WORDS_BIG_ENDIAN)
+             k = set_word_size / BITS_PER_UNIT - 1 - k;
+           if (set_words_big_endian)
+             bytep[k] |= (1 << (BITS_PER_UNIT - 1 - bit_pos % BITS_PER_UNIT));
+           else
+             bytep[k] |= (1 << (bit_pos % BITS_PER_UNIT));
+         }
+       bit_pos++;
+       if (bit_pos >= set_word_size)
+         {
+           bit_pos = 0;
+           bytep += set_word_size / BITS_PER_UNIT;
+         }
+ #else /* not GPC */
        if (bit_buffer[i])
  	{
  	  if (BYTES_BIG_ENDIAN)
***************
*** 4814,4819 ****
--- 4889,4895 ----
        bit_pos++;
        if (bit_pos >= set_word_size)
  	bit_pos = 0, bytep++;
+ #endif /* not GPC */
      }
    return non_const_bits;
  }
diff -rc gcc-2.8.1.orig/tree.h gcc-2.8.1/tree.h
*** gcc-2.8.1.orig/tree.h	1998-02-28 21:58:23.000000000 +0100
--- gcc-2.8.1/tree.h	2006-03-13 23:21:10.000000000 +0100
***************
*** 19,24 ****
--- 19,27 ----
  Boston, MA 02111-1307, USA.  */
  
  #include "machmode.h"
+ #ifdef GPC
+ #include <stdio.h>
+ #endif
  
  #ifndef RTX_CODE
  struct rtx_def;
***************
*** 1221,1228 ****
  extern char *xmalloc			PROTO((size_t));
  extern char *xrealloc			PROTO((void *, size_t));
  #else
! extern char *xmalloc ();
! extern char *xrealloc ();
  #endif
  
  extern char *xstrdup			PROTO((char *));
--- 1224,1231 ----
  extern char *xmalloc			PROTO((size_t));
  extern char *xrealloc			PROTO((void *, size_t));
  #else
! extern void *xmalloc ();
! extern void *xrealloc ();
  #endif
  
  extern char *xstrdup			PROTO((char *));
***************
*** 1258,1264 ****
  /* Return the (unique) IDENTIFIER_NODE node for a given name.
     The name is supplied as a char *.  */
  
! extern tree get_identifier		PROTO((char *));
  
  /* If an identifier with the name TEXT (a null-terminated string) has
     previously been referred to, return that node; otherwise return
--- 1261,1267 ----
  /* Return the (unique) IDENTIFIER_NODE node for a given name.
     The name is supplied as a char *.  */
  
! extern tree get_identifier		PROTO((const char *));
  
  /* If an identifier with the name TEXT (a null-terminated string) has
     previously been referred to, return that node; otherwise return
***************
*** 1279,1285 ****
  extern tree build_real			PROTO((tree, REAL_VALUE_TYPE));
  extern tree build_real_from_int_cst 	PROTO((tree, tree));
  extern tree build_complex		PROTO((tree, tree, tree));
! extern tree build_string		PROTO((int, char *));
  extern tree build1			PROTO((enum tree_code, tree, tree));
  extern tree build_tree_list		PROTO((tree, tree));
  extern tree build_decl_list		PROTO((tree, tree));
--- 1282,1288 ----
  extern tree build_real			PROTO((tree, REAL_VALUE_TYPE));
  extern tree build_real_from_int_cst 	PROTO((tree, tree));
  extern tree build_complex		PROTO((tree, tree, tree));
! extern tree build_string		PROTO((int, const char *));
  extern tree build1			PROTO((enum tree_code, tree, tree));
  extern tree build_tree_list		PROTO((tree, tree));
  extern tree build_decl_list		PROTO((tree, tree));
***************
*** 1409,1414 ****
--- 1412,1425 ----
  /* If non-zero, the alignment of a bitstring or (power-)set value, in bits. */
  extern int set_alignment;
  
+ #ifdef GPC
+ /* The word size of a bitstring or (power-)set value, in bits.  */
+ extern int set_word_size;
+ 
+ /* If non-zero, bits in (power-)sets start with the highest bit.  */
+ extern int set_words_big_endian;
+ #endif /* GPC */
+ 
  /* Concatenate two lists (chains of TREE_LIST nodes) X and Y
     by making the last node in X point to Y.
     Returns X, except if X is 0 returns Y.  */
***************
*** 1891,1893 ****
--- 1902,1938 ----
  
  /* Pop the obstack selection stack.  */
  extern void pop_obstacks PROTO((void));
+ 
+ #ifdef GPC
+ extern void set_identifier_size PARAMS((int));
+ extern void put_var_into_stack PARAMS((tree));
+ extern void expand_asm_operands PARAMS((tree, tree, tree, tree, int, char *, int));
+ extern void free_temp_slots PARAMS((void));
+ extern int exact_log2_wide PARAMS((register unsigned HOST_WIDE_INT));
+ extern int floor_log2_wide PARAMS((register unsigned HOST_WIDE_INT));
+ extern void print_node PARAMS((FILE *, const char *, tree, int));
+ extern void indent_to PARAMS((FILE *, int));
+ extern void push_function_context PARAMS((void));
+ extern void output_inline_function PARAMS((tree));
+ extern void pop_function_context PARAMS((void));
+ extern void remember_end_note PARAMS((register tree));
+ extern void push_obstacks PARAMS((struct obstack *, struct obstack *saveable));
+ extern int chain_member PARAMS((tree, tree));
+ extern void declare_nonlocal_label PARAMS((tree));
+ extern void resume_temporary_allocation PARAMS((void));
+ extern void fixup_signed_type PARAMS((tree));
+ extern void start_identifier_warnings PARAMS((void));
+ extern void expand_decl PARAMS((register tree));
+ extern void temporary_allocation PARAMS((void));
+ extern void preserve_initializer PARAMS((void));
+ extern void preserve_data PARAMS((void));
+ extern void init_function_start PARAMS((tree, char*, int));
+ extern void mark_varargs PARAMS((void));
+ extern void expand_function_start PARAMS((tree, int));
+ extern void expand_main_function PARAMS((void));
+ extern void setjmp_protect PARAMS((tree));
+ extern void setjmp_protect_args PARAMS((void));
+ extern void expand_function_end PARAMS((char *, int, int));
+ extern void assemble_alias PARAMS((tree, tree));
+ extern void declare_weak PARAMS((tree));
+ #endif
