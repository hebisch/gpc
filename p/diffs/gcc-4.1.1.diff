Changes for GCC version 4.1.2 for GNU Pascal

To apply these diffs, go to the directory gcc-4.1.2/gcc
and use the command

    patch -p1

feeding it the following diffs as input.


*** gcc/config/i386/i386.c	Fri Nov 17 08:01:22 2006
--- gcc/config/i386/i386.c	Fri Aug 31 17:28:39 2007
***************
*** 2738,2743 ****
--- 2738,2767 ----
  	    }
  	  break;
  
+ 	case SET_TYPE:
+           if (bytes <= 4)
+             {
+               classes[0] = X86_64_INTEGERSI_CLASS;
+               return 1;
+             }
+           else if (bytes <= 8)
+             {
+               classes[0] = X86_64_INTEGER_CLASS;
+               return 1;
+             }
+           else if (bytes <= 12)
+             {
+               classes[0] = X86_64_INTEGER_CLASS;
+               classes[1] = X86_64_INTEGERSI_CLASS;
+               return 2;
+             }
+           else
+             {
+               classes[0] = X86_64_INTEGER_CLASS;
+               classes[1] = X86_64_INTEGER_CLASS;
+               return 2;
+             }
+ 
  	default:
  	  gcc_unreachable ();
  	}
*** gcc/config/ia64/ia64.c	Thu Dec 21 14:06:37 2006
--- gcc/config/ia64/ia64.c	Fri Aug 31 17:28:39 2007
***************
*** 3842,3847 ****
--- 3842,3848 ----
      case BOOLEAN_TYPE:	case CHAR_TYPE:		case POINTER_TYPE:
      case OFFSET_TYPE:	case REFERENCE_TYPE:	case METHOD_TYPE:
      case LANG_TYPE:		case FUNCTION_TYPE:
+     case SET_TYPE:
        return VOIDmode;
  
        /* Fortran complex types are supposed to be HFAs, so we need to handle
*** gcc/config/sparc/sparc.c	Fri Apr 14 09:02:43 2006
--- gcc/config/sparc/sparc.c	Fri Aug 31 17:28:39 2007
***************
*** 7019,7024 ****
--- 7019,7025 ----
  	case VECTOR_TYPE:
  	case CHAR_TYPE:		/* GNU Pascal CHAR type.  Not used in C.  */
  	case BOOLEAN_TYPE:	/* GNU Fortran BOOLEAN type.  */
+         case SET_TYPE:          /* GNU Pascal SET type.  */
  	case LANG_TYPE:		/* ? */
  	  return qualifiers;
    
*** gcc/dbxout.c	Thu Oct  6 02:47:21 2005
--- gcc/dbxout.c	Fri Aug 31 17:28:39 2007
***************
*** 1916,1922 ****
  	{
  	  stabstr_S ("@s");
  	  stabstr_D (BITS_PER_UNIT * int_size_in_bytes (type));
! 	  stabstr_S (";-20;");
  	}
        else
  	{
--- 1916,1922 ----
  	{
  	  stabstr_S ("@s");
  	  stabstr_D (BITS_PER_UNIT * int_size_in_bytes (type));
! 	  stabstr_S (";-20");
  	}
        else
  	{
***************
*** 1933,1939 ****
  	{
  	  stabstr_S ("@s");
  	  stabstr_D (BITS_PER_UNIT * int_size_in_bytes (type));
! 	  stabstr_S (";-16;");
  	}
        else /* Define as enumeral type (False, True) */
  	stabstr_S ("eFalse:0,True:1,;");
--- 1933,1939 ----
  	{
  	  stabstr_S ("@s");
  	  stabstr_D (BITS_PER_UNIT * int_size_in_bytes (type));
! 	  stabstr_S (";-16");
  	}
        else /* Define as enumeral type (False, True) */
  	stabstr_S ("eFalse:0,True:1,;");
***************
*** 1972,1977 ****
--- 1972,1993 ----
  	}
        break;
  
+     case SET_TYPE:
+       if (use_gnu_debug_info_extensions)
+ 	{
+ 	  stabstr_S ("@s");
+           stabstr_D (BITS_PER_UNIT * int_size_in_bytes (type));
+           stabstr_C (';');
+ 
+ 	  /* Check if a bitstring type, which in Chill is
+ 	     different from a [power]set.  */
+ 	  if (TYPE_STRING_FLAG (type))
+ 	    stabstr_S ("@S;");
+ 	}
+       stabstr_C ('S');
+       dbxout_type (TYPE_DOMAIN (type), 0);
+       break;
+ 
      case ARRAY_TYPE:
        /* Make arrays of packed bits look like bitstrings for chill.  */
        if (TYPE_PACKED (type) && use_gnu_debug_info_extensions)
***************
*** 2435,2441 ****
           we see following the TREE_TYPE chain.  */
  
        t = type;
!       while (POINTER_TYPE_P (t))
          t = TREE_TYPE (t);
  
        /* RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE, and ENUMERAL_TYPE
--- 2451,2457 ----
           we see following the TREE_TYPE chain.  */
  
        t = type;
!       while (POINTER_TYPE_P (t) && !TYPE_NAME (t))
          t = TREE_TYPE (t);
  
        /* RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE, and ENUMERAL_TYPE
*** gcc/dwarf2out.c	Wed Dec 27 23:23:55 2006
--- gcc/dwarf2out.c	Fri Aug 31 17:28:39 2007
***************
*** 8230,8235 ****
--- 8230,8236 ----
      case OFFSET_TYPE:
      case LANG_TYPE:
      case VECTOR_TYPE:
+     case SET_TYPE:
        return 0;
  
      default:
***************
*** 9413,9418 ****
--- 9414,9432 ----
        }
        break;
  
+ #ifdef GPC
+     case REAL_CST:
+     case FLOAT_EXPR:
+     case RDIV_EXPR:
+     case STRING_CST:
+       /* In Pascal it's possible for array bounds to contain floating point
+          expressions (e.g., p/test/emil11c.pas). I don't know if it's
+          possible to represent them in dwarf2, but it doesn't seem terribly
+          important since this occurs quite rarely. -- Frank */
+       return 0;
+ #endif
+ 
+ 
      case FIX_TRUNC_EXPR:
      case FIX_CEIL_EXPR:
      case FIX_FLOOR_EXPR:
***************
*** 11166,11171 ****
--- 11180,11195 ----
    add_type_attribute (array_die, element_type, 0, 0, context_die);
  }
  
+ static void
+ gen_set_type_die (tree type, dw_die_ref context_die)
+ {
+   dw_die_ref type_die
+     = new_die (DW_TAG_set_type, scope_die_for (type, context_die), type);
+ 
+   equate_type_number_to_die (type, type_die);
+   add_type_attribute (type_die, TREE_TYPE (type), 0, 0, context_die);
+ }
+ 
  #if 0
  static void
  gen_entry_point_die (tree decl, dw_die_ref context_die)
***************
*** 12523,12528 ****
--- 12547,12557 ----
        gen_ptr_to_mbr_type_die (type, context_die);
        break;
  
+     case SET_TYPE:
+       gen_type_die (TYPE_DOMAIN (type), context_die);
+       gen_set_type_die (type, context_die);
+       break;
+ 
      case FUNCTION_TYPE:
        /* Force out return type (in case it wasn't forced out already).  */
        gen_type_die (TREE_TYPE (type), context_die);
*** gcc/expr.c	Thu Nov  2 18:18:52 2006
--- gcc/expr.c	Fri Aug 31 17:28:39 2007
***************
*** 4639,4644 ****
--- 4639,4648 ----
      case REFERENCE_TYPE:
        return 1;
  
+     case SET_TYPE:
+       /* @@@@@@ return something more accurate ... */
+       return -1;
+ 
      case VOID_TYPE:
      case METHOD_TYPE:
      case FUNCTION_TYPE:
***************
*** 5592,5600 ****
  	       index, then convert to sizetype and multiply by the size of
  	       the array element.  */
  	    if (! integer_zerop (low_bound))
  	      index = fold_build2 (MINUS_EXPR, TREE_TYPE (index),
  				   index, low_bound);
! 
  	    offset = size_binop (PLUS_EXPR, offset,
  			         size_binop (MULT_EXPR,
  					     convert (sizetype, index),
--- 5596,5614 ----
  	       index, then convert to sizetype and multiply by the size of
  	       the array element.  */
  	    if (! integer_zerop (low_bound))
+ #ifdef GPC
+             /* I think that address arithmetic should always be done on
+                sizetype or its variants -- for Pascal signed seems to be the
+                correct choice (and generates slightly better code). -- Waldek */
+               index = convert (sizetype, convert (bitsizetype,
+                       size_binop (MINUS_EXPR,
+                         convert (sbitsizetype, index),
+                         convert (sbitsizetype, low_bound))));
+ #else
+ 
  	      index = fold_build2 (MINUS_EXPR, TREE_TYPE (index),
  				   index, low_bound);
! #endif
  	    offset = size_binop (PLUS_EXPR, offset,
  			         size_binop (MULT_EXPR,
  					     convert (sizetype, index),
***************
*** 8642,8648 ****
  tree
  string_constant (tree arg, tree *ptr_offset)
  {
!   tree array, offset;
    STRIP_NOPS (arg);
  
    if (TREE_CODE (arg) == ADDR_EXPR)
--- 8656,8662 ----
  tree
  string_constant (tree arg, tree *ptr_offset)
  {
!   tree array, offset, lb = size_zero_node;
    STRIP_NOPS (arg);
  
    if (TREE_CODE (arg) == ADDR_EXPR)
***************
*** 8656,8661 ****
--- 8670,8676 ----
  	{
  	  array = TREE_OPERAND (arg, 0);
  	  offset = size_zero_node;
+           goto do_lb;
  	}
        else if (TREE_CODE (TREE_OPERAND (arg, 0)) == ARRAY_REF)
  	{
***************
*** 8664,8669 ****
--- 8679,8685 ----
  	  if (TREE_CODE (array) != STRING_CST
  	      && TREE_CODE (array) != VAR_DECL)
  	    return 0;
+           lb = array_ref_low_bound (TREE_OPERAND (arg, 0));
  	}
        else
  	return 0;
***************
*** 8692,8701 ****
--- 8708,8733 ----
  	}
        else
  	return 0;
+   do_lb:    
+       if (TREE_TYPE (array) && TREE_CODE (TREE_TYPE (array)) == ARRAY_TYPE)
+         {
+           tree domain_type = TYPE_DOMAIN (TREE_TYPE (array));
+           if (domain_type && TYPE_MIN_VALUE (domain_type))
+ #if 0
+             lb = SUBSTITUTE_PLACEHOLDER_IN_EXPR (
+                    TYPE_MIN_VALUE (domain_type), array);
+ #else
+           lb = TYPE_MIN_VALUE (domain_type);
+ #endif
+         }
      }
    else
      return 0;
  
+   if (! integer_zerop (lb))
+     offset = size_diffop (fold_convert (sizetype, offset),
+                           fold_convert (sizetype, lb));
+ 
    if (TREE_CODE (array) == STRING_CST)
      {
        *ptr_offset = convert (sizetype, offset);
*** gcc/fold-const.c	Wed Jan  3 09:15:24 2007
--- gcc/fold-const.c	Fri Aug 31 17:28:39 2007
***************
*** 5960,5965 ****
--- 5960,5969 ----
    bool unsigned_p = TYPE_UNSIGNED (TREE_TYPE (arg0));
    int overflow;
  
+   /* Overflow check does not work for unsigned numbers */
+   if (TYPE_UNSIGNED (TREE_TYPE (arg0)))
+     return NULL_TREE;
+ 
    /* We have to do this the hard way to detect unsigned overflow.
       prod = int_const_binop (MULT_EXPR, arg01, arg1, 0);  */
    overflow = mul_double_with_sign (TREE_INT_CST_LOW (arg01),
*** gcc/function.c	Tue Nov 28 13:01:45 2006
--- gcc/function.c	Fri Aug 31 17:28:39 2007
***************
*** 3118,3124 ****
--- 3118,3128 ----
    if (TYPE_P (t))
      {
        if (POINTER_TYPE_P (t))
+ #ifndef GPC
  	*walk_subtrees = 1;
+ #else
+         *walk_subtrees = 0;
+ #endif
        else if (TYPE_SIZE (t) && !TREE_CONSTANT (TYPE_SIZE (t))
  	       && !TYPE_SIZES_GIMPLIFIED (t))
  	{
*** gcc/gcc.c	Tue Nov  7 15:26:21 2006
--- gcc/gcc.c	Fri Aug 31 17:28:39 2007
***************
*** 794,801 ****
  "%{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\
   %1 %{!Q:-quiet} -dumpbase %B %{d*} %{m*} %{a*}\
   %{c|S:%{o*:-auxbase-strip %*}%{!o*:-auxbase %b}}%{!c:%{!S:-auxbase %b}}\
!  %{g*} %{O*} %{W*&pedantic*} %{w} %{std*&ansi&trigraphs}\
!  %{v:-version} %{pg:-p} %{p} %{f*} %{undef}\
   %{Qn:-fno-ident} %{--help:--help}\
   %{--target-help:--target-help}\
   %{!fsyntax-only:%{S:%W{o*}%{!o*:-o %b.s}}}\
--- 794,801 ----
  "%{pg:%{fomit-frame-pointer:%e-pg and -fomit-frame-pointer are incompatible}}\
   %1 %{!Q:-quiet} -dumpbase %B %{d*} %{m*} %{a*}\
   %{c|S:%{o*:-auxbase-strip %*}%{!o*:-auxbase %b}}%{!c:%{!S:-auxbase %b}}\
!  %{g*} %{O*} %{f*&W*&pedantic*&w} %{std*&ansi&trigraphs}\
!  %{v:-version} %{pg:-p} %{p} %{undef}\
   %{Qn:-fno-ident} %{--help:--help}\
   %{--target-help:--target-help}\
   %{!fsyntax-only:%{S:%W{o*}%{!o*:-o %b.s}}}\
*** gcc/gimplify.c	Sun Nov 19 17:15:47 2006
--- gcc/gimplify.c	Fri Aug 31 17:28:39 2007
***************
*** 2749,2754 ****
--- 2749,2758 ----
    if (TREE_CODE (ctor) != CONSTRUCTOR)
      return GS_UNHANDLED;
  
+   ret = lang_hooks.gimplify_expr (&TREE_OPERAND (*expr_p, 1), pre_p, post_p);
+   if (ret != GS_UNHANDLED)
+     return ret;
+   
    ret = gimplify_expr (&TREE_OPERAND (*expr_p, 0), pre_p, post_p,
  		       is_gimple_lvalue, fb_lvalue);
    if (ret == GS_ERROR)
***************
*** 4760,4765 ****
--- 4764,4771 ----
  
      case POINTER_TYPE:
      case REFERENCE_TYPE:
+       break;
+ 
        gimplify_type_sizes (TREE_TYPE (type), list_p);
        break;
  
*** gcc/ipa-type-escape.c	Sun Sep 25 07:28:01 2005
--- gcc/ipa-type-escape.c	Fri Aug 31 17:28:40 2007
***************
*** 260,268 ****
  type_to_consider (tree type)
  {
    /* Strip the *'s off.  */
    type = TYPE_MAIN_VARIANT (type);
    while (POINTER_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE)
!     type = TYPE_MAIN_VARIANT (TREE_TYPE (type));
  
    switch (TREE_CODE (type))
      {
--- 260,282 ----
  type_to_consider (tree type)
  {
    /* Strip the *'s off.  */
+   tree otype = type;
+   long cnt = 0;
+   long ocnt = 0;
    type = TYPE_MAIN_VARIANT (type);
    while (POINTER_TYPE_P (type) || TREE_CODE (type) == ARRAY_TYPE)
!     {
!       type = TYPE_MAIN_VARIANT (TREE_TYPE (type));
!       if (type == otype)
!         return false;
!       if (cnt > ocnt)
!         {
!           ocnt += cnt;
!           otype = type;
!         }
!       else
!         cnt ++;
!     }
  
    switch (TREE_CODE (type))
      {
*** gcc/print-tree.c	Thu Oct 13 01:34:09 2005
--- gcc/print-tree.c	Fri Aug 31 17:28:40 2007
***************
*** 580,586 ****
  
        if (TREE_CODE (node) == ENUMERAL_TYPE)
  	print_node (file, "values", TYPE_VALUES (node), indent + 4);
!       else if (TREE_CODE (node) == ARRAY_TYPE)
  	print_node (file, "domain", TYPE_DOMAIN (node), indent + 4);
        else if (TREE_CODE (node) == VECTOR_TYPE)
  	fprintf (file, " nunits %d", (int) TYPE_VECTOR_SUBPARTS (node));
--- 580,586 ----
  
        if (TREE_CODE (node) == ENUMERAL_TYPE)
  	print_node (file, "values", TYPE_VALUES (node), indent + 4);
!       else if (TREE_CODE (node) == ARRAY_TYPE || TREE_CODE (node) == SET_TYPE)
  	print_node (file, "domain", TYPE_DOMAIN (node), indent + 4);
        else if (TREE_CODE (node) == VECTOR_TYPE)
  	fprintf (file, " nunits %d", (int) TYPE_VECTOR_SUBPARTS (node));
*** gcc/stor-layout.c	Wed Oct  4 09:01:27 2006
--- gcc/stor-layout.c	Fri Aug 31 17:28:40 2007
***************
*** 19,24 ****
--- 19,25 ----
  Software Foundation, 51 Franklin Street, Fifth Floor, Boston, MA
  02110-1301, USA.  */
  
+ /* @@ PATCHED FOR GPC 20070903 @@ */
  
  #include "config.h"
  #include "system.h"
***************
*** 53,58 ****
--- 54,74 ----
     called only by a front end.  */
  static int reference_types_internal = 0;
  
+ /* If nonzero, the alignment of a bitstring or (power-)set value, in bits.
+    May be overridden by front-ends.  */
+ unsigned int set_alignment = 0;
+ 
+ /* The word size of a bitstring or (power-)set value, in bits.
+    Must be non-zero.
+    May be overridden by front-ends.  */
+ unsigned int set_word_size = BITS_PER_UNIT;
+ 
+ /* If non-zero, bits in (power-)sets start with the highest bit.
+    May be overridden by front-ends.
+    In order to be backward-compatible, the Chill frontend should
+    initialize this to BYTES_BIG_ENDIAN.  */
+ unsigned int set_words_big_endian = 0;
+ 
  static void finalize_record_size (record_layout_info);
  static void finalize_type_size (tree);
  static void place_union_field (record_layout_info, tree);
***************
*** 1899,1904 ****
--- 1915,1964 ----
        }
        break;
  
+     case SET_TYPE:  /* Used by Chill and Pascal.  */
+       if (TREE_CODE (TYPE_MAX_VALUE (TYPE_DOMAIN (type))) != INTEGER_CST
+           || TREE_CODE (TYPE_MIN_VALUE (TYPE_DOMAIN (type))) != INTEGER_CST)
+         abort ();
+       else
+         {
+           int alignment = set_alignment ? set_alignment : set_word_size;
+           tree lower_bound = convert (sbitsizetype,
+                         TYPE_MIN_VALUE (TYPE_DOMAIN (type)));
+           tree upper_bound = convert (sbitsizetype,
+                         TYPE_MAX_VALUE (TYPE_DOMAIN (type)));
+           tree size_in_bits, rounded_size;
+           if (set_alignment)
+             {
+               lower_bound = round_down (lower_bound, alignment);
+             }
+           size_in_bits = size_binop (PLUS_EXPR,
+                                 size_binop (MINUS_EXPR,
+                                         upper_bound,
+                                         lower_bound),
+                                 sbitsize_int(1));
+           rounded_size = round_up (size_in_bits, alignment);
+ 
+           if ( TREE_INT_CST_HIGH (rounded_size)
+                 || TREE_INT_CST_LOW (rounded_size) > (unsigned) alignment)
+             {
+                 TYPE_MODE (type) = BLKmode;
+             }
+           else
+             {
+                 TYPE_MODE (type) = mode_for_size (alignment, MODE_INT, 1);
+             }
+ 
+           TYPE_SIZE (type) = convert (bitsizetype, rounded_size);
+           TYPE_SIZE_UNIT (type) = convert (sizetype,
+                                 size_binop ( CEIL_DIV_EXPR,
+                                         rounded_size,
+                                         sbitsize_int (BITS_PER_UNIT)));
+           TYPE_ALIGN (type) = alignment;
+           TYPE_USER_ALIGN (type) = 0;
+           TYPE_PRECISION (type) = TREE_INT_CST_LOW (size_in_bits);
+         }
+       break;
+ 
      default:
        gcc_unreachable ();
      }
*** gcc/toplev.c	Thu Aug  3 13:33:49 2006
--- gcc/toplev.c	Fri Aug 31 17:28:40 2007
***************
*** 1110,1115 ****
--- 1110,1136 ----
  void
  print_version (FILE *file, const char *indent)
  {
+ #ifdef GPC
+   extern const char *lang_version_string;
+   static const char fmt1[] =
+ #ifdef __GNUC__
+     N_("%s%s%s version %s%s (%s)\n%s\tcompiled by GNU C version %s.\n")
+ #else
+     N_("%s%s%s version %s%s (%s) compiled by CC.\n")
+ #endif
+     ;
+   static const char fmt2[] =
+     N_("%s%sGGC heuristics: --param ggc-min-expand=%d --param ggc-min-heapsize=%d\n");
+ #ifndef __VERSION__
+ #define __VERSION__ "[?]"
+ #endif
+ 
+   fprintf (file,
+            file == stderr ? _(fmt1) : fmt1,
+            indent, *indent != 0 ? " " : "",
+            lang_hooks.name, lang_version_string, version_string, TARGET_NAME,
+            indent, __VERSION__);
+ #else
    static const char fmt1[] =
  #ifdef __GNUC__
      N_("%s%s%s version %s (%s)\n%s\tcompiled by GNU C version %s.\n")
***************
*** 1122,1132 ****
--- 1143,1155 ----
  #ifndef __VERSION__
  #define __VERSION__ "[?]"
  #endif
+ 
    fprintf (file,
  	   file == stderr ? _(fmt1) : fmt1,
  	   indent, *indent != 0 ? " " : "",
  	   lang_hooks.name, version_string, TARGET_NAME,
  	   indent, __VERSION__);
+ #endif
    fprintf (file,
  	   file == stderr ? _(fmt2) : fmt2,
  	   indent, *indent != 0 ? " " : "",
*** gcc/tree-flow-inline.h	Tue Apr 18 15:24:45 2006
--- gcc/tree-flow-inline.h	Fri Aug 31 17:28:40 2007
***************
*** 1470,1476 ****
      return false;
  
    return (AGGREGATE_TYPE_P (TREE_TYPE (v)) &&
! 	  TREE_CODE (TREE_TYPE (v)) != ARRAY_TYPE);
  }
  
    
--- 1470,1477 ----
      return false;
  
    return (AGGREGATE_TYPE_P (TREE_TYPE (v)) &&
! 	  TREE_CODE (TREE_TYPE (v)) != ARRAY_TYPE
!           && TREE_CODE (TREE_TYPE (v)) != SET_TYPE);
  }
  
    
*** gcc/tree-nested.c	Thu Jul 20 17:43:44 2006
--- gcc/tree-nested.c	Fri Aug 31 17:28:40 2007
***************
*** 1173,1178 ****
--- 1173,1180 ----
    if (!elt)
      return NULL_TREE;
    new_label = elt->new;
+   DECL_CONTEXT (new_label) = DECL_CONTEXT (label);
+ //  mark_decl_referenced (new_label);
  
    /* If there's any possibility that the previous statement falls through,
       then we must branch around the new non-local label.  */
*** gcc/tree-sra.c	Mon Nov 21 01:55:57 2005
--- gcc/tree-sra.c	Fri Aug 31 17:28:40 2007
***************
*** 1368,1373 ****
--- 1368,1376 ----
  	      && (!can_completely_scalarize_p (elt)
  		  || !type_can_instantiate_all_elements (elt->type)))
  	    use_block_copy = true;
+           if (TREE_TYPE (elt->type)
+               && full_size != full_count*TYPE_PRECISION (TREE_TYPE (elt->type)))
+             use_block_copy = true;
  	}
        elt->use_block_copy = use_block_copy;
  
*** gcc/tree-ssa-dom.c	Fri Nov 17 10:01:31 2006
--- gcc/tree-ssa-dom.c	Fri Aug 31 17:28:40 2007
***************
*** 2804,2815 ****
        val_type = TREE_TYPE (val);
  
        /* While both types are pointers, get the type of the object
! 	 pointed to.  */
!       while (POINTER_TYPE_P (op_type) && POINTER_TYPE_P (val_type))
! 	{
! 	  op_type = TREE_TYPE (op_type);
! 	  val_type = TREE_TYPE (val_type);
! 	}
  
        /* Make sure underlying types match before propagating a constant by
  	 converting the constant to the proper type.  Note that convert may
--- 2804,2829 ----
        val_type = TREE_TYPE (val);
  
        /* While both types are pointers, get the type of the object
! 	 pointed to. Do not get trapped in cycles.  */
!       {
!         long cnt = 0, maxcnt = 11;
!         tree op_type0 = op_type;
!         while (POINTER_TYPE_P (op_type) && POINTER_TYPE_P (val_type))
! 	  {
! 	    op_type = TREE_TYPE (op_type);
! 	    val_type = TREE_TYPE (val_type);
!             if (op_type == op_type0)
!               return false;
!             cnt ++;
!             if (cnt > maxcnt)
!               {
!                 op_type0 = op_type;
!                 maxcnt += maxcnt;
!                 if (maxcnt < 0)
!                   return false;
!               }
! 	  }
!       }
  
        /* Make sure underlying types match before propagating a constant by
  	 converting the constant to the proper type.  Note that convert may
*** gcc/tree.c	Fri Jan  5 21:59:15 2007
--- gcc/tree.c	Fri Aug 31 17:28:40 2007
***************
*** 2131,2136 ****
--- 2131,2137 ----
  	      || CONTAINS_PLACEHOLDER_P (TYPE_MAX_VALUE (type)));
  
      case ARRAY_TYPE:
+     case SET_TYPE:
        /* We're already checked the component type (TREE_TYPE), so just check
  	 the index type.  */
        return type_contains_placeholder_p (TYPE_DOMAIN (type));
***************
*** 3142,3148 ****
    if (EXPR_LOCUS (node)
        && EXPR_LINENO (node) == line
        && (EXPR_FILENAME (node) == file
! 	  || !strcmp (EXPR_FILENAME (node), file)))
      {
        last_annotated_node = EXPR_LOCUS (node);
        return;
--- 3143,3150 ----
    if (EXPR_LOCUS (node)
        && EXPR_LINENO (node) == line
        && (EXPR_FILENAME (node) == file
!          || (EXPR_FILENAME (node) &&  file
!                 && ! strcmp (EXPR_FILENAME (node), file))))
      {
        last_annotated_node = EXPR_LOCUS (node);
        return;
***************
*** 3154,3160 ****
    if (last_annotated_node
        && last_annotated_node->line == line
        && (last_annotated_node->file == file
! 	  || !strcmp (last_annotated_node->file, file)))
      {
        SET_EXPR_LOCUS (node, last_annotated_node);
        return;
--- 3156,3163 ----
    if (last_annotated_node
        && last_annotated_node->line == line
        && (last_annotated_node->file == file
!          || (last_annotated_node->file &&  file
!                 && ! strcmp (last_annotated_node->file, file))))
      {
        SET_EXPR_LOCUS (node, last_annotated_node);
        return;
***************
*** 5007,5012 ****
--- 5010,5016 ----
    TYPE_SIZE_UNIT (itype) = TYPE_SIZE_UNIT (type);
    TYPE_ALIGN (itype) = TYPE_ALIGN (type);
    TYPE_USER_ALIGN (itype) = TYPE_USER_ALIGN (type);
+   TYPE_UNSIGNED (itype) = TYPE_UNSIGNED (type);
  
    if (host_integerp (lowval, 0) && highval != 0 && host_integerp (highval, 0))
      return type_hash_canon (tree_low_cst (highval, 0)
*** gcc/tree.def	Fri Feb 10 18:32:10 2006
--- gcc/tree.def	Fri Aug 31 17:28:40 2007
***************
*** 254,259 ****
--- 254,265 ----
     includes the hidden argument for "self".  */
  DEFTREECODE (METHOD_TYPE, "method_type", tcc_type, 0)
  
+ /* Types of sets for Pascal.  Special fields are the same as
+    in an array type.  The target type is always a boolean type.
+    Used for both bitstrings and powersets in Chill;
+    TYPE_STRING_FLAG indicates a bitstring.  */
+ DEFTREECODE (SET_TYPE, "set_type", tcc_type, 0)
+ 
  /* This is a language-specific kind of type.
     Its meaning is defined by the language front end.
     layout_type does not know how to lay this out,
*** gcc/tree.h	Fri Feb  9 03:52:53 2007
--- gcc/tree.h	Fri Aug 31 17:28:40 2007
***************
*** 704,709 ****
--- 704,712 ----
  #define NOT_RECORD_OR_UNION_CHECK(T) \
    TREE_NOT_CHECK3 (T, RECORD_TYPE, UNION_TYPE, QUAL_UNION_TYPE)
  
+ #define ARRAY_OR_SET_CHECK(T)            \
+   TREE_CHECK2 (T, ARRAY_TYPE, SET_TYPE)
+ 
  #define NUMERICAL_TYPE_CHECK(T)					\
    TREE_CHECK5 (T, INTEGER_TYPE, ENUMERAL_TYPE, BOOLEAN_TYPE,	\
  	       CHAR_TYPE, REAL_TYPE)
***************
*** 817,823 ****
  
  #define AGGREGATE_TYPE_P(TYPE) \
    (TREE_CODE (TYPE) == ARRAY_TYPE || TREE_CODE (TYPE) == RECORD_TYPE \
!    || TREE_CODE (TYPE) == UNION_TYPE || TREE_CODE (TYPE) == QUAL_UNION_TYPE)
  
  /* Nonzero if TYPE represents a pointer or reference type.
     (It should be renamed to INDIRECT_TYPE_P.)  Keep these checks in
--- 820,827 ----
  
  #define AGGREGATE_TYPE_P(TYPE) \
    (TREE_CODE (TYPE) == ARRAY_TYPE || TREE_CODE (TYPE) == RECORD_TYPE \
!    || TREE_CODE (TYPE) == UNION_TYPE || TREE_CODE (TYPE) == QUAL_UNION_TYPE \
!    || TREE_CODE (TYPE) == SET_TYPE)
  
  /* Nonzero if TYPE represents a pointer or reference type.
     (It should be renamed to INDIRECT_TYPE_P.)  Keep these checks in
***************
*** 1618,1624 ****
  #define TYPE_SIZE_UNIT(NODE) (TYPE_CHECK (NODE)->type.size_unit)
  #define TYPE_MODE(NODE) (TYPE_CHECK (NODE)->type.mode)
  #define TYPE_VALUES(NODE) (ENUMERAL_TYPE_CHECK (NODE)->type.values)
! #define TYPE_DOMAIN(NODE) (ARRAY_TYPE_CHECK (NODE)->type.values)
  #define TYPE_FIELDS(NODE) (RECORD_OR_UNION_CHECK (NODE)->type.values)
  #define TYPE_CACHED_VALUES(NODE) (TYPE_CHECK(NODE)->type.values)
  #define TYPE_ORIG_SIZE_TYPE(NODE)			\
--- 1622,1628 ----
  #define TYPE_SIZE_UNIT(NODE) (TYPE_CHECK (NODE)->type.size_unit)
  #define TYPE_MODE(NODE) (TYPE_CHECK (NODE)->type.mode)
  #define TYPE_VALUES(NODE) (ENUMERAL_TYPE_CHECK (NODE)->type.values)
! #define TYPE_DOMAIN(NODE) (ARRAY_OR_SET_CHECK (NODE)->type.values)
  #define TYPE_FIELDS(NODE) (RECORD_OR_UNION_CHECK (NODE)->type.values)
  #define TYPE_CACHED_VALUES(NODE) (TYPE_CHECK(NODE)->type.values)
  #define TYPE_ORIG_SIZE_TYPE(NODE)			\
***************
*** 3555,3560 ****
--- 3559,3573 ----
  /* and its original value in bytes, specified via -fpack-struct=<value>.  */
  extern unsigned int initial_max_fld_align;
  
+ /* If nonzero, the alignment of a bitstring or (power-)set value, in bits.  */
+ extern unsigned int set_alignment;
+ 
+ /* The word size of a bitstring or (power-)set value, in bits.  */
+ extern unsigned int set_word_size;
+ 
+ /* If non-zero, bits in (power-)sets start with the highest bit.  */
+ extern unsigned int set_words_big_endian;
+ 
  /* Concatenate two lists (chains of TREE_LIST nodes) X and Y
     by making the last node in X point to Y.
     Returns X, except if X is 0 returns Y.  */
*** gcc/varasm.c	Mon Oct 16 11:58:48 2006
--- gcc/varasm.c	Fri Aug 31 17:28:40 2007
***************
*** 2708,2714 ****
  	VEC(constructor_elt, gc) *v;
  	unsigned HOST_WIDE_INT idx;
  	tree purpose, value;
! 	
  	v = VEC_alloc(constructor_elt, gc, VEC_length(constructor_elt,
  						      CONSTRUCTOR_ELTS (exp)));
  	FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (exp), idx, purpose, value)
--- 2708,2714 ----
  	VEC(constructor_elt, gc) *v;
  	unsigned HOST_WIDE_INT idx;
  	tree purpose, value;
! 
  	v = VEC_alloc(constructor_elt, gc, VEC_length(constructor_elt,
  						      CONSTRUCTOR_ELTS (exp)));
  	FOR_EACH_CONSTRUCTOR_ELT (CONSTRUCTOR_ELTS (exp), idx, purpose, value)
***************
*** 3748,3754 ****
  	/* Allow conversions to struct or union types if the value
  	   inside is okay.  */
  	if (TREE_CODE (dest_type) == RECORD_TYPE
! 	    || TREE_CODE (dest_type) == UNION_TYPE)
  	  return initializer_constant_valid_p (src, endtype);
        }
        break;
--- 3748,3759 ----
  	/* Allow conversions to struct or union types if the value
  	   inside is okay.  */
  	if (TREE_CODE (dest_type) == RECORD_TYPE
! 	    || TREE_CODE (dest_type) == UNION_TYPE
! #ifdef GPC
!             || TREE_CODE (TREE_TYPE (value)) == ARRAY_TYPE
! #endif
!            )
! 
  	  return initializer_constant_valid_p (src, endtype);
        }
        break;
*** gcc/version.c	Wed Mar 16 07:04:10 2005
--- gcc/version.c	Fri Aug 31 17:28:40 2007
***************
*** 17,23 ****
     forward us bugs reported to you, if you determine that they are
     not bugs in your modifications.)  */
  
! const char bug_report_url[] = "<URL:http://gcc.gnu.org/bugs.html>";
  
  /* The complete version string, assembled from several pieces.
     BASEVER, DATESTAMP, and DEVPHASE are defined by the Makefile.  */
--- 17,23 ----
     forward us bugs reported to you, if you determine that they are
     not bugs in your modifications.)  */
  
! const char bug_report_url[] = "<URL:http://www.gnu-pascal.de/todo.html>";
  
  /* The complete version string, assembled from several pieces.
     BASEVER, DATESTAMP, and DEVPHASE are defined by the Makefile.  */
