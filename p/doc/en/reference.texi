@c Copyright (C) 1997-2006 Free Software Foundation, Inc.
@c For copying conditions, see the file gpc.texi.
@c This file is part of the GPC Manual.
@c
@c Authors: Dominik Freche <dominik.freche@mailbox.tu-dresden.de>
@c          Peter Gerwinski <peter@gerwinski.de>
@c          Frank Heckenbach <frank@pascal.gnu.de>
@c          Peter N Lewis <peter@stairways.com.au>
@c
@c Last modification: 2006-01-30 (file under construction)

@node Reference
@chapter The Alphabetical GPC Language Reference

@strong{This chapter is still under development. All keywords and
built-in identifiers are listed, but not all with explanations.}

This chapter contains an alphabetical list of all keywords (reserved
words) and built-in identifiers of the GNU Pascal compiler. For
detailed and comprehensive description of syntax and reserved words,
see @ref{Programming}. This chapter explains only built-in
procedures and functions in detail.

It does not cover extensions provided by external units and
libraries which are supposed to come with their own documentation.
For the interfaces of the units that come with GPC, see
@ref{GPC Units}.

@c This table indeed lists all keywords and identifiers currently
@c recognized *and supported* by GPC.
@c
@c Most of the entries point to skeletons. Once we have documented all
@c of the below, we have a more-or-less complete documentation for GPC.

@menu
* Abs::
* absolute::
* abstract::
* Addr::
* AlignOf::
* all::
* and::
* and then::
* and_then::
* AnsiChar::
* AnyFile::
* Append::
* ArcCos::
* ArcSin::
* ArcTan::
* Arg::
* array::
* as::
* asm::
* asmname::
* Assert::
* Assign::
* Assigned::
* attribute::
* begin::
* Bind::
* bindable::
* Binding::
* BindingType::
* BitSizeOf::
* BlockRead::
* BlockWrite::
* Boolean::
* Break::
* Byte::
* ByteBool::
* ByteCard::
* ByteInt::
* c::
* Card::
* Cardinal::
* case::
* CBoolean::
* CCardinal::
* Char::
* ChDir::
* Chr::
* CInteger::
* c_language::
* class::
* Close::
* Cmplx::
* Comp::
* CompilerAssert::
* Complex::
* Concat::
* Conjugate::
* const::
* constructor::
* Continue::
* Copy::
* Cos::
* CString::
* CString2String::
* CStringCopyString::
* CurrentRoutineName::
* CWord::
* Cycle::
* Date::
* Dec::
* DefineSize::
* Delete::
* destructor::
* Discard::
* Dispose::
* div::
* do::
* Double::
* downto::
* else::
* Empty::
* end::
* EOF::
* EOLn::
* EpsReal::
* EQ::
* EQPad::
* Erase::
* except::
* Exclude::
* Exit::
* Exp::
* export::
* exports::
* Extend::
* Extended::
* external::
* Fail::
* False::
* far::
* file::
* FilePos::
* FileSize::
* FillChar::
* finalization::
* Finalize::
* finally::
* Flush::
* for::
* FormatString::
* forward::
* Frac::
* FrameAddress::
* FreeMem::
* function::
* GE::
* GEPad::
* Get::
* GetMem::
* GetTimeStamp::
* goto::
* GT::
* GTPad::
* Halt::
* High::
* if::
* Im::
* implementation::
* import::
* in::
* Inc::
* Include::
* Index::
* inherited::
* initialization::
* Initialize::
* InOutRes::
* Input::
* Insert::
* Int::
* Integer::
* interface::
* interrupt::
* IOResult::
* is::
* label::
* LastPosition::
* LE::
* Leave::
* Length::
* LEPad::
* library::
* Ln::
* LoCase::
* LongBool::
* LongCard::
* LongestBool::
* LongestCard::
* LongestInt::
* LongestReal::
* LongestWord::
* LongInt::
* LongReal::
* LongWord::
* Low::
* LT::
* LTPad::
* Mark::
* Max::
* MaxChar::
* MaxInt::
* MaxReal::
* MedBool::
* MedCard::
* MedInt::
* MedReal::
* MedWord::
* Min::
* MinReal::
* MkDir::
* mod::
* module::
* Move::
* MoveLeft::
* MoveRight::
* name::
* NE::
* near::
* NEPad::
* New::
* NewCString::
* nil::
* not::
* Null::
* object::
* Odd::
* of::
* on::
* only::
* operator::
* or::
* Ord::
* or else::
* or_else::
* otherwise::
* Output::
* overload::
* override::
* Pack::
* packed::
* Page::
* PAnsiChar::
* ParamCount::
* ParamStr::
* PChar::
* Pi::
* PObjectType::
* Pointer::
* Polar::
* Pos::
* Position::
* pow::
* Pred::
* private::
* procedure::
* program::
* property::
* protected::
* PtrCard::
* PtrDiffType::
* PtrInt::
* PtrWord::
* public::
* published::
* Put::
* qualified::
* raise::
* Random::
* Randomize::
* Re::
* Read::
* ReadLn::
* ReadStr::
* ReadString::
* Real::
* record::
* Release::
* Rename::
* repeat::
* Reset::
* resident::
* restricted::
* Result::
* Return::
* ReturnAddress::
* Rewrite::
* RmDir::
* Round::
* RunError::
* Seek::
* SeekEOF::
* SeekEOLn::
* SeekRead::
* SeekUpdate::
* SeekWrite::
* segment::
* Self::
* set::
* SetFileTime::
* SetLength::
* SetType::
* shl::
* ShortBool::
* ShortCard::
* ShortInt::
* ShortReal::
* ShortWord::
* shr::
* Sin::
* Single::
* SizeOf::
* SizeType::
* SmallInt::
* Sqr::
* SqRt::
* StandardError::
* StandardInput::
* StandardOutput::
* StdErr::
* Str::
* String::
* String2CString::
* StringOf::
* SubStr::
* Succ::
* Text::
* then::
* Time::
* TimeStamp::
* to::
* to begin do::
* to end do::
* Trim::
* True::
* Trunc::
* Truncate::
* try::
* type::
* type of::
* TypeOf::
* Unbind::
* unit::
* Unpack::
* until::
* UpCase::
* Update::
* uses::
* Val::
* value::
* var::
* view::
* virtual::
* Void::
* while::
* with::
* Word::
* WordBool::
* Write::
* WriteLn::
* WriteStr::
* xor::
@end menu


@c ============================================================================


@node Abs
@unnumberedsec Abs
@cindex Abs

@subheading Synopsis

@smallexample
function Abs (i: @var{integer_type}): @var{integer_type};
@end smallexample
or
@smallexample
function Abs (x: @var{real_type}): @var{real_type};
@end smallexample
or
@smallexample
function Abs (z: @var{complex_type}): @var{real_type};
@end smallexample

@subheading Description

Returns the absolute value of the argument. For integer or real
values of @samp{x}, the definition is

@smallexample
function Abs (x: @var{integer_or_real_type}): @var{integer_or_real_type};
begin
  if x < 0 then
    Abs := -x
  else
    Abs := x
end;
@end smallexample

@noindent whereas for complex values it is

@smallexample
function Abs (x: Complex): Real;
begin
  Abs := SqRt (x * Conjugate (x))
end;
@end smallexample

@subheading Conforming to

The function @samp{Abs} is defined in ISO 7185 Pascal; its
application to complex values is defined in ISO 10206 Extended
Pascal.

@subheading Example

@smallexample
program AbsDemo;
var
  i1: Complex;
begin
  WriteLn (Abs (42));             @{ 42 @}
  WriteLn (Abs (-42));            @{ 42 @}
  WriteLn (Abs (-12.1) : 0 : 1);  @{ 12.1 @}
  i1 := Cmplx (1, 1);             @{ 1 + i @}
  WriteLn (Abs (i1) : 0 : 3)      @{ 1.414, i.e. SqRt (2) @}
end.
@end smallexample

@subheading See also

@ref{Sqr}.


@c ----------------------------------------------------------------------------


@node absolute
@unnumberedsec absolute
@cindex absolute

@subheading Synopsis

@smallexample
var
  @var{variable_name}: @var{data_type} absolute @var{variable_reference};
@end smallexample
or
@smallexample
var
  @var{variable_name}: @var{data_type} absolute @var{integer_expression};
@end smallexample

@subheading Description

The first meaning of the @samp{absolute} directive allows to put a
variable to the address of another one and thus provides a
type-casting mechanism.

In most cases, @var{variable_reference} will be just a variable
name, but GPC also allows arbitrary pointer expressions here. If
@var{variable_reference} has neither a constant address nor is a
variable parameter, GPC prints a warning. This warning is suppressed
in ``extended syntax'' mode which is switched on by the
@samp{--extended-syntax} option or the @samp{@{$X+@}} compiler
directive.

GPC also allows explicit type casts. Variant records (as defined in
ISO 7185 Pascal), however, have no @emph{guaranteed} overlaying and
are therefore @emph{not} suitable for type casts.

The second meaning of @samp{absolute} places a variable at a
specified address. This is useful on machines without virtual memory
addressing for doing certain low-level operations, but should be
avoided on systems with memory protection such as Unix-like systems.
GPC does not check whether the specified virtual address makes any
sense and does not provide a built-in mechanism to map it to a real
address.

GPC warns about this second use of @samp{absolute} unless ``extended
syntax'' has been requested.

@subheading Conforming to

@samp{absolute} is a Borland Pascal extension.

Borland Pascal has a slightly different syntax for the second
meaning related to the addressing scheme of IA32 processors working
in real mode.

Allowing arbitrary memory references instead of just variable names
in the first meaning of @samp{absolute} is a GNU Pascal extension.

@subheading Example

@smallexample
program AbsoluteDemo;

@{$X+@}

const
  IOMem = $f0000000;
  MaxVarSize = MaxInt div 8;

var
  Mem: array [0 .. MaxVarSize - 1] of Byte absolute 0;

  @{ This address has no actual meaning @}
  MyPort: Byte absolute IOMem + $c030;

@{ Beware: Using any of the variables above will crash
  your program unless you know exactly what you do!
  That's why GPC warns about it without the $X+ directive. @}

var
  x: Real;
  a: array [1 .. SizeOf (Real)] of Byte absolute x;
  i: Integer;
  b: Byte absolute a[i];  @{ GNU Pascal extension:
                             non-constant memory reference. @}

begin
  x := 3.14;

  @{ Look at the internal representation of a real variable. @}
  for i := 1 to SizeOf (Real) do
    Write (a[i] : 4);
  WriteLn;

  @{ The same again, more ugly ... @}
  for i := 1 to SizeOf (Real) do
    Write (b : 4);
  WriteLn;

  @{ And yes, there's an even more ugly way to do it ... @}
  for i := 1 to SizeOf (Real) do
    Write (Mem[PtrCard (@@x) + i - 1] : 4);
  WriteLn
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{record}, @ref{Type Casts}.


@c ----------------------------------------------------------------------------


@node abstract
@unnumberedsec abstract
@cindex abstract

Not yet implemented.

@subheading Synopsis

@subheading Description

Abstract object type or method declaration.

@subheading Conforming to

@samp{abstract} is an Object Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node Addr
@unnumberedsec Addr
@cindex Addr

@subheading Synopsis

@smallexample
function Addr (const Foo): Pointer;
@end smallexample

@subheading Description

@samp{Addr} returns the address of its argument. It is equivalent to
the address operator.

Note: In BP, @samp{Addr} returns an untyped pointer. GPC does this
only with @samp{--borland-pascal}. Otherwise it returns a typed
pointer. @samp{Addr} never depends on the
@samp{--[no]-typed-address} option/compiler directive, unlike the
address operator. (It is recommended you never rely on untyped
pointer results, but use a type-cast if really necessary.)

@subheading Conforming to

@samp{Addr} is a Borland Pascal extension.

@subheading Example

@smallexample
program AddrDemo;
var
  Foo: ^Integer;
  Bar: Integer;
begin
  Foo := Addr (Bar);  @{ Let `Foo' point to `Bar'. @}
  Bar := 17;
  Foo^ := 42;  @{ Change the value of `Bar' to 42 @}
  WriteLn (Bar)
end.
@end smallexample

@subheading See also

@ref{Operators}.


@c ----------------------------------------------------------------------------


@node AlignOf
@unnumberedsec AlignOf
@cindex AlignOf
@cindex alignment

@subheading Synopsis

@smallexample
function AlignOf (var x): Integer;
@end smallexample

@subheading Description

Returns the alignment of a type or variable in bytes.

@subheading Conforming to

@samp{AlignOf} is a GNU Pascal extension.

@subheading Example

@smallexample
program AlignOfDemo;
var
  a: Integer;
  b: array [1 .. 8] of Char;
begin
  WriteLn (AlignOf (a));  @{ Alignment of `Integer', e.g. 4 bytes. @}
  WriteLn (AlignOf (Integer));  @{ The same. @}
  WriteLn (AlignOf (b));  @{ Alignment of `Char'; usually 1 byte. @}
end.
@end smallexample

Although the array is bigger than a single char, it is accessed char by
char, so there usually is no need to align it on a 4 byte boundary or
such. (This may be false on some platforms.)

@subheading See also

@ref{SizeOf}, @ref{BitSizeOf}, @ref{TypeOf}.


@c ----------------------------------------------------------------------------


@node all
@unnumberedsec all
@cindex all

(Under construction.)

@subheading Synopsis

@subheading Description

@samp{export} extension (@samp{export foo = all}).

@subheading Conforming to

@samp{all} is a GNU Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node and
@unnumberedsec and
@cindex and

@subheading Synopsis

@smallexample
operator and (operand1, operand2: Boolean) = Result: Boolean;
@end smallexample
or
@smallexample
operator and (operand1, operand2: @var{integer_type}) = Result: @var{integer_type};
@end smallexample
or
@smallexample
procedure and (var operand1: @var{integer_type}; operand2: @var{integer_type});
@end smallexample

@subheading Description

In GNU Pascal, @samp{and} has three built-in meanings:

@enumerate

@item
Logical ``and'' between two @samp{Boolean}-type expressions.
The result of the operation is of @samp{Boolean} type.

By default, @samp{and} acts as a short-circuit operator in GPC: If
the first operand is @samp{False}, the second operand is not
evaluated because the result is already known to be @samp{False}.
You can change this to complete evaluation using the
@samp{--no-short-circuit} command-line option or the @samp{@{$B+@}}
compiler directive.

@item
Bitwise ``and'' between two integer-type expressions.
The result is of the common integer type of both expressions.

@item
Use as a ``procedure'': @samp{operand1} is ``and''ed bitwise with
@samp{operand2}; the result is stored in @samp{operand1}.

@end enumerate

@subheading Conforming to

The logical @samp{and} operator is defined in ISO 7185 Pascal.

According to ISO, you cannot rely on @samp{and} being a
short-circuit operator. On the other hand, GPC's default behaviour
does @emph{not} contradict the ISO standard. (See @ref{and_then}.)
However, since it seems to be a de-facto standard among ISO Pascal
compilers to evaluate both operands of @samp{and}, GPC switches to
@samp{--no-short-circuit} mode if one of the language dialect
options selecting ISO Pascal, for instance @samp{--extended-pascal},
is given. Use @samp{--short-circuit} to override.

Use of @samp{and} as a bitwise operator for integers is a Borland
Pascal extension.

Use of @samp{and} as a ``procedure'' is a GNU Pascal extension.

@subheading Example

@smallexample
program AndDemo;
var
  a, b, c: Integer;
begin
  if (a = 0) and (b = 0) then  @{ logical `and' @}
    c := 1
  else if (a and b) = 0 then  @{ bitwise `and' @}
    c := 2
  else
    and (c, a)  @{ same as `c := c and a' @}
end.
@end smallexample

Note the difference between the logical @samp{and} and the bitwise
@samp{and}: When @samp{a} is 2 and @samp{b} is 4, then @samp{a and b} is 0.
@strong{Beware:} @samp{a and b = 0} has nothing to do with
@samp{(a = 0) and (b = 0)}!

Since bitwise @samp{and} has a higher priority than the @samp{=} operator,
parentheses are needed in @samp{if (a = 0) and (b = 0)} because otherwise
@samp{0 and b} would be calculated first, and the remainder would cause a
parse error.

@subheading See also

@ref{Keywords}, @ref{and_then}, @ref{and then}, @ref{or}, @ref{xor},
@ref{Operators}.


@c ----------------------------------------------------------------------------


@node and then
@unnumberedsec and then
@cindex and then

@subheading Synopsis

@smallexample
@{ `and then' is built in. A user-defined operator cannot consist of
   two words. @}
operator and then (operand1, operand2: Boolean) = Result: Boolean;
@end smallexample

@subheading Description

@samp{and then} is an alias for the short-circuit logical operator
@samp{and_then}.

@subheading Conforming to

While @samp{and_then} is defined in ISO 10206 Extended Pascal,
@samp{and then} is a GNU Pascal extension.

@subheading Example

@smallexample
program AndThenDemo;
var
  p: ^Integer;
begin
  New (p);
  ReadLn (p^);
  if (p <> nil) and then (p^ < 42) then  @{ This is safe. @}
    WriteLn (p^, ' is less than 42')
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{and_then}, @ref{and}, @ref{or else}.


@c ----------------------------------------------------------------------------


@node and_then
@unnumberedsec and_then
@cindex and_then

@subheading Synopsis

@smallexample
operator and_then (operand1, operand2: Boolean) = Result: Boolean;
@end smallexample

@subheading Description

The @samp{and_then} short-circuit logical operator performs the same
operation as the logical operator @samp{and}. But while the ISO
standard does not specify anything about the evaluation of the
operands of @samp{and} -- they may be evaluated in any order, or not
at all -- @samp{and_then} has a well-defined behaviour: It evaluates
the first operand. If the result is @samp{False}, @samp{and_then}
returns @samp{False} without evaluating the second operand. If it is
@samp{True}, the second operand is evaluated and returned.

Since the behaviour described above is the most efficient way to
implement @samp{and}, GPC by default treats @samp{and} and
@samp{and_then} exactly the same. If you want, for some reason, to
have both operands of @samp{and} evaluated completely, you must
assign both to temporary variables and then use @samp{and} -- or
@samp{and_then}, it does not matter.

@subheading Conforming to

@samp{and_then} is an ISO 10206 Extended Pascal extension.

Some people think that the ISO standard requires both operands of
@samp{and} to be evaluated. This is false. What the ISO standard
@emph{does} say is that you cannot rely on a certain order of
evaluation of the operands of @samp{and}; in particular things like
the following program can crash according to ISO Pascal, although
they cannot crash when compiled with GNU Pascal running in default
mode.

@smallexample
program AndBug;
var
  p: ^Integer;
begin
  New (p);
  ReadLn (p^);
  if (p <> nil) and (p^ < 42) then  @{ This is NOT safe! @}
    WriteLn ('You''re lucky. But the test could have crashed ...')
end.
@end smallexample

@subheading Example

@smallexample
program And_ThenDemo;
var
  p: ^Integer;
begin
  New (p);
  ReadLn (p^);
  if (p <> nil) and_then (p^ < 42) then  @{ This is safe. @}
    WriteLn (p^, ' is less than 42')
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{and then}, @ref{and}, @ref{or_else}.


@c ----------------------------------------------------------------------------


@node AnsiChar
@unnumberedsec AnsiChar
@cindex AnsiChar

@subheading Synopsis

@smallexample
type
  AnsiChar = Char;
@end smallexample

@subheading Description

@samp{AnsiChar} is an 8 bit char type. Currently, it is the same as
@samp{Char}, but this might change in the future, once @samp{wide
chars} (16 bit chars) will be introduced into GPC. Depending on the
platform, @samp{Char} might be either @samp{AnsiChar} or
@samp{WideChar} then.

@subheading Conforming to

@samp{AnsiChar} is a Borland Delphi extension.

@subheading Example

@smallexample
program AnsiCharDemo;
var
  A: AnsiChar;  @{ There is nothing special with `AnsiChar'. @}
  B: Char;
begin
  A := 'A';
  A := B
end.
@end smallexample

@subheading See also

@ref{PAnsiChar}, @ref{Char}.


@c ----------------------------------------------------------------------------


@node AnyFile
@unnumberedsec AnyFile
@cindex AnyFile

@subheading Synopsis

@smallexample
type
  AnyFile  @{ built-in type @}
@end smallexample

@subheading Description

@samp{AnyFile} is a built-in type that can only be used for
parameters and pointer targets. Any kind of file variable
(@samp{Text}, untyped and typed @samp{file}) can be passed to such a
parameter and their address assigned to such a pointer. On the other
side, only generic file operations are possible with @samp{AnyFile}
parameters/pointer targets.

This type is useful for implementing generic file handling routines.
Also some built-in file routines use this type for their parameters,
e.g. @samp{IOSelectRead} (@pxref{Run Time System}).

@samp{BlockRead} (@pxref{BlockRead}) and @samp{BlockWrite}
(@pxref{BlockWrite}) treat @samp{AnyFile} specially, in that they
accept all @samp{AnyFile}s as arguments (even if the actual file is
a typed or @samp{Text} file) and always use a block size of 1 (even
if the actual file is an untyped file with different block size or a
typed file of a type with size not equal to one). This is the only
way to reliably read/write a certain amount of data from/to an
@samp{AnyFile}.

@samp{AnyFile} pointers cannot be allocated with @samp{New} (because
it would be unspecified which kind of file to create).

@subheading Conforming to

@samp{AnyFile} is a GNU Pascal extension.

@subheading Example

@smallexample
program AnyFileDemo;

procedure Test (var f: AnyFile);
var v: ^AnyFile;
begin
  @{ Generic file operations are allowed for `AnyFile' @}
  Rewrite (f);

  @{ `AnyFile' can also be accessed via pointers @}
  v := @@f;
  Close (v^)
end;

var
  t: Text;
  f: file;
  g: file of Integer;

begin
  @{ Any kind of file variable can be passed as `AnyFile' @}
  Test (t);
  Test (f);
  Test (g)
end.
@end smallexample

@subheading See also

@ref{Text}, @ref{file}.


@c ----------------------------------------------------------------------------


@node Append
@unnumberedsec Append
@cindex Append

@subheading Synopsis

@smallexample
procedure Append (var F: @var{any_file}; [FileName: String;]
                                    [BlockSize: Cardinal]);
@end smallexample

@subheading Description

@samp{Append} opens a file for writing. If the file does not
exist, it is created. If it does exist, the file pointer is
positioned after the last element.

Like @samp{Rewrite}, @samp{Reset} and @samp{Extend} do,
@samp{Reset} accepts an optional second parameter for the name of
the file in the filesystem and a third parameter for the block size
of the file. The third parameter is allowed only (and by default
also required) for untyped files. For details, see @ref{Rewrite}.

@subheading Conforming to

@samp{Append}, including the @samp{BlockSize} parameter, is a
Borland Pascal extension. ISO 10206 Extended Pascal has @ref{Extend}
instead.
The @samp{FileName} parameter is a GNU Pascal extension.
@c @@@@ Other compilers?

@subheading Example

@smallexample
program AppendDemo;
var
  Sample: Text;
begin
  Assign (Sample, 'sample.txt');
  Rewrite (Sample);
  WriteLn (Sample, 'Hello, World!');  @{ `sample.txt' now has one line @}
  Close (Sample);

  @{ ... @}

  Append (Sample);
  WriteLn (Sample, 'Hello again!');  @{ `sample.txt' now has two lines @}
  Close (Sample)
end.
@end smallexample

@subheading See also

@ref{Assign}, @ref{Reset}, @ref{Rewrite}, @ref{Update},
@ref{Extend}.


@c ----------------------------------------------------------------------------


@node ArcCos
@unnumberedsec ArcCos
@cindex ArcCos

@subheading Synopsis

@smallexample
function ArcCos (x: Real): Real;
@end smallexample
or
@smallexample
function ArcCos (z: Complex): Complex;
@end smallexample

@subheading Description

@samp{ArcCos} returns the (principal value of the) arcus cosine of
the argument. The result is in the range @samp{0 < ArcCos (x) < Pi}
for real arguments.

@subheading Conforming to

@samp{ArcCos} is a GNU Pascal extension.

@subheading Example

@smallexample
program ArcCosDemo;
begin
  @{ yields 3.14159 as ArcCos (0.5) = Pi / 3 @}
  WriteLn (3 * ArcCos (0.5) : 0 : 5)
end.
@end smallexample

@subheading See also

@ref{ArcSin}, @ref{ArcTan}, @ref{Sin}, @ref{Cos}, @ref{Ln}, @ref{Arg}.


@c ----------------------------------------------------------------------------


@node ArcSin
@unnumberedsec ArcSin
@cindex ArcSin

@subheading Synopsis

@smallexample
function ArcSin (x: Real): Real;
@end smallexample
or
@smallexample
function ArcSin (z: Complex): Complex;
@end smallexample

@subheading Description

@samp{ArcSin} returns the (principal value of the) arcus sine of the
argument. The result is in the range
@samp{-Pi / 2 < ArcSin (x) < Pi / 2} for real arguments.

@subheading Conforming to

@samp{ArcSin} is a GNU Pascal extension.

@subheading Example

@smallexample
program ArcSinDemo;
begin
  @{ yields 3.14159 as ArcSin (0.5) = Pi / 6 @}
  WriteLn (6 * ArcSin (0.5) : 0 : 5)
end.
@end smallexample

@subheading See also

@ref{ArcCos}, @ref{ArcTan}, @ref{Sin}, @ref{Cos}, @ref{Ln}, @ref{Arg}.


@c ----------------------------------------------------------------------------


@node ArcTan
@unnumberedsec ArcTan
@cindex ArcTan

@subheading Synopsis

@smallexample
function ArcTan (x: Real): Real;
@end smallexample
or
@smallexample
function ArcTan (z: Complex): Complex;
@end smallexample

@subheading Description

@samp{ArcTan} returns the (principal value of the) arcus tangent of the
argument. The result is in the range @samp{-Pi / 2 < ArcTan (x) < Pi / 2}
for real arguments.

@subheading Conforming to

@samp{ArcTan} is defined in ISO 7185 Pascal; its application to
complex values is defined in ISO 10206 Extended Pascal.

@subheading Example

@smallexample
program ArcTanDemo;
begin
  @{ yields 3.14159 as ArcTan (1) = Pi / 4 @}
  WriteLn (4 * ArcTan (1) : 0 : 5)
end.
@end smallexample

@subheading See also

@ref{ArcSin}, @ref{ArcCos}, @ref{Sin}, @ref{Cos}, @ref{Ln}, @ref{Arg}.


@c ----------------------------------------------------------------------------


@node Arg
@unnumberedsec Arg
@cindex Arg

@subheading Synopsis

@smallexample
function Arg (z: Complex): Real;
@end smallexample

@subheading Description

@samp{Arg} returns the complex ``argument'', i.e.@: the angle
(in radian) in the complex plane with respect to the real axis,
of its parameter @samp{z}. The result is in the range of
@samp{-Pi < Arg (z) <= Pi}.

@subheading Conforming to

@samp{Arg} is an ISO 10206 Extended Pascal extension.

@subheading Example

@smallexample
program ArgDemo;
var
  z: Complex;
begin
  z := Cmplx (1, 1);  @{ 1 + i @}
  WriteLn (Arg (z) : 0 : 5)  @{ yields 0.78540, i.e. Pi / 4 @}
end.
@end smallexample

@subheading See also

@ref{ArcTan}, @ref{Ln}, @ref{Polar}.


@c ----------------------------------------------------------------------------


@node array
@unnumberedsec array
@cindex array

@subheading Synopsis

In type definitions:
@smallexample
array [@var{index_type}] of @var{element_type}
@end smallexample
or
@smallexample
array [@var{index_type}, @dots{}, @var{index_type}] of @var{element_type}
@end smallexample

In parameter list declarations:
@smallexample
array of @var{element_type}
@end smallexample

@subheading Description

The reserved word @samp{array} is used to define an array type.

@@@@conformant/open arrays

@subheading Conforming to

Array types are defined in ISO 7185 Pascal.

@subheading Example

@smallexample
program ArrayDemo;
type
  IntArray = array [1 .. 20] of Integer;
  WeekDayChars = array [(Mon, Tue, Wed, Thu, Fri, Sat, Sun)] of Char;
  Foo = array [0 .. 9, 'a' .. 'z', (Baz, Glork1, Fred)] of Real;
  TwoDimIntArray = array [1 .. 10] of IntArray;
  @{ is equivalent to: @}
  TwoDimIntArray2 = array [1 .. 10, 1 .. 20] of Integer;

procedure PrintChars (F: array of Char);
var
  i: Integer;
begin
  for i := Low (F) to High (F) do
    WriteLn (F[i])
end;

var
  Waldo: WeekDayChars;

begin
  Waldo := 'HiWorld';
  PrintChars (Waldo)
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{Array Types}, @ref{High}, @ref{Low}


@c ----------------------------------------------------------------------------


@node as
@unnumberedsec as
@cindex as

(Under construction.)

@subheading Synopsis

@subheading Description

Object type membership test and conversion.

@subheading Conforming to

@samp{as} is an Object Pascal and a Borland Delphi extension.

@subheading Example

@subheading See also

@ref{Keywords}, @ref{is}, @ref{TypeOf}, @ref{OOP}.


@c ----------------------------------------------------------------------------


@node asm
@unnumberedsec asm
@cindex asm

(Under construction.)

@subheading Synopsis

@subheading Description

See @samp{http://www.gnu-pascal.de/contrib/misc/gpcasm.zip}.

@subheading Conforming to

@samp{asm}, as implemented in GPC, is a GNU Pascal extension. It is
mostly compatible to GCC's @samp{asm}, but not compatible to that of
Borland Pascal.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node asmname
@unnumberedsec asmname
@cindex asmname

@subheading Synopsis

@subheading Description

@strong{Deprecated}! Use @samp{external name} now.

@subheading Conforming to

@subheading Example

@subheading See also

@ref{Keywords}, @ref{external}, @ref{name},
@ref{Importing Libraries from Other Languages}.


@c ----------------------------------------------------------------------------


@node Assert
@unnumberedsec Assert
@cindex Assert

@subheading Synopsis

@smallexample
procedure Assert (Condition: Boolean);
@end smallexample
or
@smallexample
procedure Assert (Condition: Boolean; const Message: String);
@end smallexample

@subheading Description

@samp{Assert} checks the given @samp{Condition} at run-time. If it
is true, it does nothing. If it is false, it raises a runtime error,
using the second argument for the message if given.

However, if the switch @samp{--no-assertions} is given
(@pxref{GPC Command Line Options}), @samp{Assert} is deactivated. It
still evaluates the condition if it has side effects, but never
raises a runtime error.

@subheading Conforming to

@samp{Assert} is a Borland Delphi extension.

@subheading Example

@subheading See also

@ref{CompilerAssert}.


@c ----------------------------------------------------------------------------


@node Assign
@unnumberedsec Assign
@cindex Assign

(Under contruction.)

@subheading Synopsis

@smallexample
procedure Assign (var F: @var{any_file}; FileName: String);
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Assign} is a Borland Pascal extension.

@subheading Example

@subheading See also

@ref{Reset}, @ref{Rewrite}, @ref{Update}, @ref{Extend}, @ref{Append}.


@c ----------------------------------------------------------------------------


@node Assigned
@unnumberedsec Assigned
@cindex Assigned

(Under construction.)

@subheading Synopsis

@smallexample
function Assigned (p: Pointer): Boolean;
@end smallexample
or
@smallexample
function Assigned (p: @var{procedural_type}): Boolean;
@end smallexample

@subheading Description

The @samp{Assigned} function returns @samp{True} if the
pointer parameter or the address of the procedural parameter
is not @samp{nil}; it returns @samp{False} if it is @samp{nil}.

@subheading Conforming to

@samp{Assigned} is a Borland Pascal extension.

@subheading Example

@smallexample
program AssignedDemo;
type
  PInt = ^Integer;

procedure TellIfOdd (p: PInt);
begin
  if Assigned (p) and then Odd (p^) then
    WriteLn ('The pointer p points to an odd value.')
end;

var
  foo: Integer;
begin
  TellIfOdd (nil);
  foo := 1;
  TellIfOdd (@@foo);
  foo := 2;
  TellIfOdd (@@foo)
end.
@end smallexample

@subheading See also

@ref{Null}, @ref{nil}, @ref{Pointer}.


@c ----------------------------------------------------------------------------


@node attribute
@unnumberedsec attribute
@cindex attribute

(Under construction.)

@subheading Synopsis

@smallexample
@var{declaration} attribute (@var{name});
@end smallexample

or

@smallexample
@var{declaration} attribute (@var{name} = @var{parameter});
@end smallexample

or

@smallexample
@var{declaration} attribute (@var{name} (@var{parameter}, @var{parameter} @dots{}));
@end smallexample

@subheading Description

Several attributes can be given in one @samp{attribute} directive,
separated with @samp{,}, or in several @samp{attribute} directives.

Besides the attributes that GCC supports (@pxref{Attribute
Syntax,,,gcc,the GCC manual}), GPC allows the following attributes
for variables:

@itemize @bullet
@item static
@item register
@item volatile
@item const
@item external
@item name (with a string constant parameter)
@end itemize

For routines it allows the following additional attributes:

@itemize @bullet
@item ignorable
@item inline
@item iocritical
@item name (with a string constant parameter)
@item noinline
@end itemize

For types it allows the following additional attributes:

@itemize @bullet
@item iocritical (for procedural [pointer] types)
@item size (with an integer constant parameter)
@end itemize

@samp{Size} can be applied to integer and Boolean types to produce
types with a specified size in bits; for example

@smallexample
type
  Card16 = Cardinal attribute (Size = 16);
@end smallexample

@noindent defines an unsigned integer type with 16 bits.

Variable and routine attributes are preceded by a @samp{;}, type
attributes are not. So, e.g., in the following example, the
@samp{Size} attribute applies to the type, and the @samp{static}
attribute to the variable.
@smallexample
var a: Integer attribute (Size = 64); attribute (static);
@end smallexample

@subheading Conforming to

@samp{attribute} is a GNU Pascal extension.

@subheading Example

@smallexample
program AttributeDemo;

@{ Demo for `iocritical' attribute. @}

@{ Program will abort with a runtime error! @}

@{$I-@}
procedure p; attribute (iocritical);
var t: Text;
begin
  Reset (t)  @{ Will not cause a runtime error here because I/O
               checking is off, but leave InOutRes set. @}
end;
@{$I+@}

begin

  p;
  @{ Since `p' was declared `iocritical', and I/O checking is now on,
    InOutRes is checked immediately after the call to p, and a
    runtime error raised. @}

  @{ So this statement is never reached. @}
  InOutRes := 0;

  @{ Neither this one, which would be reached without the
    `iocritical' attribute. @}
  WriteLn ('never gets here')

end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{external}.


@c ----------------------------------------------------------------------------


@node begin
@unnumberedsec begin
@cindex begin

@subheading Synopsis

@smallexample
begin
  @var{statement};
  @var{statement};
  @dots{}
  @var{statement}
end;
@end smallexample

@subheading Description

The reserved word @samp{begin} opens a @samp{begin @dots{} end}
statement which joins several @var{statements} to one compound
statement.

@subheading Conforming to

@samp{begin} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@smallexample
program BeginDemo;
begin
  if True then
    WriteLn ('single statement');
  if True then
    begin                     @{ clamp statement1 ... @}
      WriteLn ('statement1');
      WriteLn ('statement2')
    end                       @{ ... to statement2 @}
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{begin end Compound Statement}, @ref{end}


@c ----------------------------------------------------------------------------


@node Bind
@unnumberedsec Bind
@cindex Bind

(Under construction.)

@subheading Synopsis

@smallexample
procedure Bind (var F: @var{any_file}; B: BindingType);
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Bind} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also

@ref{Unbind}, @ref{Binding}, @ref{BindingType}, @ref{bindable}.


@c ----------------------------------------------------------------------------


@node bindable
@unnumberedsec bindable
@cindex bindable

(Under construction.)

@subheading Synopsis

@subheading Description

External bindability of files.

@subheading Conforming to

@samp{bindable} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}, @ref{Bind}, @ref{Unbind}, @ref{Binding}, @ref{BindingType}.

@c ----------------------------------------------------------------------------


@node Binding
@unnumberedsec Binding
@cindex Binding

(Under construction.)

@subheading Synopsis

@smallexample
function Binding (F: @var{any_file}): BindingType;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Binding} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also

@ref{Bind}, @ref{Unbind}, @ref{BindingType}, @ref{bindable}.


@c ----------------------------------------------------------------------------


@node BindingType
@unnumberedsec BindingType
@cindex BindingType

(Under construction.)

@subheading Synopsis

@smallexample
type
  UnixTimeType = LongInt;
  BindingType = packed record
    Bound,
    Force,                     @{ Can be set to allow binding to
                                 directories or inaccessible files @}
    Extensions_Valid,
    Readable,
    Writable,
    Executable,
    Existing,                  @{ Binding points to an existing file @}
    Directory,                 @{ Binding points to an existing
                                 directory; @samp{Existing} is False
                                 in this case @}
    Special,                   @{ Binding points to an existing
                                 special file (device, pipe, socket,
                                 etc.); @samp{Existing} is False in
                                 this case @}
    SymLink: Boolean;          @{ Binding points to a symbolic link @}
    Size: FileSizeType;        @{ Size of file, or -1 if unknown @}
    AccessTime,                @{ Time of last access @}
    ModificationTime,          @{ Time of last modification @}
    ChangeTime: UnixTimeType;  @{ Time of last change @}
    User,                      @{ User ID of owner @}
    Group,                     @{ Group ID of owner @}
    Mode,                      @{ Access permissions, cf. ChMod @}
    Device,                    @{ Device the file is on @}
    INode,                     @{ Unix INode number @}
    Links: Integer;            @{ Number of hard links @}
    TextBinary: Boolean;       @{ Open a Text file in binary mode @}
    Handle: Integer;           @{ Can be set to bind a Pascal file to
                                 a given file handle @}
    CloseFlag: Boolean;        @{ If Handle is used, tell whether to
                                 close it when file is closed @}
    Name: String (BindingNameLength)
  end;
@end smallexample

@code{BindingNameLength} is an implementation-defined constant.

@subheading Description

@subheading Conforming to

@samp{BindingType} is an ISO 10206 Extended Pascal extension. The
fields @samp{Bound} and @samp{Name} are required by Extended Pascal,
the other ones are GNU Pascal extensions.

@subheading Example

@subheading See also

@ref{Bind}, @ref{Unbind}, @ref{Binding}, @ref{bindable}.


@c ----------------------------------------------------------------------------


@node BitSizeOf
@unnumberedsec BitSizeOf
@cindex BitSizeOf
@cindex bits

@subheading Synopsis

@smallexample
function BitSizeOf (var x): SizeType;
@end smallexample

@subheading Description

Returns the size of a type or variable in bits.

@subheading Conforming to

@samp{BitSizeOf} is a GNU Pascal extension.

@subheading Example

@smallexample
program BitSizeOfDemo;
type
  Int12 = Integer attribute (Size = 12);
var
  a: Integer;
  b: array [1 .. 8] of Char;
  c: Int12;
  d: packed record
       x: Int12;
       y: 0 .. 3
     end;
begin
  WriteLn (BitSizeOf (a));    @{ Size of an `Integer'; usually 32 bits. @}
  WriteLn (BitSizeOf (Integer));  @{ The same. @}
  WriteLn (BitSizeOf (b));    @{ Size of eight `Char's; usually 64 bits. @}
  WriteLn (BitSizeOf (c));    @{ e.g. 16 bits (smallest addressable
                                 space holding a 12 bit integer). @}
  WriteLn (BitSizeOf (d));    @{ e.g. 16 @}
  WriteLn (BitSizeOf (d.x));  @{ 12 @}
  WriteLn (BitSizeOf (d.y))   @{ 2 @}
end.
@end smallexample

@subheading See also

@ref{SizeOf}, @ref{AlignOf}, @ref{TypeOf}.


@c ----------------------------------------------------------------------------


@node BlockRead
@unnumberedsec BlockRead
@cindex BlockRead

(Under construction.)

@subheading Synopsis

@smallexample
procedure BlockRead (var F: File; var Buffer; Blocks: Integer);
@end smallexample
or
@smallexample
procedure BlockRead (var F: File; var Buffer; Blocks: Integer;
                     var BlocksRead: Integer);
@end smallexample

@subheading Description

@subheading Conforming to

@samp{BlockRead} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node BlockWrite
@unnumberedsec BlockWrite
@cindex BlockWrite

(Under construction.)

@subheading Synopsis

@smallexample
procedure BlockWrite (var F: File; const Buffer; Blocks: Integer);
@end smallexample
or
@smallexample
procedure BlockWrite (var F: File; const Buffer; Blocks: Integer;
                      var BlocksWritten: Integer);
@end smallexample

@subheading Description

@subheading Conforming to

@samp{BlockWrite} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Boolean
@unnumberedsec Boolean
@cindex Boolean

@subheading Synopsis

@smallexample
type
  Boolean = (False, True); @{ built-in type @}
@end smallexample

@subheading Description

The intrinsic @samp{Boolean} represents boolean values, i.e. it can
only assume the two values @samp{True} and @samp{False}
(which are predefined constants).

@subheading Conforming to

@samp{Boolean} is defined in ISO 7185 Pascal and supported by all
known Pascal variants.

@subheading Example

@smallexample
program BooleanDemo;
var
  a: Boolean;
begin
  a := True;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Boolean (Intrinsic)}, @ref{True}, @ref{False},
@ref{CBoolean}, @ref{ByteBool}, @ref{ShortBool}, @ref{MedBool},
@ref{WordBool}, @ref{LongBool}, @ref{LongestBool}.

@c ----------------------------------------------------------------------------


@node Break
@unnumberedsec Break
@cindex Break

@subheading Synopsis

@smallexample
Break  @{ simple statement @}
@end smallexample

@subheading Description

With @samp{Break} you can exit the body of the current loop
instantly. It can only be used within a @samp{while}, @samp{repeat}
or a @samp{for} loop.

@subheading Conforming to

@samp{Break} is a Borland Pascal extension. Mac Pascal has
@samp{Leave} instead.

@subheading Example

@smallexample
program BreakDemo;
var
  Foo: Integer;
begin
  while True do
    begin
      repeat
        WriteLn ('Enter a number less than 100:');
        ReadLn (Foo);
        if Foo < 100 then
          Break;  @{ Exits `repeat' loop @}
        WriteLn (Foo, ' is not exactly less than 100! Try again ...')
      until False;
      if Foo > 50 then
        Break;  @{ Exits `while' loop @}
      WriteLn ('The number entered was not greater than 50.')
    end
end.
@end smallexample

@subheading See also

@ref{Loop Control Statements}, @ref{Continue}, @ref{Cycle},
@ref{Exit}, @ref{Halt}, @ref{Leave}, @ref{Return}, @ref{goto}.


@c ----------------------------------------------------------------------------


@node Byte
@unnumberedsec Byte
@cindex Byte

@subheading Synopsis

@smallexample
type
  Byte  @{ built-in type @}
@end smallexample

@subheading Description

@samp{Byte} is an unsigned integer type which is one ``unit'' wide.
On most platforms one unit has 8 bits, therefore the type is named
``byte'' and usually has a range of @samp{0 .. 255}. (It is the same
as @ref{ByteCard}.)

@samp{Byte} in GNU Pascal is compatible to @samp{unsigned char}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{Byte} is a Borland Pascal extension. (For something equivalent in
ISO Pascal, see @ref{Subrange Types}.)

@subheading Example

@smallexample
program ByteDemo;
var
  a: Byte;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node ByteBool
@unnumberedsec ByteBool
@cindex ByteBool

@subheading Synopsis

@smallexample
type
  ByteBool = Boolean attribute (Size = BitSizeOf (Byte));
@end smallexample

@subheading Description

The intrinsic @samp{ByteBool} represents boolean values, but
occupies the same memory space as a @samp{Byte}.  It is used when
you need to define a parameter or record that conforms to some
external library or system specification.

@subheading Conforming to

@samp{ByteBool} is a Borland Pascal extension.

@subheading Example

@smallexample
program ByteBoolDemo;
var
  a: ByteBool;
begin
  Byte (a) := 1;
  if a then WriteLn ('Ord (True) = 1')
end.
@end smallexample

@subheading See also

@ref{Boolean (Intrinsic)}, @ref{Boolean}, @ref{True}, @ref{False},
@ref{CBoolean}, @ref{ShortBool}, @ref{MedBool}, @ref{WordBool},
@ref{LongBool}, @ref{LongestBool}.

@c ----------------------------------------------------------------------------


@node ByteCard
@unnumberedsec ByteCard
@cindex ByteCard

@subheading Synopsis

@smallexample
type
  ByteCard = Cardinal attribute (Size = BitSizeOf (Byte));
@end smallexample

@subheading Description

@samp{ByteCard} is an unsigned integer type which is one ``unit'' wide.
On most platforms one unit has 8 bits, therefore the type is prefixed
``byte-'' and usually has a range of @samp{0 .. 255}.

@samp{ByteCard} in GNU Pascal is compatible to @samp{unsigned char}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{ByteCard} is a GNU Pascal extension.

@subheading Example

@smallexample
program ByteCardDemo;
var
  a: ByteCard;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node ByteInt
@unnumberedsec ByteInt
@cindex ByteInt

@subheading Synopsis

@smallexample
type
  ByteInt = Integer attribute (Size = BitSizeOf (Byte));
@end smallexample

@subheading Description

@samp{ByteInt} is a signed integer type which is one ``unit'' wide.
On most platforms one unit has 8 bits, therefore the type is prefixed
``byte-'' and usually has a range of @samp{-128 .. 127}.

@samp{ByteInt} in GNU Pascal is compatible to @samp{signed char}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{ByteInt} is a GNU Pascal extension.

@samp{ByteInt} in GNU Pascal corresponds to @ref{ShortInt} in
Borland Pascal.

@subheading Example

@smallexample
program ByteIntDemo;
var
  a: ByteInt;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node c
@unnumberedsec c
@cindex c

@subheading Synopsis

@subheading Description

@strong{Deprecated}! Use @samp{external} now.

@subheading Conforming to

@subheading Example

@subheading See also

@ref{Keywords}, @ref{Importing Libraries from Other Languages}, @ref{external}.


@c ----------------------------------------------------------------------------


@node Card
@unnumberedsec Card
@cindex Card

@subheading Synopsis

@smallexample
function Card (S: @var{any_set}): Integer;
@end smallexample

@subheading Description

The function @samp{Card (S)} returns the number of elements in the set
@samp{S}.

@subheading Conforming to

@samp{Card} is an ISO 10206 Extended Pascal extension.

@subheading Example

@smallexample
program CardDemo;
var
  Foo: set of 1 .. 100;
begin
  Foo := [1, 2, 3, 5, 1, 1, 1, 2, 2, 2, 3, 3, 5, 5];  @{ four elements @}
  WriteLn ('foo consists of ', Card (Foo), ' elements')
end.
@end smallexample

@subheading See also

@ref{set}


@c ----------------------------------------------------------------------------


@node Cardinal
@unnumberedsec Cardinal
@cindex Cardinal

@subheading Synopsis

@smallexample
type
  Cardinal  @{ built-in type @}
@end smallexample

@subheading Description

@samp{Cardinal} is the ``natural'' unsigned integer type in GNU
Pascal. On some platforms it is 32 bits wide and thus has a range of
@samp{0 .. 4294967295}. Use it whenever you need a general-purpose
unsigned integer type and don't need to care about compatibility to
other Pascal dialects.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{Cardinal} is not defined in ISO Pascal, but several Pascal
compilers support it as an extension. In Borland Delphi, for
instance, it is an unsigned 16-bit in version 1.0, an unsigned
31-bit integer from version 2.0 on, and an unsigned 32-bit
integer from version 4.0 on.

@subheading Example

@smallexample
program CardinalDemo;
var
  a: Cardinal;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node case
@unnumberedsec case
@cindex case

@subheading Synopsis

@smallexample
case @var{expression} of
  @var{selector}: @var{statement};
  @dots{}
  @var{selector}: @var{statement};
end;
@end smallexample
or, with alternative statement sequence:
@smallexample
case @var{expression} of
  @var{selector}: @var{statement};
  @dots{}
  @var{selector}: @var{statement};
otherwise  @{ ``else'' instead of ``otherwise'' is allowed @}
  @var{statement};
  @dots{}
  @var{statement};
end;
@end smallexample
or, as part of the invariant @code{record} type definition:
@smallexample
foo = record
  @var{field_declarations}
case bar: @var{variant_type} of
  @var{selector}: (@var{field_declarations});
  @var{selector}: (@var{field_declarations});
  @dots{}
end;
@end smallexample
or, without a variant selector field,
@smallexample
foo = record
  @var{field_declarations}
case @var{variant_type} of
  @var{selector}: (@var{field_declarations});
  @var{selector}: (@var{field_declarations});
  @dots{}
end;
@end smallexample

@subheading Description

@samp{case} opens a case statement. For further description see
@ref{case Statement}.

For @samp{case} in a variant record type definition, see @ref{Record Types}.

@subheading Conforming to

The @samp{case} statement is defined in ISO 7185 Pascal and
supported by all known Pascal variants.

According to ISO 7185 Pascal, the selector type must be a named
type. UCSD Pascal and Borland Pascal allow any ordinal type here.

The alternative statement execution with @samp{otherwise} it is an
Extended Pascal extension; with @samp{else} it is a Borland Pascal
extension. In GNU Pascal, both are allowed.

@subheading Example

@smallexample
program CaseDemo;
var
  Foo: String (10);
  Bar: Integer;
begin
  WriteLn ('Enter up to ten arbitrary characters:');
  ReadLn (Foo);
  for Bar := 1 to Length (Foo) do
    begin
      Write (Foo[Bar], ' is ');
      case Foo[Bar] of
        'A' .. 'Z', 'a' .. 'z':
          WriteLn ('an English letter');
        '0' .. '9':
          WriteLn ('a number');
      otherwise
        WriteLn ('an unrecognized character')
      end
    end
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{if Statement}, @ref{Record Types},
@ref{else}, @ref{otherwise}


@c ----------------------------------------------------------------------------


@node CBoolean
@unnumberedsec CBoolean
@cindex CBoolean

(Under construction.)

@subheading Synopsis

@smallexample
type
  CBoolean  @{ built-in type @}
@end smallexample

@subheading Description

@samp{CBoolean} is a Boolean type. In GNU Pascal it is compatible to
@samp{_Bool} in GNU C (which is defined as @samp{bool} in
@file{stdbool.h}). This compatibility is the reason why
@samp{CBoolean} exists.

@subheading Conforming to

@samp{CBoolean} is a GNU Pascal extension.

@subheading Example

@smallexample
program CBooleanDemo;
var
  a: CBoolean;
begin
  a := True;
  if Ord (a) = 1 then WriteLn ('Ord (True) = 1')
end.
@end smallexample

@subheading See also

@ref{Boolean (Intrinsic)}, @ref{Integer Types}, @ref{Boolean},
@ref{True}, @ref{False}, @ref{ByteBool}, @ref{ShortBool}, @ref{MedBool},
@ref{WordBool}, @ref{LongBool}, @ref{LongestBool}.


@c ----------------------------------------------------------------------------


@node CCardinal
@unnumberedsec CCardinal
@cindex CCardinal

@subheading Synopsis

@smallexample
type
  CCardinal  @{ built-in type @}
@end smallexample

@subheading Description

@samp{CCardinal} is an unsigned integer type. On some platforms it
is 32 bits wide and thus has a range of @samp{0 .. 4294967295}.

@samp{CCardinal} in GNU Pascal is compatible to @samp{unsigned int}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{CCardinal} is a GNU Pascal extension.

@subheading Example

@smallexample
program CCardinalDemo;
var
  a: CCardinal;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node Char
@unnumberedsec Char
@cindex Char

@subheading Synopsis

@smallexample
type
  Char  @{ built-in type @}
@end smallexample

@subheading Description

The built-in type @samp{Char} holds elements of the operating
system's character set (usually ASCII). The @samp{Char} type is a
special case of ordinal type. Conversion between character types and
ordinal types is possible with the built-in functions @samp{Ord} and
@samp{Chr}.

@subheading Conforming to

@samp{Char} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@smallexample
program CharDemo;
var
  a: Char;
begin
  a := 'x';
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Character Types}, @ref{Ordinal Types}, @ref{Type Casts},
@ref{Ord}, @ref{Chr}.

@c ----------------------------------------------------------------------------


@node ChDir
@unnumberedsec ChDir
@cindex ChDir

@subheading Synopsis

@smallexample
procedure ChDir (Directory: String);
@end smallexample

@subheading Description

@samp{ChDir} changes the current directory to @var{Directory}, if its
argument is a valid parameter to the related operating system's function.
Otherwise, a runtime error is caused.

@subheading Conforming to

@samp{ChDir} is a Borland Pascal extension.

@subheading Example

@smallexample
program ChDirDemo;
var
  Foo: String (127);
begin
  WriteLn ('Enter directory name to change to:');
  ReadLn (Foo);
  @{$I-@}  @{ Don't abort the program on error @}
  ChDir (Foo);
  if IOResult <> 0 then
    WriteLn ('Cannot change to directory `', Foo, '''.')
  else
    WriteLn ('Okay.')
end.
@end smallexample

@subheading See also

@ref{MkDir}, @ref{RmDir}


@c ----------------------------------------------------------------------------


@node Chr
@unnumberedsec Chr
@cindex Chr

@subheading Synopsis

@smallexample
function Chr (AsciiCode: Integer): Char;
@end smallexample

@subheading Description

@samp{Chr} returns a character whose ASCII code corresponds to the value
given by @samp{AsciiCode}.

@subheading Conforming to

@samp{Chr} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@smallexample
program ChrDemo;
var
  x: Integer;
begin
  for x := 32 to 122 do
    Write (Chr (x))
end.
@end smallexample

@subheading See also

@ref{Character Types}, @ref{Ord}, @ref{Char}


@c ----------------------------------------------------------------------------


@node CInteger
@unnumberedsec CInteger
@cindex CInteger

@subheading Synopsis

@smallexample
type
  CInteger  @{ built-in type @}
@end smallexample

@subheading Description

@samp{CInteger} is a signed integer type. On some platforms it is 32
bits wide and thus has a range of @samp{-2147483648 .. 2147483647}.

@samp{CInteger} in GNU Pascal is compatible to @samp{int} in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{CInteger} is a GNU Pascal extension.

@subheading Example

@smallexample
program CIntegerDemo;
var
  a: CInteger;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Integer Types}, @ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node c_language
@unnumberedsec c_language
@cindex c_language

@subheading Synopsis

@subheading Description

@strong{Deprecated}! Use @samp{external} now.

@subheading Conforming to

@subheading Example

@subheading See also

@ref{Keywords}, @ref{Importing Libraries from Other Languages}, @ref{external}.


@c ----------------------------------------------------------------------------


@node class
@unnumberedsec class
@cindex class

Not yet implemented.

@subheading Synopsis

@subheading Description

OOE/Delphi style object class.

@subheading Conforming to

@samp{class} is an Object Pascal and a Borland Delphi extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node Close
@unnumberedsec Close
@cindex Close

(Under construction.)

@subheading Synopsis

@smallexample
procedure Close (var F: @var{any_file});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Close} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Cmplx
@unnumberedsec Cmplx
@cindex Cmplx

@subheading Synopsis

@smallexample
function Cmplx (RealPart, ImaginaryPart: Real): Complex;
@end smallexample

@subheading Description

@samp{Cmplx} makes a complex number from @samp{RealPart} and
@samp{ImaginaryPart}.

@subheading Conforming to

@samp{Cmplx} is an ISO 10206 Extended Pascal extension.

@subheading Example

@smallexample
program CmplxDemo;
var
  z: Complex;
  x, y: Real;
begin
  z := Cmplx (x, y)  @{ z := x + iy @}
end.
@end smallexample

@subheading See also

@ref{Re}, @ref{Im}, @ref{Polar}, @ref{Arg}


@c ----------------------------------------------------------------------------


@node Comp
@unnumberedsec Comp
@cindex Comp

@subheading Synopsis

@smallexample
type
  Comp = LongInt;
@end smallexample

@subheading Description

@samp{Comp} is a signed integer type which is longer than
@samp{Integer}. On some platforms it is 64 bits wide and thus has
a range of @samp{-9223372036854775808 .. 9223372036854775807}.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{Comp} is a Borland Pascal extension.

In some contexts, Borland Pascal treats @samp{Comp} as a ``real''
type -- this behaviour is not supported by GPC.

@subheading Example

@smallexample
program CompDemo;
var
  a: Comp;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Integer Types}, @ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node CompilerAssert
@unnumberedsec CompilerAssert
@cindex CompilerAssert

@subheading Synopsis

@smallexample
procedure CompilerAssert (Condition: Boolean);
@end smallexample
or
@smallexample
function CompilerAssert (Condition: Boolean): Boolean;
@end smallexample
or
@smallexample
function CompilerAssert (Condition: Boolean;
           ResultValue: @var{Any_Type}): type of ResultValue;
@end smallexample

@subheading Description

@samp{CompilerAssert} checks the given @samp{Condition} at
compile-time. If it is a compile-time constant of Boolean type with
the value @samp{True}, it returns @samp{ResultValue}, or if called
with only one argument, it returns @samp{True} or nothing if used as
a procedure.

If @samp{Condition} cannot be evaluated at compile-time or does not
have the value @samp{True}, it causes a compile-time error.

So it can be used to make sure that certain assumptions hold before
relying on them.

@samp{CompilerAssert} does not depend on the
@samp{--[no-]assertions} options. It does not generate any run-time
code.

@subheading Conforming to

@samp{CompilerAssert} is a GNU Pascal extension.

@subheading Example

@smallexample
program CompilerAssertDemo;

var
  a: LongInt;

const
  @{ Make sure that the highest value a can hold is larger than
    MaxInt, and set b to that value. @}
  b = CompilerAssert (High (a) > MaxInt, High (a));

  @{ Do a similar check for the minimum value, setting c to True
    (which can be ignored). @}
  c = CompilerAssert (Low (a) < Low (Integer));

begin
  @{ Procedure-like use of CompilerAssert in the statement part. @}
  CompilerAssert (MaxInt >= 100000);

  WriteLn (b, ' ', c)
end.
@end smallexample

@subheading See also

@ref{Assert}.


@c ----------------------------------------------------------------------------


@node Complex
@unnumberedsec Complex
@cindex Complex

(Under construction.)

@subheading Synopsis

@smallexample
type
  Internal_Complex = record  @{ not visible @}
    RealPart, ImaginaryPart: Real
  end;
  Complex = restricted Internal_Complex;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Complex} is an ISO 10206 Extended Pascal extension.

@subheading Example

@smallexample
program ComplexDemo;
var
  a: Complex;
begin
  a := Cmplx (42, 3);
  WriteLn (Re (a), ' + ', Im (a), ' i')
end.
@end smallexample

@subheading See also


@c ----------------------------------------------------------------------------


@node Concat
@unnumberedsec Concat
@cindex Concat

(Under construction.)

@subheading Synopsis

@smallexample
function Concat (S1, S2: String): String;
@end smallexample
or
@smallexample
function Concat (S1, S2, S3: String): String;
@end smallexample
or
@smallexample
@dots{}
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Concat} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Conjugate
@unnumberedsec Conjugate
@cindex Conjugate

@subheading Synopsis

@smallexample
function Conjugate (z: Complex): Complex;
@end smallexample

@subheading Description

@samp{Conjugate} computes the complex conjugate of the complex number @samp{z}

@subheading Conforming to

@samp{Conjugate} is a GNU Pascal extension.

@subheading Example

@smallexample
program ConjugateDemo;
var
  z: Complex;
begin
  z := Cmplx (2, 3);  @{ z is 2 + i * 3 @}
  WriteLn ('z = ', Re (z) : 0 : 5, ' + i * ', Im (z) : 0 : 5);
  z := Conjugate (z);  @{ z conjugate is 2 - i * 3 @}
  WriteLn ('z conjugate = ', Re (z) : 0 : 5,' + i * ', Im (z) : 0 : 5)
end.
@end smallexample

@subheading See also

@ref{Cmplx}, @ref{Re}, @ref{Im}, @ref{Abs}


@c ----------------------------------------------------------------------------


@node const
@unnumberedsec const
@cindex const

(Under construction.)

@subheading Synopsis

@subheading Description

Constant declaration or constant parameter declaration.

@subheading Conforming to

@samp{const} is defined in ISO 7185 Pascal and supported by all
known Pascal variants. @samp{const} parameters are a Borland Pascal
extension. Pointers to @samp{const} are a GNU Pascal extension.

Constant declarations allow you to define names for constant (unchanging)
values, such as using @samp{SecondsPerHour} instead of 3600.  This can make
your program much more readable and maintainable.

GNU Pascal allows you to define constant strings, records and arrays
as well as simple numeric constants.

GNU Pascal also implements the const parameter extension which
allows the compiler to pass parameters by reference while still
allowing you to pass constant values as inputs.  See
@ref{Subroutine Parameter List Declaration} for more information.

@@@@ Pointers to @samp{const} @@@@

@subheading Example

@smallexample
program ConstDemo;

type
  Rec = record
    x: Integer;
    y: Integer;
  end;

const
  a = 5;
  constr: Rec = (10, 12);

procedure doit (const r: Rec; const s: String);
begin
  WriteLn (r.x);
  WriteLn (r.y);
  WriteLn (s);
end;

var
  variabler: Rec;

begin
  variabler.x := 16;
  variabler.y := 7;
  doit (variabler, 'Should be 16 and 7');
  doit (constr, 'Should be 10 and 12');
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{var}, @ref{protected},
@ref{Subroutine Parameter List Declaration}.


@c ----------------------------------------------------------------------------


@node constructor
@unnumberedsec constructor
@cindex constructor

(Under construction.) ;@minus{})

@subheading Synopsis

@subheading Description

Object constructor.

@subheading Conforming to

@samp{constructor} is an Object Pascal and a Borland Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node Continue
@unnumberedsec Continue
@cindex Continue

@subheading Synopsis

@smallexample
Continue  @{ simple statement @}
@end smallexample

@subheading Description

@samp{Continue} goes on with loop iteration by jumping to the end of
the current loop body. Note: @samp{Continue} can only stand within a
@samp{while}, @samp{repeat} or a @samp{for} loop.

@subheading Conforming to

@samp{Continue} is a Borland Pascal extension, Mac Pascal has
@samp{Cycle} instead.

@subheading Example

@smallexample
program ContinueDemo;
var
  Foo, Bar: Integer;
begin
  WriteLn ('Enter three numbers:');
  for Bar := 1 to 3 do
    begin
      ReadLn (Foo);
      if Foo < 5 then
        Continue;
      WriteLn ('Your number was greater than 5.')
    end
end.
@end smallexample

@subheading See also

@ref{Loop Control Statements}, @ref{Break}, @ref{Cycle}, @ref{Exit},
@ref{Halt}, @ref{Leave}, @ref{Return}, @ref{goto}.


@c ----------------------------------------------------------------------------


@node Copy
@unnumberedsec Copy
@cindex Copy

@subheading Synopsis

@smallexample
function Copy (S: String; FirstChar, Count: Integer): String;
@end smallexample
or
@smallexample
function Copy (S: String; FirstChar: Integer): String;
@end smallexample

@subheading Description

@samp{Copy} returns a sub-string of @samp{S} starting with the
character at position @var{FirstChar}. If @var{Count} is given, such
many characters will be copied into the sub-string. If @var{Count} is
omitted, the sub-string will range to the end of @var{S}.

If @samp{Count} is too large for the sub-string to fit in @var{S}, the
result will be truncated at the end of @var{S}. If @samp{FirstChar}
exceeds the length of @var{S}, the empty string will be returned. (For
a function which does not truncate but triggers a runtime error instead,
see @ref{SubStr}.)

Please note that GPC's strings may be longer than 255 characters. If
you want to isolate the second half of a string @var{S} starting with
the third character, use @samp{Copy (S, 3)} instead of
@samp{Copy (S, 3, 255)}.

@subheading Conforming to

@samp{Copy} is a UCSD Pascal extension. The possibility to omit the
third parameter is a GNU Pascal extension.

@subheading Example

@smallexample
program CopyDemo;
var
  S: String (42);
begin
  S := 'Hello';
  WriteLn (Copy (S, 2, 3));  @{ yields `ell' @}
  WriteLn (Copy (S, 3));     @{ yields `llo' @}
  WriteLn (Copy (S, 4, 7));  @{ yields `lo' @}
  WriteLn (Copy (S, 42))     @{ yields the empty string @}
end.
@end smallexample

@subheading See also

@ref{SubStr}, @ref{String Slice Access}.


@c ----------------------------------------------------------------------------


@node Cos
@unnumberedsec Cos
@cindex Cos

@subheading Synopsis

@smallexample
function Cos (x: Real): Real;
@end smallexample
or
@smallexample
function Cos (z: Complex): Complex;
@end smallexample

@subheading Description

@samp{Cos} returns the cosine of the argument.
The result is in the range @samp{-1 < Cos (x) < 1} for real arguments.

@subheading Conforming to

The function @samp{Cos} is defined in ISO 7185 Pascal;
its application to complex values is defined in ISO 10206 Extended Pascal.

@subheading Example

@smallexample
program CosDemo;
begin
  @{ yields 0.5 since Cos (Pi / 3) = 0.5 @}
  WriteLn (Cos (Pi / 3) : 0 : 5)
end.
@end smallexample

@subheading See also

@ref{ArcTan}, @ref{Sin}, @ref{Ln}, @ref{Arg}.


@c ----------------------------------------------------------------------------


@node CString
@unnumberedsec CString
@cindex CString

(Under construction.)

@subheading Synopsis

@smallexample
type
  CString = ^Char;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{CString} is a GNU Pascal extension.

@subheading Example

@smallexample
program CStringDemo;
var
  s: CString;
begin
  s := 'Hello, world!';
  @{$X+@}
  WriteLn (s)
end.
@end smallexample

@subheading See also


@c ----------------------------------------------------------------------------


@node CString2String
@unnumberedsec CString2String
@cindex CString2String

(Under construction.)

@subheading Synopsis

@smallexample
function CString2String (S: CString): String;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{CString2String} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node CStringCopyString
@unnumberedsec CStringCopyString
@cindex CStringCopyString

(Under construction.)

@subheading Synopsis

@smallexample
function CStringCopyString (Dest: CString; const Source: String): CString;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{CStringCopyString} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node CurrentRoutineName
@unnumberedsec CurrentRoutineName
@cindex CurrentRoutineName

@subheading Synopsis

@smallexample
function CurrentRoutineName: String;
@end smallexample

@subheading Description

@samp{CurrentRoutineName} returns the name of the current routine
from where it's called.

@subheading Conforming to

@samp{CurrentRoutineName} is a GNU Pascal extension.

@subheading Example

@smallexample
program CurrentRoutineNameDemo;

procedure FooBar;
begin
  WriteLn (CurrentRoutineName)  @{ `FooBar' @}
end;

begin
  WriteLn (CurrentRoutineName);  @{ `main program' @}
  FooBar
end.
@end smallexample

@subheading See also


@c ----------------------------------------------------------------------------


@node CWord
@unnumberedsec CWord
@cindex CWord

@subheading Synopsis

@smallexample
type
  CWord = CCardinal;
@end smallexample

@subheading Description

@samp{CCardinal} is an unsigned integer type. On some platforms it
is 32 bits wide and thus has a range of @samp{0 .. 4294967295}. It is
the same as @ref{CCardinal}.

@samp{CWord} in GNU Pascal is compatible to @samp{unsigned int}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{CWord} is a GNU Pascal extension.

@subheading Example

@smallexample
program CWordDemo;
var
  a: CWord;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{CCardinal}, @ref{Integer Types}, @ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node Cycle
@unnumberedsec Cycle
@cindex Cycle

@subheading Synopsis

@smallexample
Cycle  @{ simple statement @}
@end smallexample

@subheading Description

@samp{Cycle} goes on with loop iteration by jumping to the end of
the current loop body. Note: @samp{Cycle} can only stand within a
@samp{while}, @samp{repeat} or a @samp{for} loop.

@subheading Conforming to

@samp{Cycle} is a Mac Pascal extension. Borland Pascal has
@samp{Continue} instead.

@subheading Example

@smallexample
program CycleDemo;
var
  Foo, Bar: Integer;
begin
  WriteLn ('Enter three numbers:');
  for Bar := 1 to 3 do
    begin
      ReadLn (Foo);
      if Foo < 5 then
        Cycle;
      WriteLn ('Your number was greater than 5.')
    end
end.
@end smallexample

@subheading See also

@ref{Loop Control Statements}, @ref{Break}, @ref{Continue},
@ref{Exit}, @ref{Halt}, @ref{Leave}, @ref{Return}, @ref{goto}.


@c ----------------------------------------------------------------------------


@node Date
@unnumberedsec Date
@cindex Date

@subheading Synopsis

@smallexample
function Date (T: TimeStamp): packed array [1 .. @var{Date_length}] of Char;
@end smallexample

@subheading Description

Date takes a @code{TimeStamp} parameter and returns the date as a
string (in the form of a packed array of @code{Char}).
@var{Date_length} is an implementation defined invisible constant.

@subheading Conforming to

@samp{Date} is an ISO 10206 Extended Pascal extension.

@subheading Example

Set @ref{TimeStamp}.

@subheading See also

@ref{TimeStamp}, @ref{GetTimeStamp}, @ref{Time},
@ref{Date And Time Routines}.


@c ----------------------------------------------------------------------------


@node Dec
@unnumberedsec Dec
@cindex Dec

@subheading Synopsis

For ordinal types:
@smallexample
procedure Dec (var x: @var{ordinal_type});
@end smallexample
or
@smallexample
procedure Dec (var x: @var{ordinal_type}; Amount: @var{and_integer_type});
@end smallexample

For pointer types:
@smallexample
procedure Dec (var p: @var{any_pointer_type});
@end smallexample
or
@smallexample
procedure Dec (var p: @var{any_pointer_type}; Amount: @var{and_integer_type});
@end smallexample

@subheading Description

For ordinal types, @samp{Dec} decreases the value of @samp{x} by one or
by @samp{amount} if specified.

If the argument @samp{p} is pointing to a specified type (typed
pointer), @samp{Dec} decreases the address of @samp{p} by the size
of the type @samp{p} is pointing to or by @samp{amount} times that
size respectively. If @samp{p} is an untyped pointer (i.e. @samp{p}
is of type @ref{Pointer}), @samp{p} is decreased by one, otherwise
by @samp{amount} if specified.

@subheading Conforming to

@samp{Dec} is a Borland Pascal extension. The combination of the second
argument with application to pointers is a GNU Pascal extension.

@subheading Example

@smallexample
program DecDemo;
var
  x: Integer;
  y: array [1 .. 5] of Integer;
  p: ^Integer;
begin
  x := 9;
  Dec (x, 10);  @{ yields -1 @}
  @{$X+@}         @{ Turn on extended systax @}
  p := @@y[5];   @{ p points to y[5] @}
  Dec (p, 3)    @{ p points to y[2] @}
end.
@end smallexample

@subheading See also

@ref{Inc}, @ref{Pred}, @ref{Succ}, @ref{Pointer Arithmetics}.


@c ----------------------------------------------------------------------------


@node DefineSize
@unnumberedsec DefineSize
@cindex DefineSize

(Under construction.)

@subheading Synopsis

@smallexample
procedure DefineSize (var F: @var{any_file}; NewSize: Integer);
@end smallexample

@subheading Description

@subheading Conforming to

@samp{DefineSize} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Delete
@unnumberedsec Delete
@cindex Delete

(Under construction.)

@subheading Synopsis

@smallexample
procedure Delete (var S: String; FirstChar, Count: Integer);
@end smallexample
or
@smallexample
procedure Delete (var S: String; FirstChar: Integer);
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Delete} is a UCSD Pascal extension. The possibility to omit
the third parameter is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node destructor
@unnumberedsec destructor
@cindex destructor

(Under construction.)

@subheading Synopsis

@subheading Description

Object destructor.

@subheading Conforming to

@samp{destructor} is an Object Pascal and a Borland Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node Discard
@unnumberedsec Discard
@cindex Discard

@subheading Synopsis

@smallexample
Discard (Value);
@end smallexample

@subheading Description

@samp{Discard} does nothing, but tells the compiler that the value
given as an argument is not further used. It can be applied, e.g.,
to routine parameters which are to be ignored, so no warning about
them will be given with @samp{-Wunused}, or when calling a function
and ignore its result.

An alternative for the latter case is to give the function the
@samp{ignorable} attribute. This is useful is the function's result
is expected to be ignored regularly. If, however, a result is
generally meaningful and only to be ignored in a particular case,
using @samp{Discard} is preferable.

@subheading Conforming to

@samp{Discard} is a GNU Pascal extension.

@subheading Example

program DiscardDemo;

function Foo (a: Integer): Integer;
begin
  WriteLn (a);
  Foo := a + 1
end;

@{ Parameter `a' is there only to make the parameter list compatible
  to that of function `Foo'. @}
function Bar (a: Integer): Integer;
begin
  Discard (a);  @{ Tell the compiler that we intentionally do not
                  use `a' in this function. @}
  Bar := a + 1
end;

var
  c: Char;
  f: function (a: Integer): Integer;

begin
  Write ('With output? ');
  ReadLn (c);
  if LoCase (c) = 'y' then
    f := Foo
  else
    f := Bar;
  Discard (f (42))  @{ Call the function, but ignore its result @}
end.

@subheading See also


@c ----------------------------------------------------------------------------


@node Dispose
@unnumberedsec Dispose
@cindex Dispose

(Under construction.)

@subheading Synopsis

@smallexample
Dispose (PointerVar: Pointer);
@end smallexample
or
@smallexample
Dispose (PointerVar: Pointer; @var{tag_field_values});
@end smallexample
or
@smallexample
Dispose (ObjectPointerVar: Pointer; @var{destructor_call});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Dispose} is defined in ISO 7185 Pascal and supported by most
known Pascal variants, but not by UCSD Pascal. Its use for objects
is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node div
@unnumberedsec div
@cindex div

@subheading Synopsis

@smallexample
operator div (p, q: Integer) = r: Integer;
@end smallexample

@subheading Description

Integer division operator.

@subheading Conforming to

@samp{div} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@smallexample
program DivDemo;

var
  a, b: Integer;

begin
  a := 16;
  b := 7;
  WriteLn (a div b);  @{ `2' @}
end.
@end smallexample

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node do
@unnumberedsec do
@cindex do

@subheading Synopsis

@smallexample
for ... do
  @var{statement}
@end smallexample
or
@smallexample
while ... do
  @var{statement}
@end smallexample
or
@smallexample
with ... do
  @var{statement}
@end smallexample
or
@smallexample
to begin do
  @var{statement}
@end smallexample
or
@smallexample
to end do
  @var{statement}
@end smallexample

@subheading Description

The @samp{do} reserved word is used in combination with other Pascal
keywords in many ways. For description and examples see the relevant
reference sections: @samp{for}, @samp{while}, @samp{with},
@samp{to begin}, @samp{to end}.

@subheading Conforming to

@samp{do} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

See references.

@subheading See also

@ref{Keywords}, @ref{for}, @ref{while}, @ref{with},
@ref{to begin do}, @ref{to end do}.


@c ----------------------------------------------------------------------------


@node Double
@unnumberedsec Double
@cindex Double

(Under construction.)

@subheading Synopsis

@smallexample
type
  Double = Real;
@end smallexample

@subheading Description

@samp{Double} is a synonym for the @samp{Real} data type and
supported for compatibility with other compilers.

@subheading Conforming to

@samp{Double} is a Borland Pascal extension.

@subheading Example

@smallexample
program DoubleDemo;
var
  A: Double;  @{ There is nothing special with `Double'. @}
  B: Real;
begin
  A := Pi;
  A := B
end.
@end smallexample

@subheading See also


@c ----------------------------------------------------------------------------


@node downto
@unnumberedsec downto
@cindex downto

@subheading Synopsis

@smallexample
for @var{variable} := @var{value1} downto @var{value2} do
  @var{statement}
@end smallexample

@subheading Description

The @samp{downto} reserved word is used in combination with
@samp{for} to build a @samp{for} loop.

@subheading Conforming to

@samp{downto} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

program DowntoDemo;
var
  i: Integer;
begin
  for i := 10 downto 1 do WriteLn (i)
end.

@subheading See also

@ref{Keywords}, @ref{for}.


@c ----------------------------------------------------------------------------


@node else
@unnumberedsec else
@cindex else

@subheading Synopsis

As part of the @code{if} @dots{} @code{then} @dots{} @code{else} statement:
@smallexample
if @var{Boolean_expression} then
  @var{statement1}
else
  @var{statement2}
@end smallexample
or, as part of the @code{case} @dots{} @code{else} statement:
@smallexample
case @var{expression} of
  @var{selector}: @var{statement};
  @dots{}
  @var{selector}: @var{statement}
else  @{ ``otherwise'' instead of ``else'' is allowed @}
  @var{statement};
  @dots{}
  @var{statement}
end
@end smallexample

@subheading Description

@samp{else} is part of the @samp{if @dots{} then @dots{} else}
statement which provides a possibility to execute statements
alternatively. In the @code{case} statement, @samp{else} starts a
series of statements which is executed if no selector fit in
@var{expression}. In this situation, @samp{else} is a synonym for
@code{otherwise}.

@subheading Conforming to

@samp{else} in @samp{if} statements is defined in ISO 7185
Pascal and supported by all known Pascal variants. @samp{else} in
@samp{case} statements is a Borland Pascal extension; ISO 10206 Extended
Pascal has @samp{otherwise} instead.

@subheading Example

@smallexample
program ElseDemo;
var
  i: Integer;
begin
  Write ('Enter a number: ');
  ReadLn (i);
  if i > 42 then
    WriteLn ('The number is greater than 42')
  else
    WriteLn ('The number is not greater than 42')
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{if}, @ref{case}, @ref{otherwise}.


@c ----------------------------------------------------------------------------


@node Empty
@unnumberedsec Empty
@cindex Empty

(Under construction.)

@subheading Synopsis

@smallexample
function Empty (var F: @var{any_file}): Boolean;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Empty} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node end
@unnumberedsec end
@cindex end

@subheading Synopsis

@smallexample
begin
  @var{statement};
  @var{statement};
  @dots{}
  @var{statement}
end
@end smallexample

@subheading Description

The reserved word @samp{end} closes a @samp{begin} @dots{} @samp{end};
statement which joins several @var{statements} together into one compound
statement.

@@@@ end of a @samp{case} statement
@@@@ end of a record or object declaration
@@@@ part of a @samp{to end do} module destructor

@subheading Conforming to

@samp{end} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@smallexample
program EndDemo;
begin
  if True then
    WriteLn ('single statement');
  if True then
    begin  @{ clamp statement1 ... @}
      WriteLn ('statement1');
      WriteLn ('statement2')
    end    @{ ... to statement2 @}
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{begin end Compound Statement}, @ref{begin}


@c ----------------------------------------------------------------------------


@node EOF
@unnumberedsec EOF
@cindex EOF

(Under construction.)

@subheading Synopsis

@smallexample
function EOF ([var F: @var{any_file}]): Boolean;
@end smallexample
or
@smallexample
function EOF: Boolean;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{EOF} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node EOLn
@unnumberedsec EOLn
@cindex EOLn

(Under construction.)

@subheading Synopsis

@smallexample
function EOLn ([var F: Text]): Boolean;
@end smallexample
or
@smallexample
function EOLn: Boolean;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{EOLn} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node EpsReal
@unnumberedsec EpsReal
@cindex EpsReal

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{EpsReal} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node EQ
@unnumberedsec EQ
@cindex EQ

(Under construction.)

@subheading Synopsis

@smallexample
function EQ (S1, S2: String): Boolean;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{EQ} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node EQPad
@unnumberedsec EQPad
@cindex EQPad

(Under construction.)

@subheading Synopsis

@smallexample
function EQPad (S1, S2: String): Boolean;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{EQPad} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Erase
@unnumberedsec Erase
@cindex Erase

(Under construction.)

@subheading Synopsis

@smallexample
procedure Erase (var F: @var{any_file});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Erase} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node except
@unnumberedsec except
@cindex except

Not yet implemented.

@subheading Synopsis

@subheading Conforming to

@samp{except} is a Borland Delphi extension.

@subheading Example

@subheading See also

@ref{Keywords}.

@c ----------------------------------------------------------------------------


@node Exclude
@unnumberedsec Exclude
@cindex Exclude

@subheading Synopsis

@smallexample
Exclude (@var{set_variable}, @var{ordinal_value});
@end smallexample

@subheading Description

Remove (subtract) a single element from a set.  @var{ordinal_value}
must be compatible with the base type of @var{set_variable}.
Exclude is equivalent to:

@smallexample
@var{set_variable} := @var{set_variable} - [@var{ordinal_value}];
@end smallexample

If @var{set_variable} does not contain @var{ordinal_value}, nothing
happens.

@subheading Conforming to

@samp{Exclude} is a Borland Pascal extension.

@subheading Example

@smallexample
program ExcludeDemo;

var
  Ch: Char;
  MyCharSet: set of Char;

begin
  MyCharSet := ['P', 'N', 'L'];
  Exclude (MyCharSet , 'N')  @{ L, P @}
end.
@end smallexample

See other examples in @ref{set} and @ref{Set Operations}.

@subheading See also

@ref{Keywords}, @ref{Set Operations}, @ref{set}, @ref{in}, @ref{Include}.


@c ----------------------------------------------------------------------------


@node Exit
@unnumberedsec Exit
@cindex Exit

@subheading Synopsis

@smallexample
procedure Exit;
@end smallexample

or

@smallexample
procedure Exit (program);
@end smallexample

or

@smallexample
procedure Exit (Identifier);
@end smallexample

@subheading Description

@samp{Exit} without an argument leaves the currently executed
procedure or function. Note: If @samp{Exit} is called within the
main program, it will be terminated instantly.

@samp{Exit} with an argument that is @samp{program} or the name of
the current program, terminates the program, and is equivalent to
@samp{Halt}.

@samp{Exit} with an argument that is the name of the current or an
encompassing routine leaves that routine.

@subheading Conforming to

@samp{Exit} is a UCSD Pascal extension. Borland Pascal only allows
it without an argument.

@subheading Example

@smallexample
program ExitDemo;

procedure Foo (Bar: Integer);
var
  Baz, Fac: Integer;
begin
  if Bar < 1 then
    Exit;  @{ Exit `Foo' @}
  Fac := 1;
  for Baz := 1 to Bar do
    begin
      Fac := Fac * Baz;
      if Fac >= Bar then
        Exit;  @{ Exit `Foo' @}
      WriteLn (Bar,' is greater than ', Baz, '!, which is equal to ', Fac)
  end
end;

begin
  Foo (-1);
  Foo (789);
  Exit;            @{ Terminates program @}
  Foo (987654321)  @{ This is not executed anymore @}
end.
@end smallexample

@subheading See also

@ref{Break}, @ref{Continue}, @ref{Halt}.


@c ----------------------------------------------------------------------------


@node Exp
@unnumberedsec Exp
@cindex Exp

@subheading Synopsis

@smallexample
function Exp (x: Real): Real;
@end smallexample
or
@smallexample
function Exp (z: Complex): Complex;
@end smallexample

@subheading Description

The exponential function @samp{Exp} computes the value of e to the power
of x, where the Euler number e = Exp (1) is the base of the natural
logarithm.

@subheading Conforming to

The function @samp{Exp} is defined in ISO 7185 Pascal;
its application to complex values is defined in ISO 10206 Extended Pascal.

@subheading Example

@smallexample
program ExpDemo;
var
  z: Complex;
begin
  z := Cmplx (1, - 2 * Pi);  @{ z = 1 - 2 pi i @}
  z := Exp (z);  @{ yields e = Exp (1), since Exp ix = Cos x + i Sin x @}
  WriteLn (Ln (Re (z)) : 0 : 5)  @{ prints 1 = Ln (Exp (1)) @}
end.
@end smallexample

@subheading See also

@ref{Ln}


@c ----------------------------------------------------------------------------


@node export
@unnumberedsec export
@cindex export
@cindex all

(Under construction.)

@subheading Synopsis

@smallexample
export @samp{interface_name} = (@var{identifier}, @var{identifier}, @dots{});
@end smallexample

or

@smallexample
export @samp{interface_name} = all;
@end smallexample

@subheading Description

Interface export for Extended Pascal modules.

@samp{all} means to automatically export all identifiers declared in
the interface module.

@subheading Conforming to

@samp{export} is an ISO 10206 Extended Pascal extension. It also
exists in Borland Pascal, but with a different meaning, not (yet)
supported by GPC.

@samp{export all} is a GNU Pascal extension.

@subheading Example

@smallexample
program ExportDemo;

import AllInterface in 'somemodule.pas';

begin
  Bar (a);
  WriteLn (b)
end.
@end smallexample

@smallexample
module SomeModule interface;

export
  SomeInterface = (a);
  AllInterface = all;  @{ Same as `AllInterface = (a, b, Bar);' @}

var
  a, b: Integer;

procedure Bar (i: Integer);

end.

module SomeModule implementation;

procedure Bar (i: Integer);
begin
  b := a
end;

to begin do
  a := 42;

end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{Modules}.


@c ----------------------------------------------------------------------------


@node exports
@unnumberedsec exports
@cindex exports

Not yet implemented.

@subheading Synopsis

@subheading Description

Library export.

@subheading Conforming to

@samp{exports} is a Borland Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node Extend
@unnumberedsec Extend
@cindex Extend

(Under construction.)

@subheading Synopsis

@smallexample
procedure Extend (var F: @var{any_file}; [FileName: String;]
                                    [BlockSize: Cardinal]);
@end smallexample

@subheading Description

@samp{Extend} opens a file for writing. If the file does not
exist, it is created. If it does exist, the file pointer is
positioned after the last element.

Like @samp{Rewrite}, @samp{Reset} and @samp{Append} do,
@samp{Reset} accepts an optional second parameter for the name of
the file in the filesystem and a third parameter for the block size
of the file. The third parameter is allowed only (and by default
also required) for untyped files. For details, see @ref{Rewrite}.

@subheading Conforming to

@samp{Extend} is an ISO 10206 Extended extension. Borland Pascal
has @ref{Append} instead.
The @samp{BlockSize} parameter is a Borland Pascal extension.
The @samp{FileName} parameter is a GNU Pascal extension.
@c @@@@ Other compilers?

@subheading Example

@smallexample
program ExtendDemo;
var
  Sample: Text;
begin
  Assign (Sample, 'sample.txt');
  Rewrite (Sample);
  WriteLn (Sample, 'Hello, World!');  @{ `sample.txt' now has one line @}
  Close (Sample);

  @{ ... @}

  Extend (Sample);
  WriteLn (Sample, 'Hello again!');  @{ `sample.txt' now has two lines @}
  Close (Sample)
end.
@end smallexample

@subheading See also

@ref{Assign}, @ref{Reset}, @ref{Rewrite}, @ref{Update},
@ref{Append}.


@c ----------------------------------------------------------------------------


@node Extended
@unnumberedsec Extended
@cindex Extended

(Under construction.)

@subheading Synopsis

@smallexample
type
  Extended = LongReal;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Extended} is a Borland Pascal extension.

@subheading Example

@smallexample
program ExtendedDemo;
var
  a: Extended;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also


@c ----------------------------------------------------------------------------


@node external
@unnumberedsec external
@cindex external

(Under construction.)

@subheading Synopsis

@smallexample
@var{declaration} external;
@end smallexample

or

@smallexample
@var{declaration} external name @var{linker_name};
@end smallexample

@subheading Description


Declaration of external object.

@subheading Conforming to

@samp{external} is a UCSD Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node Fail
@unnumberedsec Fail
@cindex Fail

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{Fail} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node False
@unnumberedsec False
@cindex False

@subheading Synopsis

@smallexample
type
  Boolean = (False, True);  @{ built-in type @}
@end smallexample

@subheading Description

@samp{False} is one of the two Boolean values and is used to
represent a condition which is never fullfilled. For example, the
expression, @samp{1 = 2} always yields @samp{False}. It is the
opposite of @samp{True}. @samp{False} has the ordinal value 0.

@subheading Conforming to

@samp{False} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@smallexample
program FalseDemo;

var
  a: Boolean;

begin
  a := 1 = 2;  @{ yields False @}
  WriteLn (Ord (False));  @{ 0 @}
  WriteLn (a);  @{ False @}
  if False then WriteLn ('This is not executed.')
end.
@end smallexample

@subheading See also

@ref{Boolean (Intrinsic)}, @ref{True}, @ref{Boolean}.

@c ----------------------------------------------------------------------------


@node far
@unnumberedsec far
@cindex far

@subheading Synopsis

@subheading Description

The @samp{far} directive can be appended to a procedure or function
heading but is ignored by GPC. It is there for Borland compatibility,
only. (Since the GNU compilers provide a flat memory model, the
distinction between @samp{near} and @samp{far} pointers is void.)

@subheading Conforming to

@samp{far} is a Borland Pascal extension.

@subheading Example

@smallexample
program FarDemo;

var
  p: procedure;

@{$W no-near-far@}  @{ Don't warn about the uselessness of `far' @}

procedure Foo; far;  @{ `far' has no effect in GPC @}
begin
  WriteLn ('Foo')
end;

begin
  p := Foo;  @{ Would also work without `far' in GPC. @}
  p
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{near}.


@c ----------------------------------------------------------------------------


@node file
@unnumberedsec file
@cindex file

(Under construction.)

@subheading Synopsis

In type definitions:
@smallexample
file of @var{Type}
@end smallexample
or
@smallexample
file
@end smallexample

@subheading Description

Non-text file type declaration.

@subheading Conforming to

Typed files (@samp{file of @var{Type}}) are defined in ISO 7185
Pascal and supported by all known Pascal variants. Untyped files
(@samp{file}) are a Borland Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}, @ref{Text}, @ref{AnyFile}.


@c ----------------------------------------------------------------------------


@node FilePos
@unnumberedsec FilePos
@cindex FilePos

(Under construction.)

@subheading Synopsis

@smallexample
function FilePos (var F: @var{any_file}): Integer;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{FilePos} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node FileSize
@unnumberedsec FileSize
@cindex FileSize

(Under construction.)

@subheading Synopsis

@smallexample
function FileSize (var F: @var{any_file}): Integer;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{FileSize} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node FillChar
@unnumberedsec FillChar
@cindex FillChar

(Under construction.)

@subheading Synopsis

@smallexample
procedure FillChar (var Dest; Count: SizeType; Val: Char);
@end smallexample
or
@smallexample
procedure FillChar (var Dest; Count: SizeType; Val: Byte);
@end smallexample

@subheading Description

@subheading Conforming to

@samp{FillChar} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node finalization
@unnumberedsec finalization
@cindex finalization

(Under construction.)

@subheading Synopsis

@subheading Description

Unit finalization.

It is equivalent to Extended Pascal's @samp{to end do}.

@subheading Conforming to

@samp{finalization} is a Borland Delphi extension.

@subheading Example

@subheading See also

@ref{Keywords}, @ref{initialization}, @ref{to end do}.


@c ----------------------------------------------------------------------------


@node Finalize
@unnumberedsec Finalize
@cindex Finalize

(Under construction.)

@subheading Synopsis

@smallexample
procedure Finalize (var Aynthing);
@end smallexample

@subheading Description

@samp{Finalize} does all necessary clean-ups for the parameter. This
is normally done automatically when a variable goes out of scope, so
you need to call @samp{Finalize} only in special situations, e.g.
when you deallocate a dynamic variable with @samp{FreeMem} rather
than @samp{Dispose}.

Using a variable after applying @samp{Finalize} to it (and without applying
@samp{Initialize} to it again) is invalid and produces undefined results.

@subheading Conforming to

@samp{Finalize} is a Borland Delphi extension.

@subheading Example

@subheading See also

@ref{Initialize}, @ref{Dispose}, @ref{FreeMem}.


@c ----------------------------------------------------------------------------


@node finally
@unnumberedsec finally
@cindex finally

Not yet implemented.

@subheading Synopsis

@subheading Conforming to

@samp{finally} is a Borland Delphi extension.

@subheading Example

@subheading See also

@ref{Keywords}.

@c ----------------------------------------------------------------------------


@node Flush
@unnumberedsec Flush
@cindex Flush

(Under construction.)

@subheading Synopsis

@smallexample
procedure Flush (var F: @var{any_file});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Flush} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node for
@unnumberedsec for
@cindex for

@subheading Synopsis

For ordinal index variables:
@smallexample
for @var{ordinal_variable} := @var{initial_value} to @var{final_value} do
  @var{statement}
@end smallexample
or
@smallexample
for @var{ordinal_variable} := @var{initial_value} downto @var{final_value} do
  @var{statement}
@end smallexample

For sets:
@smallexample
for @var{set_element_type_variable} in @var{some_set} do
  @var{statement}
@end smallexample

For pointer index variables:
@smallexample
for @var{pointer_variable} := @var{initial_address} to @var{final_address} do
  @var{statement}
@end smallexample
or
@smallexample
for @var{pointer_variable} := @var{initial_address} downto @var{final_address} do
  @var{statement}
@end smallexample

@@@@ Set member iteration

@subheading Description

The @samp{for} statement is a count loop. For further information
see @ref{for Statement}.

@subheading Conforming to

@samp{for} is defined in ISO 7185 Pascal and supported by all known
Pascal variants. Iteration of Pointers is a Borland Pascal
extension. Set member iteration is an ISO 10206 Extended Pascal
extension.

@subheading Example

@smallexample
program ForDemo;
var
  CharSet: set of Char;
  c: Char;
  n: Integer;
  Fac: array [0 .. 10] of Integer;
  PInt: ^Integer;
begin
  CharSet := ['g', 'p', 'c'];
  for c in CharSet do
    WriteLn (c);  @{ prints `c', `g', `p' in three lines @}
  Fac[0] := 1;
  for n := 1 to 10 do  @{ computes the factorial of n for n = 0 .. 10 @}
    Fac[n] := Fac[n - 1] * n;
  @{$X+@}
  @{ prints n! for n = 0 .. 10 @}
  for PInt := @@Fac[0] to @@Fac[10] do
    WriteLn (PInt - @@Fac[0], '! = ', PInt^)
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{Set Types}, @ref{Pointer Arithmetics}


@c ----------------------------------------------------------------------------


@node FormatString
@unnumberedsec FormatString
@cindex FormatString

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{FormatString} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node forward
@unnumberedsec forward
@cindex forward

(Under construction.)

@subheading Synopsis

@subheading Description

Declaration of a routine whose definition follows below.

@subheading Conforming to

@samp{forward} is a UCSD Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node Frac
@unnumberedsec Frac
@cindex Frac

@subheading Synopsis

@smallexample
function Frac (x: Real): Real;
@end smallexample

@subheading Description

@samp{Frac} returns the fractional part of a floating point number.

@subheading Conforming to

@samp{Frac} is a Borland Pascal extension.

@subheading Example

@smallexample
program FracDemo;

begin
  WriteLn (Frac (12.345) : 1 : 5);  @{ 0.34500 @}
  WriteLn (Int (12.345) : 1 : 5);  @{ 12.00000 @}
  WriteLn (Round (12.345) : 1);  @{ 12 @}
  WriteLn (Trunc (12.345) : 1);  @{ 12 @}

  WriteLn (Frac (-12.345) : 1 : 5);  @{ -0.34500 @}
  WriteLn (Int (-12.345) : 1 : 5);  @{ -12.00000 @}
  WriteLn (Round (-12.345) : 1);  @{ -12 @}
  WriteLn (Trunc (-12.345) : 1);  @{ -12 @}

  WriteLn (Frac (12.543) : 1 : 5);  @{ 0.54300 @}
  WriteLn (Int (12.543) : 1 : 5);  @{ 12.00000 @}
  WriteLn (Round (12.543) : 1);  @{ 13 @}
  WriteLn (Trunc (12.543) : 1);  @{ 12 @}

  WriteLn (Frac (-12.543) : 1 : 5);  @{ -0.54300 @}
  WriteLn (Int (-12.543) : 1 : 5);  @{ -12.00000 @}
  WriteLn (Round (-12.543) : 1);  @{ -13 @}
  WriteLn (Trunc (-12.543) : 1);  @{ -12 @}
end.
@end smallexample

@subheading See also

@ref{Real Types}, @ref{Real}, @ref{Int}, @ref{Round}, @ref{Trunc}.

@c ----------------------------------------------------------------------------


@node FrameAddress
@unnumberedsec FrameAddress
@cindex FrameAddress

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{FrameAddress} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node FreeMem
@unnumberedsec FreeMem
@cindex FreeMem

@subheading Synopsis

@smallexample
procedure FreeMem (var p: Pointer; Size: Cardinal);
@end smallexample
or
@smallexample
procedure FreeMem (var p: Pointer);
@end smallexample

@subheading Description

Releases a chunk of memory previously allocated using @samp{GetMem}.
The parameter @var{Size} is optional. Its value is currently ignored.

Since Extended Pascal's schemata provide a cleaner way to implement
dynamical arrays and such, we recommend using @samp{GetMem} and
@samp{FreeMem} only for low-level applications or for interfacing
with other languages.

@subheading Conforming to

@samp{FreeMem} is a Borland Pascal extension. @samp{FreeMem}
with only one parameter is a GNU Pascal extension.

@subheading Example

@xref{GetMem}.

@subheading See also

@ref{GetMem}, @ref{Schema Types}, @ref{Dispose}, @ref{Mark}, @ref{Release}.


@c ----------------------------------------------------------------------------


@node function
@unnumberedsec function
@cindex function

(Under construction.)

@subheading Synopsis

@subheading Description

Function declaration.

@subheading Conforming to

@samp{function} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node GE
@unnumberedsec GE
@cindex GE

(Under construction.)

@subheading Synopsis

@smallexample
function GE (S1, S2: String): Boolean;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{GE} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node GEPad
@unnumberedsec GEPad
@cindex GEPad

(Under construction.)

@subheading Synopsis

@smallexample
function GEPad (S1, S2: String): Boolean;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{GEPad} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Get
@unnumberedsec Get
@cindex Get

(Under construction.)

@subheading Synopsis

@smallexample
procedure Get (var F: @var{typed_file});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Get} is defined in ISO 7185 Pascal and supported by all known
Pascal variants except UCSD/Borland Pascal and its variants.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node GetMem
@unnumberedsec GetMem
@cindex GetMem

@subheading Synopsis

@smallexample
procedure GetMem (var p: Pointeger; Size: Cardinal);
@end smallexample

@subheading Description

Allocates dynamical storage on the heap and returns a pointer to it in
@samp{p}.

Since Extended Pascal's schemata provide a cleaner way to implement
dynamical arrays and such, we recommend using @samp{GetMem} and
@samp{FreeMem} only for low-level applications.

@subheading Conforming to

@samp{GetMem} is a Borland Pascal extension.

@subheading Example

The Borland-comatibility unit @samp{Graph} from the @file{BPcompat}
package supports a @samp{GetImage} and a @samp{PutImage} procedure
which need a variable of size @samp{ImageSize} as a buffer. Since
these are ``black box'' routines, the buffer can't reasonably be a
schema providing a dynamical array. Instead, we have to use
@samp{GetMem} and @samp{FreeMem} for dynamical memory allocation.

@smallexample
program GetMemDemo;
var
  Buffer: Pointer;
  Size: Cardinal;
begin
  Size := Random (10000);  @{ the size can be determined at run time @}
  GetMem (Buffer, Size);
  @{ Do something with Buffer @}
  FreeMem (Buffer)  @{ or: FreeMem (Buffer, Size) @}
end.
@end smallexample

@subheading See also

@ref{FreeMem}, @ref{New}, @ref{Schema Types}.


@c ----------------------------------------------------------------------------


@node GetTimeStamp
@unnumberedsec GetTimeStamp
@cindex GetTimeStamp

@subheading Synopsis

@smallexample
procedure GetTimeStamp (var T: TimeStamp);
@end smallexample

@subheading Description

GetTimeStamp gets the current local date and time as a
@code{TimeStamp} record containing the Year, Month, Day, Hour,
Minute, Second, and so on.

@subheading Conforming to

@samp{GetTimeStamp} is an ISO 10206 Extended Pascal extension.

@subheading Example

Set @ref{TimeStamp}.

@subheading See also

@ref{TimeStamp}, @ref{Date}, @ref{Time}, @ref{Date And Time Routines}.


@c ----------------------------------------------------------------------------


@node goto
@unnumberedsec goto
@cindex goto

(Under construction.)

@subheading Synopsis

@smallexample
goto @var{label}
@end smallexample

@subheading Description

The @samp{goto} statement transfers control to statement with the label
@samp{label}.

@subheading Conforming to

@samp{goto} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node GT
@unnumberedsec GT
@cindex GT

(Under construction.)

@subheading Synopsis

@smallexample
function GT (S1, S2: String): Boolean;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{GT} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node GTPad
@unnumberedsec GTPad
@cindex GTPad

(Under construction.)

@subheading Synopsis

@smallexample
function GTPad (S1, S2: String): Boolean;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{GTPad} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Halt
@unnumberedsec Halt
@cindex Halt

@subheading Synopsis

@smallexample
Halt;
@end smallexample
or
@smallexample
Halt (ExitCode: Integer);
@end smallexample

@subheading Description

@samp{Halt} terminates the program with exitcode 0. If @samp{ExitCode},
is specified, it is returned by @samp{Halt} on exit.

@subheading Conforming to

@samp{Halt} is an Extended Pascal and a UCSD Pascal extension.

@subheading Example

@smallexample
program HaltDemo;
begin
  WriteLn ('This string will always be this program''s output.');
  Halt;  @{ Terminate right here and right now. @}
  WriteLn ('And this string won''t ever!')
end.
@end smallexample

@subheading See also

@ref{Break}, @ref{Continue}, @ref{Exit}, @ref{Return}, @ref{goto}.


@c ----------------------------------------------------------------------------


@node High
@unnumberedsec High
@cindex High

@subheading Synopsis

@smallexample
function High (@var{ordinal_type_or_variable}): @var{ordinal_type};
@end smallexample
or
@smallexample
function High (@var{array_type_or_variable}): @var{array_index_type};
@end smallexample
or
@smallexample
function High (@var{string_variable}): Integer;
@end smallexample

@subheading Description

For ordinal types or variables of that type, @samp{High} returns the
highest value a variable of that type can assume.

For array types or variables of that type, @samp{High} returns the
highest index a variable of that type can assume. Note: the result is of
the same type as the array index is. If the array has more than one
dimension, @samp{High} returns the highest index in the first dimension.

If the argument is a string variable, @samp{High} returns the
discriminant of the string type (i.e.@: its capacity).

@subheading Conforming to

@samp{High} is a Borland Pascal extension.

@subheading Example

@smallexample
program HighDemo;
type
  Colors = (Red, Green, Blue);
var
  Col: array [Colors] of (Love, Hope, Faithfulness);
  Foo: Colors;
  Bar: Integer;
  Baz: String (123);
begin
  Foo := High (Col);             @{ yields Blue @}
  Bar := Ord (High (Col[Foo]));  @{ yields Ord (Faithfulness), i.e., 2 @}
  Bar := High (Integer);         @{ highest possible value of `Integer' @}
  Bar := High (Baz)              @{ returns 123 @}
end.
@end smallexample

@subheading See also

@ref{Low}


@c ----------------------------------------------------------------------------


@node if
@unnumberedsec if
@cindex if

@subheading Synopsis

@smallexample
if @var{Boolean_expression} then
  @var{statement}
@end smallexample
or with an alternative statement:
@smallexample
if @var{Boolean_expression} then
  @var{statement1}
else
  @var{statement2}
@end smallexample

@subheading Description

The @samp{if @dots{} then} statement executes @var{statement1} depending
on @samp{Boolean expression} being true. If @samp{else} is specified, it
continues executing @var{statement2} instead.

@subheading Conforming to

@samp{if} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@smallexample
program IfDemo;
var
  Foo, Bar: Boolean;
begin
  Foo := True;
  Bar := False;
  if ((1 = 1) or (2 = 3)) and (Foo = not Bar) then
    begin
      @{ This is executed if either Foo is true but not Bar or vice versa @}
      WriteLn ('Either Foo or Bar is true.');
      if Bar then
        WriteLn ('You will see this text if Bar is true.')
    end
  else  @{ This whole `else' branch is not executed @}
    if 1 = 1 then
      if True = False then
        WriteLn ('This text is never written on screen.')
      else  @{ Note: This ``else'' belongs to ``if True = False'' @}
        WriteLn ('This text is never written on screen as well.')
    else  @{ Note: This ``else'' belongs to ``if 1 = 1'' @}
      WriteLn ('Nor is this.')
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{if Statement}, @ref{else}, @ref{then}


@c ----------------------------------------------------------------------------


@node Im
@unnumberedsec Im
@cindex Im

@subheading Synopsis

@smallexample
function Im (z: Complex): Real;
@end smallexample

@subheading Description
@samp{Im} extracts the imaginary part of the complex number @samp{z}.
The result is a real value.

@subheading Conforming to

@samp{Im} is an ISO 10206 Extended Pascal extension.

@subheading Example

@smallexample
program ImDemo;
var
  z: Complex;
begin
  z := Cmplx (1, 2);  @{ 1 + i * 2 @}
  WriteLn (Im (z) : 0 : 5)  @{ 2.00000 @}
end.
@end smallexample

@subheading See also

@ref{Cmplx}, @ref{Re}, @ref{Arg}.


@c ----------------------------------------------------------------------------


@node implementation
@unnumberedsec implementation
@cindex implementation

(Under construction.)

@subheading Synopsis

@subheading Description

Module or unit implementation part.

@subheading Conforming to

@samp{implementation} is an Extended Pascal and a UCSD Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node import
@unnumberedsec import
@cindex import

@subheading Synopsis

@smallexample
program @@@@fragment foo;

import
  bar1;
  bar3 (baz1 => glork1) in 'baz.pas';
  bar2 only (baz2, baz3 => glork2);
  bar4 qualified;

[...]
@end smallexample

In module:

@smallexample
module @@@@fragment Bar;

import
  bar1;
  bar3 (baz1 => glork1) in 'baz.pas';
  bar2 only (baz2, baz3 => glork2);
  bar4 qualified;

[...]
@end smallexample

@subheading Description

The reserved word @samp{import} in the @emph{import part} of a
program makes the program import an interface.

The @samp{in} above tells GPC to look for the module in the
specified file; otherwise the file name is derived from the name of
the interface by adding first @file{.p}, then @file{.pas} -- which
only works if the name of the exported interface coincides with the
file name.

The symbol @samp{=>} denotes import renaming: The entity which is
exported under the name @samp{baz1} by the interface @samp{bar3}
will be known under the new name @samp{glork1} in the program.

The @samp{only} qualifier means that only the listed identifiers
will be imported from the interface. Renaming works together with
@samp{only}, too.

The @samp{qualified} qualifier means ``qualified import'': The
imported identifiers will be accessible only trough a ``qualified
name''. The entity which is exported under the name @samp{baz2} by
the interface @samp{bar4} will be accessible as @samp{bar4.baz2}.

There must be at most one import part at the begining of a block.
Each module or function/procedure (and also main program) can have
its own import part. A single import part can import arbitrarly many
interfaces.

The interfaces needn't be exported by Extended Pascal modules but
may be UCSD/Borland Pascal units as well. GPC also allows
@samp{import} parts in units.

@subheading Conforming to

@samp{import} and modules in general are an ISO 10206 Extended
Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}, @ref{module}, @ref{unit}, @ref{uses}.


@c ----------------------------------------------------------------------------


@node in
@unnumberedsec in
@cindex in

@subheading Synopsis

As part of the @code{set} membership test, as a boolean expression:
@smallexample
@var{ordinal_value} in @var{set_expression}
@end smallexample
or, as part of a @samp{for} loop iterating through a set:
@smallexample
for @var{ordinal_variable} in @var{set_expression} do @dots{}
@end smallexample

@subheading Description

When @samp{in} is used as a membership test, it acts as a binary
operator taking @var{ordinal_value} as its left parameter and
@var{set_expression} as its right parameter and returning a boolean
result which is true if @var{set_expression} contains the element
@var{ordinal_value}.

When @samp{in} is used as part of a @samp{for} loop, it iterates
@var{ordinal_variable} over the elements contained in
@var{set_expression}, that is every @var{ordinal_value} that
would return true if tested as @code{@var{ordinal_value} in
@var{set_expression}}.

@subheading Conforming to

@samp{in} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

Set @ref{set}

@subheading See also

@ref{Keywords}, @ref{Set Operations}, @ref{set},
@ref{Exclude}, @ref{Include}, @ref{for}.


@c ----------------------------------------------------------------------------


@node Inc
@unnumberedsec Inc
@cindex Inc

@subheading Synopsis

For ordinal types:
@smallexample
procedure Inc (var x: @var{ordinal_type});
@end smallexample
or
@smallexample
procedure Inc (var x: @var{ordinal_type}; Amount: @var{and_integer_type});
@end smallexample

For pointer types:
@smallexample
procedure Inc (var p: @var{any_pointer_type});
@end smallexample
or
@smallexample
procedure Inc (var p: @var{any_pointer_type}; Amount: @var{and_integer_type});
@end smallexample

@subheading Description

For ordinal types, @samp{inc} increases the value of @samp{x} by one or
by @samp{amount} if it is given.

If the argument @samp{p} is pointing to a specified type (typed
pointer), @samp{inc} increases the address of @samp{p} by the size of
the type @samp{p} is pointing to or by @samp{amount} times that size
respectively. If @samp{p} is an untyped pointer (i.e.@: @samp{p} is of
type @ref{Pointer}), @samp{p} is increased by one.

@subheading Conforming to

@samp{Inc} is a Borland Pascal extension.
Yet application of @samp{Inc} to pointers is defined in Borland Pascal.
The combination of the second argument with application to pointers
is a GNU Pascal extension.

@subheading Example

@smallexample
program IncDemo;
var
  Foo: Integer;
  Bar: array [1 .. 5] of Integer;
  Baz: ^Integer;
begin
  Foo := 4;
  Inc (Foo, 5);      @{ yields 9 @}
  @{$X+@}            @{ Turn on extended systax @}
  Baz := @@Bar[1];   @{ Baz points to y[1] @}
  Inc (Baz, 2);      @{ Baz points to y[3] @}
end.
@end smallexample

@subheading See also

@ref{Dec}, @ref{Pred}, @ref{Succ}, @ref{Pointer Arithmetics}.


@c ----------------------------------------------------------------------------


@node Include
@unnumberedsec Include
@cindex Include

@subheading Synopsis

@smallexample
Include (@var{set_variable}, @var{ordinal_value});
@end smallexample

@subheading Description

Add (join) a single element to a set. @var{ordinal_value} must be
compatible with the base type of @var{set_variable}.
Include is equivalent to:

@smallexample
@var{set_variable} := @var{set_variable} + [@var{ordinal_value}];
@end smallexample

If @var{set_variable} already contains @var{ordinal_value},
nothing happens.

@subheading Conforming to

@samp{Include} is a Borland Pascal extension.

@subheading Example

@smallexample
program IncludeDemo;

var
  Ch: Char;
  MyCharSet: set of Char;

begin
  MyCharSet := ['P', 'N', 'L'];
  Include (MyCharSet , 'A')  @{ A, L, N, P @}
end.
@end smallexample

See other examples in @ref{set} and @ref{Set Operations}.

@subheading See also

@ref{Keywords}, @ref{Set Operations}, @ref{set}, @ref{in}, @ref{Exclude}.

@c ----------------------------------------------------------------------------


@node Index
@unnumberedsec Index
@cindex Index

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{Index} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node inherited
@unnumberedsec inherited
@cindex inherited

(Under construction.)

@subheading Synopsis

@subheading Description

Reference to methods of ancestor object types.

@subheading Conforming to

@samp{inherited} is an Object Pascal, Borland Pascal and traditional
Macintosh Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node initialization
@unnumberedsec initialization
@cindex initialization

(Under construction.)

@subheading Synopsis

@subheading Description

Unit initialization.

It is equivalent to Extended Pascal's @samp{to begin do}.

@subheading Conforming to

@samp{initialization} is a Borland Delphi extension.

@subheading Example

@subheading See also

@ref{Keywords}, @ref{finalization}, @ref{to begin do}.


@c ----------------------------------------------------------------------------


@node Initialize
@unnumberedsec Initialize
@cindex Initialize

(Under construction.)

@subheading Synopsis

@smallexample
procedure Initialize (var Aynthing);
@end smallexample

@subheading Description

@samp{Initialize} does all necessary initializations for the
parameter (e.g., setting of string and schema discriminants, and
object VMT pointers, initialization of file variables). This is
normally done automatically at the start of the lifetime of a
variable, so you need to call @samp{Initialize} only in special
situations, e.g. when you allocate a dynamic variable with
@samp{GetMem} rather than @samp{New}.

@subheading Conforming to

@samp{Initialize} is a Borland Delphi extension.

@subheading Example

@subheading See also

@ref{Finalize}, @ref{New}, @ref{GetMem}.


@c ----------------------------------------------------------------------------


@node InOutRes
@unnumberedsec InOutRes
@cindex InOutRes

(Under construction.)

@subheading Synopsis

@smallexample
var
  InOutRes: Integer;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{InOutRes} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Input
@unnumberedsec Input
@cindex Input

(Under construction.)

@subheading Synopsis

@smallexample
var
  Input: Text;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Input} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Insert
@unnumberedsec Insert
@cindex Insert

(Under construction.)

@subheading Synopsis

@smallexample
procedure Insert (Source: String; var Dest: String; Position: Integer);
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Insert} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Int
@unnumberedsec Int
@cindex Int

@subheading Synopsis

@smallexample
function Int (x: Real): Real;
@end smallexample

@subheading Description

@samp{Int} returns the integer part of a floating point number as a
floating point number. Use @samp{Trunc} to get the integer part as
an integer.

@subheading Conforming to

@samp{Int} is a UCSD Pascal extension.

@subheading Example

@smallexample
program IntDemo;

begin
  WriteLn (Frac (12.345) : 1 : 5);  @{ 0.34500 @}
  WriteLn (Int (12.345) : 1 : 5);  @{ 12.00000 @}
  WriteLn (Round (12.345) : 1);  @{ 12 @}
  WriteLn (Trunc (12.345) : 1);  @{ 12 @}

  WriteLn (Frac (-12.345) : 1 : 5);  @{ -0.34500 @}
  WriteLn (Int (-12.345) : 1 : 5);  @{ -12.00000 @}
  WriteLn (Round (-12.345) : 1);  @{ -12 @}
  WriteLn (Trunc (-12.345) : 1);  @{ -12 @}

  WriteLn (Frac (12.543) : 1 : 5);  @{ 0.54300 @}
  WriteLn (Int (12.543) : 1 : 5);  @{ 12.00000 @}
  WriteLn (Round (12.543) : 1);  @{ 13 @}
  WriteLn (Trunc (12.543) : 1);  @{ 12 @}

  WriteLn (Frac (-12.543) : 1 : 5);  @{ -0.54300 @}
  WriteLn (Int (-12.543) : 1 : 5);  @{ -12.00000 @}
  WriteLn (Round (-12.543) : 1);  @{ -13 @}
  WriteLn (Trunc (-12.543) : 1);  @{ -12 @}
end.
@end smallexample
@subheading See also

@ref{Real Types}, @ref{Real}, @ref{Frac}, @ref{Round}, @ref{Trunc}.


@c ----------------------------------------------------------------------------


@node Integer
@unnumberedsec Integer
@cindex Integer

@subheading Synopsis

@smallexample
type
  Integer  @{ built-in type @}
@end smallexample

@subheading Description

@samp{Integer} is the ``natural'' signed integer type in GNU Pascal.
On some platforms it is 32 bits wide and thus has a range of
@samp{-2147483648 .. 2147483647}. Use it whenever you need a
general-purpose signed integer type.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

In ISO Pascal, @samp{Integer} is the only built-in integer type.
(However see @ref{Subrange Types}.)

@subheading Example

@smallexample
program IntegerDemo;
var
  a: Integer;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Integer Types}, @ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node interface
@unnumberedsec interface
@cindex interface

(Under construction.)

@subheading Synopsis

@subheading Description

Module or unit interface part.

@subheading Conforming to

@samp{interface} is an Extended Pascal and a UCSD Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node interrupt
@unnumberedsec interrupt
@cindex interrupt

Not yet implemented.

@subheading Synopsis

@subheading Description

Interrupt handler declaration (not yet implemented).

@subheading Conforming to

@samp{interrupt} is a Borland Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node IOResult
@unnumberedsec IOResult
@cindex IOResult

(Under construction.)

@subheading Synopsis

@smallexample
function IOResult: Integer;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{IOResult} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node is
@unnumberedsec is
@cindex is

@subheading Synopsis

@subheading Description

Object type membership test.

@subheading Conforming to

@samp{is} is an Object Pascal and a Borland Delphi extension.

@subheading Example

@subheading See also

@ref{Keywords}, @ref{as}, @ref{TypeOf}, @ref{OOP}.


@c ----------------------------------------------------------------------------


@node label
@unnumberedsec label
@cindex label

(Under construction.)

@subheading Synopsis

@subheading Description

Label declaration for a @samp{goto} statement.

@subheading Conforming to

@samp{label} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node LastPosition
@unnumberedsec LastPosition
@cindex LastPosition

(Under construction.)

@subheading Synopsis

@smallexample
function LastPosition (var F: @var{typed_file}): @var{index_type};
@end smallexample

@subheading Description

@subheading Conforming to

@samp{LastPosition} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node LE
@unnumberedsec LE
@cindex LE

(Under construction.)

@subheading Synopsis

@smallexample
function LE (S1, S2: String): Boolean;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{LE} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Leave
@unnumberedsec Leave
@cindex Leave

@subheading Synopsis

@smallexample
Leave  @{ simple statement @}
@end smallexample

@subheading Description

With @samp{Leave} you can exit the body of the current loop
instantly. It can only be used within a @samp{while}, @samp{repeat}
or a @samp{for} loop.

@subheading Conforming to

@samp{Leave} is a Mac Pascal extension. Borland Pascal has
@samp{Break} instead.

@subheading Example

@smallexample
program LeaveDemo;
var
  Foo: Integer;
begin
  while True do
    begin
      repeat
        WriteLn ('Enter a number less than 100:');
        ReadLn (Foo);
        if Foo < 100 then
          Leave;  @{ Exits `repeat' loop @}
        WriteLn (Foo, ' is not exactly less than 100! Try again ...')
      until False;
      if Foo > 50 then
        Leave;  @{ Exits `while' loop @}
      WriteLn ('The number entered was not greater than 50.')
    end
end.
@end smallexample

@subheading See also

@ref{Loop Control Statements}, @ref{Break}, @ref{Continue},
@ref{Cycle}, @ref{Exit}, @ref{Halt}, @ref{Return}, @ref{goto}.


@c ----------------------------------------------------------------------------


@node Length
@unnumberedsec Length
@cindex Length

(Under construction.)

@subheading Synopsis

@smallexample
function Length (S: String): Integer;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Length} is an Extended Pascal and a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node LEPad
@unnumberedsec LEPad
@cindex LEPad

(Under construction.)

@subheading Synopsis

@smallexample
function LEPad (S1, S2: String): Boolean;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{LEPad} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node library
@unnumberedsec library
@cindex library

Not yet implemented.

@subheading Synopsis

@subheading Description

Library declaration.

@subheading Conforming to

@samp{library} is a Borland Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node Ln
@unnumberedsec Ln
@cindex Ln

@subheading Synopsis

@smallexample
function Ln (x: Real): Real;
@end smallexample
or
@smallexample
function Ln (z: Complex): Complex;
@end smallexample

@subheading Description

The natural logarith @samp{Ln} is the logarithm with base e, where e
is the Euler number e = Exp (1) = 2.718281828@dots{}

@subheading Conforming to

The function @samp{Ln} is defined in ISO 7185 Pascal; its
application to complex values is defined in ISO 10206 Extended
Pascal.

@subheading Example

@smallexample
program LnDemo;
var
  z: Complex;
begin
  z := Cmplx (1, 1);
  z := Ln (z)  @{ yields Ln (SqRt (2)) + i * Pi / 4 @}
               @{ since Ln (i * x) = Ln Abs (x) + i * Arg (x) @}
end.
@end smallexample

@subheading See also


@c ----------------------------------------------------------------------------


@node LoCase
@unnumberedsec LoCase
@cindex LoCase

(Under construction.)

@subheading Synopsis

@smallexample
function LoCase (Ch: Char): Char;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{LoCase} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node LongBool
@unnumberedsec LongBool
@cindex LongBool

@subheading Synopsis

@smallexample
type
  LongBool = Boolean attribute (Size = BitSizeOf (LongInt));
@end smallexample

@subheading Description

The intrinsic @samp{LongBool} represents boolean values, but
occupies the same memory space as a @samp{LongInt}.  It is used when
you need to define a parameter or record that conforms to some
external library or system specification.

@subheading Conforming to

@samp{LongBool} is a Borland Pascal extension.

@subheading Example

@smallexample
program LongBoolDemo;
var
  a: LongBool;
begin
  LongInt (a) := 1;
  if a then WriteLn ('Ord (True) = 1')
end.
@end smallexample

@subheading See also

@ref{Boolean (Intrinsic)}, @ref{Boolean}, @ref{True}, @ref{False},
@ref{CBoolean}, @ref{ByteBool}, @ref{ShortBool}, @ref{MedBool},
@ref{WordBool}, @ref{LongestBool}.

@c ----------------------------------------------------------------------------


@node LongCard
@unnumberedsec LongCard
@cindex LongCard

@subheading Synopsis

@smallexample
type
  LongCard = Cardinal attribute (Size = BitSizeOf (LongInt));
@end smallexample

@subheading Description

@samp{LongCard} is an unsigned integer type which is longer than
@samp{Cardinal}. On some platforms it is 64 bits wide and thus has
a range of @samp{0 .. 18446744073709551615}.

@samp{LongCard} in GNU Pascal is compatible to
@samp{long long unsigned int} in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{LongCard} is a GNU Pascal extension.

@subheading Example

@smallexample
program LongCardDemo;
var
  a: LongCard;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node LongestBool
@unnumberedsec LongestBool
@cindex LongestBool

@subheading Synopsis

@smallexample
type
  LongestBool = Boolean attribute (Size = BitSizeOf (LongestInt));
@end smallexample

@subheading Description

The intrinsic @samp{LongestBool} represents boolean values, but
occupies the same memory space as a @samp{LongestInt}.  It is used
when you need to define a parameter or record that conforms to some
external library or system specification.

@subheading Conforming to

@samp{LongestBool} is a GNU Pascal extension.

@subheading Example

@smallexample
program LongestBoolDemo;
var
  a: LongestBool;
begin
  LongestInt (a) := 1;
  if a then WriteLn ('Ord (True) = 1')
end.
@end smallexample

@subheading See also

@ref{Boolean (Intrinsic)}, @ref{Boolean}, @ref{True}, @ref{False},
@ref{CBoolean}, @ref{ByteBool}, @ref{ShortBool}, @ref{MedBool},
@ref{WordBool}, @ref{LongBool}.

@c ----------------------------------------------------------------------------


@node LongestCard
@unnumberedsec LongestCard
@cindex LongestCard

@subheading Synopsis

@smallexample
type
  LongestCard = Cardinal attribute (Size = BitSizeOf (LongestInt));
@end smallexample

@subheading Description

@samp{LongestCard} is GPC's longest-possible unsigned integer type.
Currently, this is the same as @ref{LongCard}.
On some platforms it is 64 bits wide and thus has
a range of @samp{0 .. 18446744073709551615}.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{LongestCard} is a GNU Pascal extension.

@subheading Example

@smallexample
program LongestCardDemo;
var
  a: LongestCard;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node LongestInt
@unnumberedsec LongestInt
@cindex LongestInt

@subheading Synopsis

@smallexample
type
  LongestInt = LongInt;  @{ might get bigger than LongInt someday @}
@end smallexample

@subheading Description

@samp{LongestInt} is GPC's longest-possible signed integer type.
Currently, this is the same as @ref{LongInt}. On some platforms it
is 64 bits wide and thus has a range of @samp{-9223372036854775808
.. 9223372036854775807}.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{LongestInt} is a GNU Pascal extension.

@subheading Example

@smallexample
program LongestIntDemo;
var
  a: LongestInt;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node LongestReal
@unnumberedsec LongestReal
@cindex LongestReal

(Under construction.)

@subheading Synopsis

@smallexample
type
  LongestReal = LongReal;  @{ might get bigger than LongReal someday @}
@end smallexample

@subheading Description

@subheading Conforming to

@samp{LongestReal} is a GNU Pascal extension.

@subheading Example

@smallexample
program LongestRealDemo;
var
  a: LongestReal;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample


@subheading See also


@c ----------------------------------------------------------------------------


@node LongestWord
@unnumberedsec LongestWord
@cindex LongestWord

@subheading Synopsis

@smallexample
type
  LongestWord = LongestCard;
@end smallexample

@subheading Description

@samp{LongestWord} is GPC's longest-possible unsigned integer type.
Currently, this is the same as @ref{LongWord}. On some platforms it
is 64 bits wide and thus has a range of @samp{0 ..
18446744073709551615}. (It is the same as @ref{LongestCard}.)

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{LongestWord} is a GNU Pascal extension.

@subheading Example

@smallexample
program LongestWordDemo;
var
  a: LongestWord;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{LongestCard}, @ref{Integer Types}, @ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node LongInt
@unnumberedsec LongInt
@cindex LongInt

@subheading Synopsis

@smallexample
type
  LongInt  @{ built-in type @}
@end smallexample

@subheading Description

@samp{LongInt} is a signed integer type which is longer than
@samp{Integer}. On some platforms it is 64 bits wide and thus has
a range of @samp{-9223372036854775808 .. 9223372036854775807}.

@samp{LongInt} in GNU Pascal is compatible to @samp{long long int}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{LongInt} is a Borland Pascal extension. Borland Pascal
defines @samp{LongInt} as a 32-bit signed integer type
(@ref{Integer} in GNU Pascal).

@subheading Example

@smallexample
program LongIntDemo;
var
  a: LongInt;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node LongReal
@unnumberedsec LongReal
@cindex LongReal

(Under construction.)

@subheading Synopsis

@smallexample
type
  LongReal  @{ built-in type @}
@end smallexample

@subheading Description

@subheading Conforming to

@samp{LongReal} is a GNU Pascal extension.

@subheading Example

@smallexample
program LongRealDemo;
var
  a: LongReal;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also


@c ----------------------------------------------------------------------------


@node LongWord
@unnumberedsec LongWord
@cindex LongWord

@subheading Synopsis

@smallexample
type
  LongWord = LongCard;
@end smallexample

@subheading Description

@samp{LongWord} is an unsigned integer type which is larger than
@samp{Word}. On some platforms it is 64 bits wide and thus has
a range of @samp{0 .. 18446744073709551615}. It is the same as
@ref{LongCard}.

@samp{LongWord} in GNU Pascal is compatible to
@samp{long long unsigned int} in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{LongWord} is a GNU Pascal extension.

@subheading Example

@smallexample
program LongWordDemo;
var
  a: LongWord;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{LongCard}, @ref{Integer Types}, @ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node Low
@unnumberedsec Low
@cindex Low

@subheading Synopsis

@smallexample
function Low (@var{ordinal_type_or_variable}): @var{ordinal_type};
@end smallexample
or
@smallexample
function Low (@var{array_type_or_variable}): @var{array_element_type};
@end smallexample
or
@smallexample
function Low (@var{string_variable}): Integer;
@end smallexample

@subheading Description

For ordinal types or variables of that type, @samp{Low} returns the
lowest value a variable of that type can assume.

For array types or variables of that type, @samp{Low} returns the
lowest index a variable of that type can assume. Note: the result is
of the same type as the array index is. If the array has more than
one dimension, @samp{Low} returns the lowest index in the first
dimension.

If the argument is a string variable, @samp{Low} returns one.

@subheading Conforming to

@samp{Low} is a Borland Pascal extension.

@subheading Example

@smallexample
program LowDemo;
type
  Colors = (Red, Green, Blue);
var
  Col: array [12 .. 20] of Colors;
  Foo: 12 .. 20;
  Bar: Integer;
begin
  Foo := Low (Col);            @{ returns 12 @}
  Col[Foo] := Low (Col[Foo]);  @{ returns Red @}
  Bar := Low (Integer)         @{ lowest possible value of `Integer' @}
end.
@end smallexample

@subheading See also

@ref{High}


@c ----------------------------------------------------------------------------


@node LT
@unnumberedsec LT
@cindex LT

(Under construction.)

@subheading Synopsis

@smallexample
function LT (S1, S2: String): Boolean;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{LT} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node LTPad
@unnumberedsec LTPad
@cindex LTPad

(Under construction.)

@subheading Synopsis

@smallexample
function LTPad (S1, S2: String): Boolean;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{LTPad} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Mark
@unnumberedsec Mark
@cindex Mark

(Under construction.)

@subheading Synopsis

@smallexample
procedure Mark (var P: Pointer);
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Mark} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Max
@unnumberedsec Max
@cindex Max

(Under construction.)

@subheading Synopsis

@smallexample
function Max (x1, x2: @var{ordinal_or_real_type}): @var{same_type};
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Max} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node MaxChar
@unnumberedsec MaxChar
@cindex MaxChar

(Under construction.)

@subheading Synopsis

@subheading Description

The value of @code{MaxChar} is the largest value of @code{Char}.

@subheading Conforming to

@samp{MaxChar} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node MaxInt
@unnumberedsec MaxInt
@cindex MaxInt

(Under construction.)

@subheading Synopsis

@subheading Description

The @code{MaxInt} constant defines the maximum value of
@code{Integer}. This constant is a built-in compiler value.

@subheading Conforming to

@samp{MaxInt} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node MaxReal
@unnumberedsec MaxReal
@cindex MaxReal

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{MaxReal} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also

@ref{MinReal}.

@c ----------------------------------------------------------------------------


@node MedBool
@unnumberedsec MedBool
@cindex MedBool

@subheading Synopsis

@smallexample
type
  MedBool = Boolean attribute (Size = BitSizeOf (MedInt));
@end smallexample

@subheading Description

The intrinsic @samp{MedBool} represents boolean values, but occupies
the same memory space as a @samp{MedInt}.  It is used when you need
to define a parameter or record that conforms to some external
library or system specification.

@subheading Conforming to

@samp{MedBool} is a GNU Pascal extension.

@subheading Example

@smallexample
program MedBoolDemo;
var
  a: MedBool;
begin
  MedInt (a) := 1;
  if a then WriteLn ('Ord (True) = 1')
end.
@end smallexample

@subheading See also

@ref{Boolean (Intrinsic)}, @ref{Boolean}, @ref{True}, @ref{False},
@ref{CBoolean}, @ref{ByteBool}, @ref{ShortBool}, @ref{WordBool},
@ref{LongBool}, @ref{LongestBool}.

@c ----------------------------------------------------------------------------


@node MedCard
@unnumberedsec MedCard
@cindex MedCard

@subheading Synopsis

@smallexample
type
  MedCard = Cardinal attribute (Size = BitSizeOf (MedInt));
@end smallexample

@subheading Description

@samp{MedCard} is an unsigned integer type which is not smaller than
@samp{Cardinal}. On some platforms it actually is the same as
@samp{Cardinal} and 32 bits wide and thus has a range of
@samp{0 .. 4294967295}.

@samp{MedCard} in GNU Pascal is compatible to @samp{long unsigned int}
in GNU C. This compatibility is the reason why @samp{MedCard} exists.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{MedCard} is a GNU Pascal extension.

@subheading Example

@smallexample
program MedCardDemo;
var
  a: MedCard;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node MedInt
@unnumberedsec MedInt
@cindex MedInt

@subheading Synopsis

@smallexample
type
  MedInt  @{ built-in type @}
@end smallexample

@subheading Description

@samp{MedInt} is a signed integer type which is not smaller than
@samp{Integer}. On some platforms it actually is the same as
@samp{Integer} and 32 bits wide and thus has a range of
@samp{-2147483648 .. 2147483647}.

@samp{MedInt} in GNU Pascal is compatible to @samp{long int}
in GNU C. This compatibility is the reason why @samp{MedInt} exists.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{MedInt} is a GNU Pascal extension.

@subheading Example

@smallexample
program MedIntDemo;
var
  a: MedInt;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node MedReal
@unnumberedsec MedReal
@cindex MedReal

(Under construction.)

@subheading Synopsis

@smallexample
type
  MedReal = Real;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{MedReal} is a GNU Pascal extension.

@subheading Example

@smallexample
program MedRealDemo;
var
  a: MedReal;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample


@subheading See also


@c ----------------------------------------------------------------------------


@node MedWord
@unnumberedsec MedWord
@cindex MedWord

@subheading Synopsis

@smallexample
type
  MedWord = MedCard;
@end smallexample

@subheading Description

@samp{MedWord} is an unsigned integer type which is not smaller than
@samp{Word}. On some platforms it actually is the same as @samp{Word}
and 32 bits wide and thus has a range of @samp{0 .. 4294967295}. It is
the same as @ref{MedCard}.

@samp{MedWord} in GNU Pascal is compatible to @samp{long unsigned int}
in GNU C. This compatibility is the reason why @samp{MedWord} exists.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{MedWord} is a GNU Pascal extension.

@subheading Example

@smallexample
program MedWordDemo;
var
  a: MedWord;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{MedCard}, @ref{Integer Types}, @ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node Min
@unnumberedsec Min
@cindex Min

(Under construction.)

@subheading Synopsis

@smallexample
function Min (x1, x2: @var{ordinal_or_real_type}): @var{same_type};
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Min} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node MinReal
@unnumberedsec MinReal
@cindex MinReal

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{MinReal} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also

@ref{MaxReal}.

@c ----------------------------------------------------------------------------


@node MkDir
@unnumberedsec MkDir
@cindex MkDir

@subheading Synopsis

@smallexample
procedure MkDir (Directory: String);
@end smallexample

@subheading Description

@samp{MkDir} creates the given @var{Directory}, if its argument is a
valid parameter to the related operating system's function.
Otherwise a runtime error is caused.

@subheading Conforming to

@samp{MkDir} is a Borland Pascal extension.

@subheading Example

@smallexample
program MkDirDemo;
var
  Foo: String (127);
begin
  WriteLn ('Enter directory name to create:');
  ReadLn (Foo);
  @{$I-@}  @{ Don't abort program on error @}
  MkDir (Foo);
  if IOResult <> 0 then
    WriteLn ('Directory `', Foo, ''' could not be created')
  else
    WriteLn ('Okay')
end.
@end smallexample

@subheading See also

@ref{ChDir}, @ref{RmDir}


@c ----------------------------------------------------------------------------


@node mod
@unnumberedsec mod
@cindex mod

(Under construction.)

@subheading Synopsis

@smallexample
operator mod (p, q: Integer) = r: Integer;
@end smallexample

@subheading Description

Integer remainder operator.

@subheading Conforming to

@samp{mod} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node module
@unnumberedsec module
@cindex module

(Under construction.)

@subheading Synopsis

@subheading Description

EP style or PXSC style module.

@subheading Conforming to

@samp{module} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node Move
@unnumberedsec Move
@cindex Move

(Under construction.)

@subheading Synopsis

@smallexample
procedure Move (const Source; var Dest; Count: Integer);
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Move} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node MoveLeft
@unnumberedsec MoveLeft
@cindex MoveLeft

(Under construction.)

@subheading Synopsis

@smallexample
procedure MoveLeft (const Source; var Dest; Count: Integer);
@end smallexample

@subheading Description

@subheading Conforming to

@samp{MoveLeft} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node MoveRight
@unnumberedsec MoveRight
@cindex MoveRight

(Under construction.)

@subheading Synopsis

@smallexample
procedure MoveRight (const Source; var Dest; count: Integer);
@end smallexample

@subheading Description

@subheading Conforming to

@samp{MoveRight} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node name
@unnumberedsec name
@cindex name

(Under construction.)

@subheading Synopsis

@var{procedure/function_header}; external name @var{name};

@var{procedure/function_header}; attribute (name = @var{name});

or

@var{variable_declaration}; external name @var{name};

@var{variable_declaration}; attribute (name = @var{name});

or

unit @var{Name}; attribute (name = @var{name});

@subheading Description

The @samp{name} directive declares the external name of a procedure,
function or variable. It can be used after @samp{external} or within
@samp{attribute}.

This directive declares the external name of a procedure, function
or variable. The external name of the routine is given explicitly as
a case-sensitive constant string expression. This is useful when
interfacing with libraries written in other languages.

With this extension it is possible to access all external functions,
for example the X11 interface functions, and not only those written
in lowercase.

@samp{name} can also be applied to units and module interfaces. In
this case it denotes the @emph{prefix} prepended to the external
name of the initializer of the unit: While it is normally called
@samp{init_Modulename}, it is called
@samp{init_@var{name}_Modulename} when @samp{name} is given.

This is not of interest under normal circumstances since the
initializers are called automatically. It can help avoiding
conflicts when there are several units of the same name within one
program. Again, this does not happen normally, but e.g., when a
program uses a unit/module that has the same name as one of the
units the RTS consists of: The RTS uses @samp{GPC} as the name for
its units to avoid conflicts.

@c @@@@@@@@
In the future, a @samp{name} directive applied to units, modules and
programs (the latter is recognized syntactically already, but has no
effect yet) will also affect the default external name of routines
and variables which have no @samp{name} directive themselves. Again,
this is mostly useful for libraries etc., and will not be necessary
for normal units, modules and programs.

@subheading Conforming to

@samp{name} is a Borland Pascal extension. @samp{attribute} and the
application of @samp{name} to units, modules and programs are GNU
Pascal extensions.

@subheading Example

@smallexample
program NameDemo;

@{ Make two variables aliases of each other by using `name'.
  This is not good style. If you must have aliases for any reason,
  `absolute' declarations may be the lesser evil ... @}
var
  Foo: Integer; attribute (name = 'Foo_Bar');
  Bar: Integer; external name 'Foo_Bar';

@{ A function from the C library @}
function PutS (Str: CString): Integer; external name 'puts';

var
  Result: Integer;
begin
  Result := PutS ('Hello World!');
  WriteLn ('puts wrote ', Result, ' characters (including a newline).');
  Foo := 42;
  WriteLn ('Foo = ', Foo);
  Bar := 17;
  WriteLn ('Setting Bar to 17.');
  WriteLn ('Now, Foo = ', Foo, '!!!')
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{attribute}, @ref{external},
@ref{Importing Libraries from Other Languages}.


@c ----------------------------------------------------------------------------


@node NE
@unnumberedsec NE
@cindex NE

(Under construction.)

@subheading Synopsis

@smallexample
function NE (S1, S2: String): Boolean;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{NE} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node near
@unnumberedsec near
@cindex near

@subheading Synopsis

@subheading Description

The @samp{near} directive can be appended to a procedure or function
heading but is ignored by GPC. It is there for Borland compatibility,
only. (Since the GNU compilers provide a flat memory model, the
distinction between @samp{near} and @samp{far} pointers is void.)

@subheading Conforming to

@samp{near} is a Borland Pascal extension.

@subheading Example

@smallexample
program NearDemo;

var
  p: procedure;

@{$W no-near-far@}  @{ Don't warn about the uselessness of `near' @}

procedure Foo; near;  @{ `near' has no effect in GPC @}
begin
  WriteLn ('Foo')
end;

begin
  p := Foo;  @{ Works, despite the `near'. @}
  p
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{far}.


@c ----------------------------------------------------------------------------


@node NEPad
@unnumberedsec NEPad
@cindex NEPad

(Under construction.)

@subheading Synopsis

@smallexample
function NEPad (S1, S2: String): Boolean;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{NEPad} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node New
@unnumberedsec New
@cindex New

(Under construction.)

@subheading Synopsis

@smallexample
procedure New (var P: @var{any_Pointer});
@end smallexample
or
@smallexample
procedure New (var P: @var{Pointer_to_a_variant_record}; @var{tag_fields});
@end smallexample
or
@smallexample
procedure New (var P: @var{Pointer_to_a_schema}; @var{discriminants});
@end smallexample
or
@smallexample
procedure New (var P: @var{Pointer_to_an_object}; @var{constructor_call});
@end smallexample
or
@smallexample
function New (@var{any_Pointer_type}): @var{same_type};
@end smallexample
or
@smallexample
function New (@var{variant_record_Pointer_type};
              @var{tag_fields}): @var{same_type};
@end smallexample
or
@smallexample
function New (@var{schema_Pointer_type};
              @var{discriminants}): @var{same_type};
@end smallexample
or
@smallexample
function New (@var{object_Pointer_type};
              @var{constructor_call}): @var{same_type};
@end smallexample

@subheading Description

@subheading Conforming to

@samp{New} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node NewCString
@unnumberedsec NewCString
@cindex NewCString

(Under construction.)

@subheading Synopsis

@smallexample
function NewCString (const S: String): CString;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{NewCString} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node nil
@unnumberedsec nil
@cindex nil

@subheading Synopsis

@samp{nil} is a predefined constant

@subheading Description

@samp{nil} is a predefined pointer constant that indicates an
unassigned pointer. ``nil'' stands for ``not in list''. @emph{Every}
pointer type can be associated with this constant.

@subheading Conforming to

@samp{nil} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@smallexample
program NilDemo;
const
  NodeNum = 10;
type
  PNode = ^TNode;
  TNode = record
    Key: Integer;
    Next: PNode
  end;
var
  Root, Node: PNode;
  Foo: Integer;
begin
  New (Root);
  Root^.Key := 1;             @{ Set root key @}
  Node := Root;
  for Foo := 2 to NodeNum do  @{ Create linked list with NODE_NUM nodes @}
    begin
      New (Node^.Next);
      Node := Node^.Next;
      Node^.Key := Foo        @{ Set key @}
    end;
  Node^.Next := nil;          @{ Mark end of linked list @}
  @{ Shorten list by removing its first element until list is empty @}
  while Root <> nil do
    begin
      Node := Root;
      WriteLn ('Current key:', Root^.Key);
      Root := Root^.Next;
      Dispose (Node);
      Node := nil             @{ Indicate old node is not assigned @}
    end
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{Assigned}, @ref{Pointer}


@c ----------------------------------------------------------------------------


@node not
@unnumberedsec not
@cindex not

(Under construction.)

@subheading Synopsis

@smallexample
operator not (b1, b2: Boolean) = Result: Boolean;
@end smallexample
or
@smallexample
operator not (i1, i2: @var{integer_type}) = Result: @var{integer_type};
@end smallexample

@subheading Description

Boolean or bitwise negation operator.

@subheading Conforming to

@samp{not} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node Null
@unnumberedsec Null
@cindex Null

@subheading Synopsis

@smallexample
var
  Null: Void absolute 0;
@end smallexample

@subheading Description

@samp{Null} is a predefined variable at address @samp{nil}.
@samp{Null} can be passed as a ``void'' argument to a procedure,
function or operator expecting a ``var'' parameter. @emph{Note}:
Make sure they can handle this case, otherwise this is likely to
cause an exception and the program will be terminated. Since
@samp{Null} is an L-value, it can be taken as ``nil-reference''.

@subheading Conforming to

@samp{Null} is a Borland Delphi extension.

@subheading Example

@smallexample
program NullDemo;
type
  PString = ^String;
var
  Com1: String (25) = 'This is an amazing number';
  Com2: String (25) = 'This is a boring number';

procedure FooBar (Foo: Integer; var Comment: PString);
begin
  if Odd (Foo) then
    WriteLn ('FooBar:', Foo, ' is odd')
   else
    WriteLn ('FooBar:', Foo, ' is even');
  if @@Comment <> nil then
    if not Odd (Foo) then
      Comment := @@Com1
    else
      Comment := @@Com2
end;

var
  S: String (25);
  P: PString value @@S;

begin
  @{ FooBar allows you to leave out variables
    for any information you might not need @}
  FooBar (1, Null);
  @{ But FooBar is flexible, after all @}
  FooBar (6, P);
  WriteLn ('FooBar said about 6: `', P^, '''')
end.
@end smallexample

@subheading See also

@ref{nil}


@c ----------------------------------------------------------------------------


@node object
@unnumberedsec object
@cindex object

@subheading Synopsis

@subheading Description

The keyword @samp{object} is used to declare a new object type:

@smallexample
type
  foo = object
    a: Integer;
    constructor Init;
    procedure Bar (x: Integer); virtual;
  end;
@end smallexample

(For a longer example, see @ref{OOP}.)

@subheading Conforming to

GNU Pascal follows the Borland Pascal 7.0 object model.

ISO Pascal does not support Object-oriented programming. There is an
ANSI draft for an ``Object Pascal'' language which is not yet
supported by GPC, but planned. The Delphi language, also called
``Object Pascal'' by Borland, is currently not supported by GPC
either.

@subheading Example

@subheading See also

@ref{Keywords}, @ref{OOP}, @ref{record}.


@c ----------------------------------------------------------------------------


@node Odd
@unnumberedsec Odd
@cindex Odd

@subheading Synopsis

@smallexample
function Odd (i: Integer): Boolean;
@end smallexample

@subheading Description

@samp{Odd} checks the parity of its argument @samp{i}. It returns
@samp{True} if the argument is odd, @samp{False} if it is even.

@subheading Conforming to

@samp{Odd} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@smallexample
program OddDemo;
var
  Foo: Integer;
begin
  Write ('Please enter an odd number: ');
  ReadLn (Foo);
  if not Odd (Foo) then
    WriteLn ('Odd''s not even! Something''s odd out there ...')
  else
    WriteLn (Foo, ' is pretty odd.')
end.
@end smallexample

@subheading See also


@c ----------------------------------------------------------------------------


@node of
@unnumberedsec of
@cindex of

(Under construction.)

@subheading Synopsis

@subheading Description

Part of an @samp{array}, @samp{set} or typed @samp{file} type
declaration, a @samp{case} statement, a variant @samp{record} type
or a @samp{type of} type inquiry.

@subheading Conforming to

@samp{of} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node on
@unnumberedsec on
@cindex on

Not yet implemented.

@subheading Synopsis

@subheading Conforming to

@samp{on} is a Borland Delphi extension.

@subheading Example

@subheading See also

@ref{Keywords}.

@c ----------------------------------------------------------------------------


@node only
@unnumberedsec only
@cindex only

(Under construction.)

@subheading Synopsis

@subheading Description

Import specification.

@subheading Conforming to

@samp{only} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node operator
@unnumberedsec operator
@cindex operator

(Under construction.)

@subheading Synopsis

@subheading Description

Operator declaration.

@subheading Conforming to

@samp{operator} is PASCAL_SC extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node or
@unnumberedsec or
@cindex or

@subheading Synopsis

@smallexample
operator or (operand1, operand2: Boolean) = Result: Boolean;
@end smallexample
or
@smallexample
operator or (operand1, operand2: @var{integer_type}) = Result: @var{integer_type};
@end smallexample
or
@smallexample
procedure or (var operand1: @var{integer_type}; operand2: @var{integer_type});
@end smallexample

@subheading Description

In GNU Pascal, @samp{or} has three built-in meanings:

@enumerate

@item
Logical ``or'' between two @samp{Boolean}-type expressions.
The result of the operation is of @samp{Boolean} type.

By default, @samp{or} acts as a short-circuit operator in GPC: If
the first operand is @samp{True}, the second operand is not
evaluated because the result is already known to be @samp{True}. You
can change this to complete evaluation using the
@samp{--no-short-circuit} command-line option or the @samp{@{$B+@}}
compiler directive.

@item
Bitwise ``or'' between two integer-type expressions.
The result is of the common integer type of both expressions.

@item
Use as a ``procedure'': @samp{operand1} is ``or''ed bitwise with
@samp{operand2}; the result is stored in @samp{operand1}.

@end enumerate

@subheading Conforming to

The logical @samp{or} operator is defined in ISO 7185 Pascal.

According to ISO, you cannot rely on @samp{or} being a short-circuit
operator. On the other hand, GPC's default behaviour does @emph{not}
contradict the ISO standard. (See @ref{or_else}.) However, since it
seems to be a de-facto standard among ISO Pascal compilers to
evaluate both operands of @samp{or}, GPC switches to
@samp{--no-short-circuit} mode if one of the language dialect
options selecting ISO Pascal, for instance @samp{--extended-pascal},
is given. Use @samp{--short-circuit} to override.

Use of @samp{or} as a bitwise operator for integers is a Borland
Pascal extension.

Use of @samp{or} as a ``procedure'' is a GNU Pascal extension.

@subheading Example

@smallexample
program OrDemo;
var
  a, b, c: Integer;
begin
  if (a = 0) or (b = 0) then  @{ logical `or' @}
    c := 1
  else if (a or b) = 0 then  @{ bitwise `or' @}
    c := 2
  else
    or (c, a)  @{ same as `c := c or a' @}
end.
@end smallexample

Note the difference between the logical @samp{or} and the bitwise
@samp{or}: When @samp{a} is 2 and @samp{b} is 4, then @samp{a or b}
is 6. @strong{Beware:} @samp{a or b = 0} happens to mean the same as
@samp{(a = 0) and (b = 0)}. (Note the @samp{and}!)

Since bitwise @samp{or} has a higher priority than the @samp{=}
operator, parentheses are needed in @samp{if (a = 0) or (b = 0)}
because otherwise @samp{0 or b} would be calculated first, and the
remainder would cause a parse error.

@subheading See also

@ref{Keywords}, @ref{and}, @ref{xor}, @ref{Operators}.


@c ----------------------------------------------------------------------------


@node Ord
@unnumberedsec Ord
@cindex Ord

@subheading Synopsis

@smallexample
function Ord (@var{ordinal_value}): Integer;
@end smallexample

@subheading Description

@samp{Ord} returns the ordinal value of any ordinal variable or
constant. For characters, this would be the ASCII code corresponding
to the character. For enumerated types, this would be the ordinal
value of the constant or variable (remember that ordinal value of
enumerated constants start from zero).

@subheading Conforming to

@samp{Ord} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@smallexample
program OrdDemo;
var
  Ch: Char;
  Day: (Monday, Tuesday, Wednesday, Thursday, Friday);
begin
  Ch := 'A';
  WriteLn (Ord (Ch));  @{ 65 @}
  Day := Thursday;
  WriteLn (Ord (Day));  @{ 3 @}
end.
@end smallexample

@subheading See also

@ref{Character Types}, @ref{Ordinal Types}, @ref{Chr}, @ref{Char}

@c ----------------------------------------------------------------------------


@node or else
@unnumberedsec or else
@cindex or else

@subheading Synopsis

@smallexample
@{ `or else' is built in. A user-defined operator cannot consist of
   two words. @}
operator or else (operand1, operand2: Boolean) = Result: Boolean;
@end smallexample

@subheading Description

@samp{or else} is an alias for the short-circuit logical operator
@samp{or_else}.

@subheading Conforming to

While @samp{or_else} is defined in ISO 10206 Extended Pascal,
@samp{or else} is a GNU Pascal extension.

@subheading Example

@smallexample
program OrElseDemo;
var
  a: Integer;
begin
  ReadLn (a);
  if (a = 0) or else (100 div a > 42) then  @{ This is safe. @}
    WriteLn ('100 div a > 42')
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{or_else}, @ref{or}, @ref{and then}.


@c ----------------------------------------------------------------------------


@node or_else
@unnumberedsec or_else
@cindex or_else

@subheading Synopsis

@smallexample
operator or_else (operand1, operand2: Boolean) = Result: Boolean;
@end smallexample

@subheading Description

The @samp{or_else} short-circuit logical operator performs the same
operation as the logical operator @samp{or}. But while the ISO
standard does not specify anything about the evaluation of the
operands of @samp{or} -- they may be evaluated in any order, or not
at all -- @samp{or_else} has a well-defined behaviour: It evaluates
the first operand. If the result is @samp{True}, @samp{or_else}
returns @samp{True} without evaluating the second operand. If it is
@samp{False}, the second operand is evaluated and returned.

GPC by default treats @samp{or} and @samp{or_else} exactly the same.
If you want, for some reason, to have both operands of @samp{or}
evaluated completely, you must assign both to temporary variables
and then use @samp{or} -- or @samp{or_else}, it does not matter.

@subheading Conforming to

@samp{or_else} is an ISO 10206 Extended Pascal extension.

Some people think that the ISO standard requires both operands of
@samp{or} to be evaluated. This is false. What the ISO standard
@emph{does} say is that you cannot rely on a certain order of
evaluation of the operands of @samp{or}; in particular things like
the following program can crash according to ISO Pascal, although
they cannot crash when compiled with GNU Pascal running in default
mode.

@smallexample
program OrBug;
var
  a: Integer;
begin
  ReadLn (a);
  if (a = 0) or (100 div a > 42) then  @{ This is *not* safe! @}
    WriteLn ('You''re lucky. But the test could have crashed ...')
end.
@end smallexample

@subheading Example

@smallexample
program Or_ElseDemo;
var
  a: Integer;
begin
  ReadLn (a);
  if (a = 0) or_else (100 div a > 42) then  @{ This is safe. @}
    WriteLn ('100 div a > 42')
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{or else}, @ref{or}, @ref{and_then}.


@c ----------------------------------------------------------------------------


@node otherwise
@unnumberedsec otherwise
@cindex otherwise

@subheading Synopsis

Default @samp{case} branch as part of the @code{case} @dots{}
@code{otherwise} statement:
@smallexample
case @var{expression} of
  @var{selector}: @var{statement};
  @dots{}
  @var{selector}: @var{statement}
otherwise  @{ ``else'' instead of ``otherwise'' is allowed @}
  @var{statement};
  @dots{}
  @var{statement}
end
@end smallexample

Use in a structured value of @samp{array} type:
@smallexample
[@var{index1}: @var{value1}; @var{index2}: @var{value2}
 otherwise @var{value_otherwise}]
@end smallexample

@subheading Description

@samp{otherwise} starts a series of statements which is executed if no
selector matches @var{expression}. In this situation, @samp{else} is a
synonym for @code{otherwise}.

@samp{otherwise} also defines the default value in an Extended
Pascal structured values of array type.

@subheading Conforming to

@samp{otherwise} is an ISO 10206 Extended Pascal extension.

@subheading Example

@smallexample
program OtherwiseDemo;

var
  i: Integer;
  a: array [1 .. 10] of Integer value [1: 2; 4: 5 otherwise 3];

begin
  for i := 1 to 10 do
    case a[i] of
      2:        WriteLn ('a[', i, '] has value two.');
      3:        WriteLn ('a[', i, '] has value three.');
      otherwise WriteLn ('a[', i, '] has neither value two nor three.')
    end
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{case Statement}, @ref{case}, @ref{else}.


@c ----------------------------------------------------------------------------


@node Output
@unnumberedsec Output
@cindex Output

(Under construction.)

@subheading Synopsis

@smallexample
var
  Output: Text;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Output} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node overload
@unnumberedsec overload
@cindex overload

Not yet implemented.

@subheading Synopsis

@subheading Conforming to

@samp{overload} is a Borland Delphi extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node override
@unnumberedsec override
@cindex override

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{override} directive is defined in OOE draft and supported by
Delphi and Mac Pascal

@subheading Example

@subheading See also

@ref{Keywords}.

@c ----------------------------------------------------------------------------


@node Pack
@unnumberedsec Pack
@cindex Pack

(Under construction.)

@subheading Synopsis

@subheading Description

@smallexample
procedure Pack (Source: @var{unpacked_array};
                FirstElement: @var{index_type};
                var Dest: @var{packed_array});
@end smallexample

@subheading Conforming to

@samp{Pack} is defined in ISO 7185 Pascal and supported by all known
Pascal variants except UCSD/Borland Pascal and its variants.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node packed
@unnumberedsec packed
@cindex packed

@subheading Synopsis

@subheading Description

@samp{packed} is a reserved word. According to ISO 7185
Pascal it can precede @samp{array} and @samp{record} type
definitions to indicate that memory usage should be minimized for
variables of this type, possibly at the expense of loss of speed.

As a GNU Pascal extension, @samp{packed} can also be applied to
@ref{Subrange Types}.

@subheading Conforming to

The reserved word @samp{packed} is defined in ISO 7185 Pascal.

According to ISO standard, only @emph{packed} arrays of char with lower
bound 1 qualify as strings of fixed length. GNU Pascal neither requires
@samp{packed} nor the lower bound of 1 here.

@subheading Example

@smallexample
program PackedDemo;

type
  MonthInt = packed 1 .. 12;  @{ needs one byte @}
  FastMonthInt = 1 .. 12;     @{ needs e.g. four bytes @}

  FixString10 = packed array [1 .. 10] of Char;
  FoxyString10 = array [0 .. 9] of Char;

  Flags = packed array [1 .. 32] of Boolean;  @{ needs four bytes @}

  Int15 = Integer attribute (Size = 15);
  DateRec = packed record
    Day: 1 .. 31;       @{ five bits @}
    Month: MonthInt;    @{ four bits @}
    Year: Int15         @{ 15 bits = -16384 .. 16383 @}
  end;

  Dates = array [1 .. 1000] of DateRec;

var
  S: FixString10;
  T: FoxyString10;

begin
  S := 'Hello!';  @{ blank padded @}
  WriteLn (S);

  T := 'GNU Pascal';  @{ GPC extension: this also works. @}
  WriteLn (T)
end.
@end smallexample

@samp{DateRec} has 24 bits = 3 bytes in total; @samp{Dates} has 3000 bytes.

@subheading See also

@ref{Keywords}, @ref{Pack}, @ref{Unpack}, @ref{SizeOf},
@ref{AlignOf}, @ref{BitSizeOf}.


@c ----------------------------------------------------------------------------


@node Page
@unnumberedsec Page
@cindex Page

(Under construction.)

@subheading Synopsis

@smallexample
procedure Page ([var F: Text]);
@end smallexample
or
@smallexample
procedure Page;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Page} is defined in ISO 7185 Pascal, but missing in Borland
Pascal.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node PAnsiChar
@unnumberedsec PAnsiChar
@cindex PAnsiChar

(Under construction.)

@subheading Synopsis

@smallexample
type
  PAnsiChar = ^AnsiChar;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{PAnsiChar} is a Borland Delphi extension.

@subheading Example

@smallexample
program PAnsiCharDemo;
var
  s: PAnsiChar;
begin
  s := 'Hello, world!';
  @{$X+@}
  WriteLn (s)
end.
@end smallexample

@subheading See also


@c ----------------------------------------------------------------------------


@node ParamCount
@unnumberedsec ParamCount
@cindex ParamCount

@subheading Synopsis

@smallexample
function ParamCount: Integer;
@end smallexample

@subheading Description

@samp{ParamCount} returns the number of command-line arguments given
to the program. @samp{ParamCount} returns 0 if no arguments have
been given to the program; the name of the program as an implicit
argument is not counted.

@subheading Conforming to

@samp{ParamCount} is a Borland Pascal extension.

@subheading Example

@smallexample
program ParamCountDemo;

var
  i: Integer;

begin
  WriteLn ('You have invoked this program with ',
           ParamCount, ' arguments.');
  WriteLn ('These are:');
  for i := 1 to ParamCount do
    WriteLn (ParamStr (i))
end.
@end smallexample

@subheading See also

@ref{ParamStr}.


@c ----------------------------------------------------------------------------


@node ParamStr
@unnumberedsec ParamStr
@cindex ParamStr

(Under construction.)

@subheading Synopsis

@smallexample
function ParamStr (ParmNumber: Integer): String;
@end smallexample

@subheading Description

@strong{Please note:} If you are using the Dos (DJGPP) or MS-Windows
(mingw32) version of GPC and are getting unexpected results from
@samp{ParamStr}, please see the section ``Command-line Arguments
Handling in DJGPP'' of the DJGPP FAQ list.

@subheading Conforming to

@samp{ParamStr} is a Borland Pascal extension.

@subheading Example

@smallexample
program ParamStrDemo;

var
  i: Integer;

begin
  WriteLn ('You have invoked this program with ',
           ParamCount, ' arguments.');
  WriteLn ('These are:');
  for i := 1 to ParamCount do
    WriteLn (ParamStr (i))
end.
@end smallexample

@subheading See also


@c ----------------------------------------------------------------------------


@node PChar
@unnumberedsec PChar
@cindex PChar

(Under construction.)

@subheading Synopsis

@smallexample
type
  PChar = ^Char;
@end smallexample
or
@smallexample
type
  PChar = CString;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{PChar} is a Borland Pascal extension.

@subheading Example

@smallexample
program PCharDemo;
var
  s: PChar;
begin
  s := 'Hello, world!';
  @{$X+@}
  WriteLn (s)
end.
@end smallexample

@subheading See also


@c ----------------------------------------------------------------------------


@node Pi
@unnumberedsec Pi
@cindex Pi

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{Pi} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node PObjectType
@unnumberedsec PObjectType
@cindex PObjectType

@subheading Synopsis

@smallexample
type
  InternalSignedSizeType =
    Integer attribute (Size = BitSizeOf (SizeType));
  PObjectType = ^const record
    Size:        SizeType;
    NegatedSize: InternalSignedSizeType;
    Parent:      PObjectType;
    Name:        ^const String
  end;
@end smallexample

(Note: @samp{^record} is not valid syntax. It is just used here in
the explanation because the record type has no name by itself.
Because of the added method pointers (see below), there is no useful
usage of the record type.)

@subheading Description

@samp{PObjectType} is the type returned by @samp{TypeOf} and
required by @samp{SetType}. In fact, the record pointed to (the
@dfn{VMT}, ``virtual method table'') also contains pointers to the
virtual methods. However, these are not declared in
@samp{PObjectType} because they vary from object type to object
type. The fields declared here are those that are shared by every
object type and can be accessed via @samp{TypeOf}.

@samp{Size} contains the size of the object type, @samp{NegatedSize}
contains the size negated (for optional runtime checks).
@samp{Parent} contains a pointer to the parent type's VMT (or nil if
the type has no parent). @samp{Name} points to a string containing
the type's name.

For abstract object types, @samp{Size} contains 0 and
@samp{NegatedSize} contains -1, so they will always fail the runtime
check.

@subheading Conforming to

@samp{PObjectType} is a GNU Pascal extension.

@subheading Example

@subheading See also

@ref{TypeOf}, @ref{SetType}, @ref{OOP}.


@c ----------------------------------------------------------------------------


@node Pointer
@unnumberedsec Pointer
@cindex Pointer

(Under construction.)

@subheading Synopsis

@smallexample
type
  Pointer  @{ built-in type @}
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Pointer} is a Borland Pascal extension.

@subheading Example

@smallexample
program PointerDemo;
var
  a: Integer;
  b: Boolean;
  p: Pointer;
begin
  p := nil;
  p := @@a;
  p := @@b
end.
@end smallexample

@subheading See also


@c ----------------------------------------------------------------------------


@node Polar
@unnumberedsec Polar
@cindex Polar

(Under construction.)

@subheading Synopsis

@smallexample
function Polar (rho, phi: Real): Complex;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Polar} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Pos
@unnumberedsec Pos
@cindex Pos

(Under construction.)

@subheading Synopsis

@smallexample
function Pos (SearchPattern, Source: String): Integer;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Pos} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Position
@unnumberedsec Position
@cindex Position

(Under construction.)

@subheading Synopsis

@smallexample
function Position (var F: @var{typed_file}): @var{index_type};
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Position} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node pow
@unnumberedsec pow
@cindex pow

(Under construction.)

@subheading Synopsis

@smallexample
operator pow (base: Real; exponent: Integer) = power: Real;
@end smallexample
or
@smallexample
operator pow (base: Complex; exponent: Integer) = power: Complex;
@end smallexample

@subheading Description

Exponentiation operator with integer exponent.

@subheading Conforming to

@samp{pow} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node Pred
@unnumberedsec Pred
@cindex Pred

@subheading Synopsis

@smallexample
function Pred (i: @var{ordinal_type}): @var{ordinal_type};
@end smallexample
or
@smallexample
function Pred (i: @var{ordinal_type}; j: @var{and_integer_type}): @var{ordinal_type};
@end smallexample

or, with extended syntax (@samp{--extended-syntax} or @samp{@{$X+@}}),

@smallexample
function Pred (p: @var{Pointer_type}): @var{Pointer_type};
@end smallexample
or
@smallexample
function Pred (p: @var{Pointer_type}; j: @var{and_integer_type}): @var{Pointer_type};
@end smallexample

@subheading Description

Returns the predecessor of the @var{ordinal_type} value @samp{i},
or, if the second argument @samp{j} is given, its @samp{j}th
predecessor. For integer values @samp{i}, this is @samp{i - 1} (or
@samp{i - j}). (No, @samp{Pred} does @emph{not} work faster than
plain subtraction. Both are optimized the same way, often to a
single machine instruction.)

If extended syntax is on, the argument may also be a pointer value.
In this case, the address is decremented by the size of the variable
pointed to, or, if @samp{j} is given, by @samp{j} times the size of
the variable pointed to. If @samp{p} points to an element of an
array, the returned pointer will point to the (@samp{j}th) previous
element of the array.


@subheading Conforming to

The @samp{Pred} function is defined in ISO 7185 Pascal. The optional
second parameter is defined in ISO 10206 Extended Pascal.
Application of @samp{Pred} to pointers is defined in Borland Pascal.
The combination of the second argument with application to pointers
is a GNU Pascal extension.

@subheading Example

@smallexample
program PredDemo;

type
  Metasyntactical = (foo, bar, baz);

var
  m: Metasyntactical;
  c: Char;
  a: array [1 .. 7] of Integer;
  p: ^Integer;

begin
  m := Pred (bar);     @{ foo @}
  c := Pred ('Z', 2);  @{ 'X' @}
  a[1] := 42;
  a[4] := Pred (a[1]);     @{ 41 @}
  a[5] := Pred (a[4], 3);  @{ 38 @}
  @{$X+@}
  p := @@a[5];
  p := Pred (p);     @{ now p points to a[4] @}
  p := Pred (p, 3);  @{ now p points to a[1] @}
end.
@end smallexample

@subheading See also

@ref{Succ}, @ref{Dec}, @ref{Pointer Arithmetics}.


@c ----------------------------------------------------------------------------


@node private
@unnumberedsec private
@cindex private

(Under construction.)

@subheading Synopsis

@subheading Description

GPC currently accepts but ignores the @samp{private} directive
in object type declarations.

@subheading Conforming to

@samp{private} is a Borland Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}, @ref{protected}, @ref{public}, @ref{published}.


@c ----------------------------------------------------------------------------


@node procedure
@unnumberedsec procedure
@cindex procedure

(Under construction.)

@subheading Synopsis

@subheading Description

Procedure declaration.

@subheading Conforming to

@samp{procedure} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node program
@unnumberedsec program
@cindex program

(Under construction.)

@subheading Synopsis

@subheading Description

Start of a Pascal program.

@subheading Conforming to

@samp{program} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node property
@unnumberedsec property
@cindex property

Not yet implemented.

@subheading Synopsis

@subheading Description

Object properties.

@subheading Conforming to

@samp{property} is an Object Pascal and a Borland Delphi extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node protected
@unnumberedsec protected
@cindex protected

(Under construction.)

@subheading Synopsis

@subheading Description

The Extended Pascal meaning of @samp{protected} is supported by GPC.

GPC currently accepts but ignores the @samp{protected} directive
in object type declarations.

@subheading Conforming to

Extended Pascal and Borland Pascal, but with different meanings.

@subheading Example

@subheading See also

@ref{Keywords}, @ref{const}, @ref{import}, @ref{private},
@ref{public}, @ref{published}.


@c ----------------------------------------------------------------------------


@node PtrCard
@unnumberedsec PtrCard
@cindex PtrCard

(Under construction.)

@subheading Synopsis

@smallexample
type
  PtrCard = Cardinal attribute (Size = BitSizeOf (Pointer));
@end smallexample

@subheading Description

An unsigned integer type of the same size as a pointer.

@subheading Conforming to

@samp{PtrCard} is a GNU Pascal extension.

@subheading Example

@smallexample
program PtrCardDemo;
var
  a: PtrCard;
  p: Pointer;
begin
  GetMem (p, 10);
  a := PtrCard (p);
  Inc (a);
  p := Pointer (a)
end.
@end smallexample

@subheading See also


@c ----------------------------------------------------------------------------


@node PtrDiffType
@unnumberedsec PtrDiffType
@cindex PtrDiffType

(Under construction.)

@subheading Synopsis

@smallexample
type
  PtrDiffType  @{ built-in type @}
@end smallexample

@subheading Description

@samp{PtrDiffType} is a (signed) integer type to represent the
difference between two positions in memory. It is not needed except
for rather low-level purposes.

@subheading Conforming to

@samp{PtrDiffType} is a GNU Pascal extension.

@subheading Example

@smallexample
program PtrDiffTypeDemo;
var
  a: array [1 .. 10] of Integer;
  d: PtrDiffType;
  p, q: ^Integer;
begin
  p := @@a[1];
  q := @@a[4];
  @{$X+@}
  d := q - p
end.
@end smallexample

@subheading See also


@c ----------------------------------------------------------------------------


@node PtrInt
@unnumberedsec PtrInt
@cindex PtrInt

(Under construction.)

@subheading Synopsis

@smallexample
type
  PtrInt = Integer attribute (Size = BitSizeOf (Pointer));
@end smallexample

@subheading Description

A signed integer type of the same size as a pointer.

@subheading Conforming to

@samp{PtrInt} is a GNU Pascal extension.

@subheading Example

@smallexample
program PtrIntDemo;
var
  a: PtrInt;
  p: Pointer;
begin
  GetMem (p, 10);
  a := PtrInt (p);
  Inc (a);
  p := Pointer (a)
end.
@end smallexample


@subheading See also


@c ----------------------------------------------------------------------------


@node PtrWord
@unnumberedsec PtrWord
@cindex PtrWord

(Under construction.)

@subheading Synopsis

@smallexample
type
  PtrWord = PtrCard;
@end smallexample

@subheading Description

An unsigned integer type of the same size as a pointer.

@subheading Conforming to

@samp{PtrWord} is a GNU Pascal extension.

@subheading Example

@smallexample
program PtrWordDemo;
var
  a: PtrWord;
  p: Pointer;
begin
  GetMem (p, 10);
  a := PtrWord (p);
  Inc (a);
  p := Pointer (a)
end.
@end smallexample


@subheading See also

@ref{PtrCard}, @ref{Integer Types}.


@c ----------------------------------------------------------------------------


@node public
@unnumberedsec public
@cindex public

(Under construction.)

@subheading Synopsis

@subheading Description

GPC currently accepts but ignores the @samp{public} directive in
object type declarations.

@subheading Conforming to

@samp{public} is a Borland Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}, @ref{private}, @ref{protected}, @ref{published}.


@c ----------------------------------------------------------------------------


@node published
@unnumberedsec published
@cindex published

(Under construction.)

@subheading Synopsis

@subheading Description

GPC currently accepts but ignores the @samp{published} directive
in object type declarations.

@subheading Conforming to

@samp{published} is a Borland Delphi extension.

@subheading Example

@subheading See also

@ref{Keywords}, @ref{private}, @ref{protected}, @ref{public}.


@c ----------------------------------------------------------------------------


@node Put
@unnumberedsec Put
@cindex Put

(Under construction.)

@subheading Synopsis

@smallexample
procedure Put (var F: @var{typed_file});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Put} is defined in ISO 7185 Pascal and supported by all known
Pascal variants except UCSD/Borland Pascal and its variants.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node qualified
@unnumberedsec qualified
@cindex qualified

(Under construction.)

@subheading Synopsis

@subheading Description

Import specification.

@subheading Conforming to

@samp{qualified} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node raise
@unnumberedsec raise
@cindex raise

Not yet implemented.

@subheading Synopsis

@subheading Conforming to

@samp{overload} is a Borland Delphi extension.

@subheading Example

@subheading See also

@ref{Keywords}.

@c ----------------------------------------------------------------------------


@node Random
@unnumberedsec Random
@cindex Random

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{Random} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Randomize
@unnumberedsec Randomize
@cindex Randomize

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{Randomize} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Re
@unnumberedsec Re
@cindex Re

@subheading Synopsis

@smallexample
function Re (z: Complex): Real;
@end smallexample

@subheading Description

@samp{Re} extracts the real part of the complex number @samp{z}.

@subheading Conforming to

@samp{Re} is an ISO 10206 Extended Pascal extension.

@subheading Example

@smallexample
program ReDemo;
var
  z: Complex;
begin
  z := Cmplx (1, 2);
  WriteLn (Re (z) : 0 : 5)
end.
@end smallexample

@subheading See also

@ref{Cmplx}, @ref{Im}, @ref{Arg}


@c ----------------------------------------------------------------------------


@node Read
@unnumberedsec Read
@cindex Read

(Under construction.)

@subheading Synopsis

@smallexample
procedure Read (var F: @var{typed_file}; @var{variable});
@end smallexample
or
@smallexample
procedure Read (var F: Text; @var{variables});
@end smallexample
or
@smallexample
procedure Read (@var{variables});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Read} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node ReadLn
@unnumberedsec ReadLn
@cindex ReadLn

(Under construction.)

@subheading Synopsis

@smallexample
procedure ReadLn (var F: Text; @var{variables});
@end smallexample
or
@smallexample
procedure ReadLn (@var{variables});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{ReadLn} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node ReadStr
@unnumberedsec ReadStr
@cindex ReadStr

(Under construction.)

@subheading Synopsis

@smallexample
procedure ReadStr (const S: String; @var{variables});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{ReadStr} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also

@c ----------------------------------------------------------------------------

@node ReadString
@unnumberedsec ReadString
@cindex ReadString


@subheading Description

@samp{ReadString} is an alternative name for @samp{ReadStr}

@subheading Conforming to

@samp{ReadString} is a Mac Pascal extension.

@subheading See also

@ref{ReadStr}

@c ----------------------------------------------------------------------------


@node Real
@unnumberedsec Real
@cindex Real

(Under construction.)

@subheading Synopsis

@smallexample
type
  Real  @{ built-in type @}
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Real} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@smallexample
program RealDemo;
var
  a: Real;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Real Types}, @ref{Int}, @ref{Frac}, @ref{Round}, @ref{Trunc}.

@c ----------------------------------------------------------------------------


@node record
@unnumberedsec record
@cindex record

@subheading Synopsis

In type definitions:
@smallexample
@var{record_type_identifier} = record
  @var{field_identifier}: @var{type_definition}
  @dots{}
  @var{field_identifier}: @var{type_definition}
end;
@end smallexample

or, with a variant part,

@smallexample
@var{record_type_identifier} = record
  @var{field_identifier}: @var{type_definition}
  @dots{}
  @var{field_identifier}: @var{type_definition}
  case bar: @var{variant_type} of
    @var{selector}: (@var{field_declarations});
    @var{selector}: (@var{field_declarations});
    @dots{}
end;
@end smallexample

or, without a variant selector field,

@smallexample
@var{record_type_identifier} = record
  @var{field_identifier}: @var{type_definition}
  @dots{}
  @var{field_identifier}: @var{type_definition}
  case @var{variant_type} of
    @var{selector}: (@var{field_declarations});
    @var{selector}: (@var{field_declarations});
    @dots{}
end;
@end smallexample

@subheading Description

The reserved word @samp{record} starts the definition of a new record type.

Records can be @samp{packed} to save memory usage at the expense of speed.

The variants of a variant record may -- but are not required to --
share one location in memory (inside the record).

Sometimes variant records are used to emulate type casting in
ISO 7185 Pascal. This is in fact a violation of the
standard and not portable. There is intentionally @emph{no}
possibility in ISO 7185 Pascal to emulate type casting.

@subheading Conforming to

The reserved word @samp{record} and record types are defined in
ISO 7185 Pascal.

According to ISO Pascal, the variant type must be an identifier.
GNU Pascal, like UCSD and Borland Pascal, also allows a subrange here.

Subranges in the variant fields, e.g. @code{case Integer of 2 .. 5},
are a GPC extension.

@subheading Example

@smallexample
program RecordDemo;

type
  FooPtr = ^Foo;

  Foo = record
    Bar: Integer;
    NextFoo: FooPtr;
    case Choice: 1 .. 3 of
      1: (a: Integer);  @{ These three choices may share @}
      2: (b: Real);     @{ one location in memory. @}
      3: (c: Char;
          d: Boolean);
  end;

  Int5 = Integer attribute (Size = 5);
  SmallFoo = packed record
    b: 0 .. 3;
    a: Int5;
    r: Boolean
  end;  @{ needs 1 byte @}

var
  f: Foo;

begin
  f.b := 3.14;
  WriteLn (f.a)  @{ yields some strange number which is part of the   @}
                 @{ internal representation of the real number `f.b'. @}
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{packed}, @ref{case Statement}


@c ----------------------------------------------------------------------------


@node Release
@unnumberedsec Release
@cindex Release

(Under construction.)

@subheading Synopsis

@smallexample
procedure Release (P: Pointer);
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Release} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Rename
@unnumberedsec Rename
@cindex Rename

(Under construction.)

@subheading Synopsis

@smallexample
procedure Rename (var F: @var{any_file}; NewName: String);
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Rename} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node repeat
@unnumberedsec repeat
@cindex repeat

@subheading Synopsis

@smallexample
repeat
  @var{statement};
  @dots{}
  @var{statement};
until @var{boolean_expression};
@end smallexample

@subheading Description

The @samp{repeat @dots{} until} statement declares a loop. For
further description see @ref{repeat Statement}.

@subheading Conforming to

@samp{repeat} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@smallexample
program RepeatDemo;
var
  Number, Sum: Integer;
begin
  WriteLn ('Black Jack for beginners.');
  WriteLn ('You can choose your cards yourself. :-)');
  Sum := 0;
  repeat
    Write ('Your card (number)? ');
    ReadLn (Number);
    Inc (Sum, Number);
    WriteLn ('You have ', Sum, '.')
  until Sum >= 21;
  if Sum = 21 then
    WriteLn ('You win!')
  else
    WriteLn ('You lose.')
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{while Statement}, @ref{for Statement}.


@c ----------------------------------------------------------------------------


@node Reset
@unnumberedsec Reset
@cindex Reset

(Under construction.)

@subheading Synopsis

@smallexample
procedure Reset (var F: @var{any_file}; [FileName: String;]
                                    [BlockSize: Cardinal]);
@end smallexample

@subheading Description

@samp{Reset} opens an existing file for reading. The file pointer is
positioned at the beginning of the file.

Like @samp{Rewrite}, @samp{Append} and @samp{Extend} do,
@samp{Reset} accepts an optional second parameter for the name of
the file in the filesystem and a third parameter for the block size
of the file. The third parameter is allowed only (and by default
also required) for untyped files. For details, see @ref{Rewrite}.

@subheading Conforming to

@samp{Reset} is defined in ISO 7185 Pascal.
The @samp{BlockSize} parameter is a Borland Pascal extension.
The @samp{FileName} parameter is a GNU Pascal extension.
@c @@@@ Other compilers?

@subheading Example

@smallexample
program ResetDemo;
var
  Sample: Text;
  s: String (42);
begin
  Rewrite (Sample);  @{ Open an internal file for writing @}
  WriteLn (Sample, 'Hello, World!');
  Reset (Sample);  @{ Open it again for reading @}
  ReadLn (Sample, s);
  WriteLn (s);
  Close (Sample)
end.
@end smallexample

@subheading See also

@ref{Assign}, @ref{Rewrite}, @ref{Append}, @ref{Extend}.

@c ----------------------------------------------------------------------------


@node resident
@unnumberedsec resident
@cindex resident

Not yet implemented.

@subheading Synopsis

@subheading Description

Library export specification.

@subheading Conforming to

@samp{resident} is a Borland Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node restricted
@unnumberedsec restricted
@cindex restricted

(Under construction.)

@subheading Synopsis

@subheading Description

Restricted type specification.

@subheading Conforming to

@samp{restricted} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node Result
@unnumberedsec Result
@cindex Result

(Under construction.)

@subheading Synopsis

@subheading Description

@strong{Please note:} GPC @emph{deactivates} @samp{Result} by
default because it is incompatible with standard program semantics.
Only in @samp{--delphi} mode or with the option
@samp{--implicit-result}, it is activated. Explicit result variables
provide a safer alternative that works in default mode.

@subheading Conforming to

@samp{Result} is a Borland Delphi extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Return
@unnumberedsec Return
@cindex Return

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{Return} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node ReturnAddress
@unnumberedsec ReturnAddress
@cindex ReturnAddress

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{ReturnAddress} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Rewrite
@unnumberedsec Rewrite
@cindex Rewrite

(Under construction.)

@subheading Synopsis

@smallexample
procedure Rewrite (var F: @var{any_file}; [FileName: String;]
                                    [BlockSize: Cardinal]);
@end smallexample

@subheading Description

@samp{Rewrite} opens a file for writing. If the file does not exist,
it is created. The file pointer is positioned at the beginning of
the file.

Like @samp{Reset}, @samp{Append} and @samp{Extend} do,
@samp{Rewrite} accepts an optional second and third parameter.

The second parameter can specify the name of the file in the
filesystem. If it is omitted, the following alternative ways can be
used to specify the name. There are so many different ways in order
to be compatible to the idiosyncrasies of as many other Pascal
compilers as possible. (If you know about yet other ways, let us
know @dots{})

@itemize @minus
@item The @samp{Assign} procedure (@pxref{Assign})
@item The @samp{Bind} procedure (@pxref{Bind})
@end itemize

The following ways are only available if the file is external, i.e.
a global variable which is mentioned in the program header.
Otherwise, the file will be internal, i.e. get no name in the file
system (it may get a name temporarily, but will then be erased
automatically again). This is useful to store some data and read
them back within a program without the need for permanent storage.

@itemize @minus
@item A command-line parameter of the form
@samp{--gpc-rts=-n@var{f}:@var{name}} where @var{f} is the
identifier of the file variable.
@item If the file was mentioned in the program header and the option
@samp{--transparent file names} (@pxref{GPC Command Line Options})
was set, the file name will be identical to the identifier converted
to lower-case.
@item Otherwise, the user will be prompted for a file name.
@end itemize

The last optional parameter determines the block size of the file.
It is valid only for untyped files. Often 1 is a reasonable value
here. However, the existence of this parameter is a BP compatibility
feature, and in BP it defaults to 128 because of historic misdesign.
Therefore, GPC requires this parameter to be present. In
@samp{--borland-pascal} mode, it makes it optional (like BP does),
but warns about the strange default if omitted.

@subheading Conforming to

@samp{Rewrite} is defined in ISO 7185 Pascal.
The @samp{BlockSize} parameter is a Borland Pascal extension.
The @samp{FileName} parameter is a GNU Pascal extension.
@c @@@@ Other compilers?

@subheading Example

@smallexample
program RewriteDemo;
var
  Sample: Text;
begin
  Assign (Sample, 'sample.txt');
  Rewrite (Sample);
  WriteLn (Sample, 'Hello, World!');
  Close (Sample)
end.
@end smallexample

@subheading See also

@ref{Assign}, @ref{Reset}, @ref{Append}, @ref{Extend}, @ref{Update}.


@c ----------------------------------------------------------------------------


@node RmDir
@unnumberedsec RmDir
@cindex RmDir

@subheading Synopsis

@smallexample
procedure RmDir (Directory: String);
@end smallexample

@subheading Description

@samp{RmDir} removes the given @var{Directory} if its argument is a valid
parameter to the related operating system's function. Otherwise a
runtime error is caused.

@subheading Conforming to

@samp{RmDir} is a Borland Pascal extension.

@subheading Example

@smallexample
program RmDirDemo;
var
  Foo: String (127);
begin
  WriteLn ('Enter directory name to remove: ');
  ReadLn (Foo);
  @{$I-@}  @{ Don't abort on I/O errors @}
  RmDir (Foo);
  if IOResult <> 0 then
    WriteLn ('Directory ', Foo, ' could not be removed.')
  else
    WriteLn ('Okay.')
end.
@end smallexample

@subheading See also

@ref{ChDir}, @ref{MkDir}


@c ----------------------------------------------------------------------------


@node Round
@unnumberedsec Round
@cindex Round

@subheading Synopsis

@smallexample
function Round (x: Real): Integer;
@end smallexample

@subheading Description

@samp{Round} returns the nearest integer to @samp{x}. The result is of
type integer. In the case of equidistance, the result is machine-dependent
(or depends on the behaviour of the processor).

@subheading Conforming to

@samp{Round} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@smallexample
program RoundDemo;
var
  Foo: Real;
begin
  Foo := 9.876543;
  WriteLn (Round (Foo));  @{ Prints 10 @}
  Foo := 3.456789;
  WriteLn (Round (Foo));  @{ Prints 3 @}

  WriteLn (Frac (12.345) : 1 : 5);  @{ 0.34500 @}
  WriteLn (Int (12.345) : 1 : 5);  @{ 12.00000 @}
  WriteLn (Round (12.345) : 1);  @{ 12 @}
  WriteLn (Trunc (12.345) : 1);  @{ 12 @}

  WriteLn (Frac (-12.345) : 1 : 5);  @{ -0.34500 @}
  WriteLn (Int (-12.345) : 1 : 5);  @{ -12.00000 @}
  WriteLn (Round (-12.345) : 1);  @{ -12 @}
  WriteLn (Trunc (-12.345) : 1);  @{ -12 @}

  WriteLn (Frac (12.543) : 1 : 5);  @{ 0.54300 @}
  WriteLn (Int (12.543) : 1 : 5);  @{ 12.00000 @}
  WriteLn (Round (12.543) : 1);  @{ 13 @}
  WriteLn (Trunc (12.543) : 1);  @{ 12 @}

  WriteLn (Frac (-12.543) : 1 : 5);  @{ -0.54300 @}
  WriteLn (Int (-12.543) : 1 : 5);  @{ -12.00000 @}
  WriteLn (Round (-12.543) : 1);  @{ -13 @}
  WriteLn (Trunc (-12.543) : 1);  @{ -12 @}
end.
@end smallexample

@subheading See also

@ref{Real Types}, @ref{Real}, @ref{Int}, @ref{Frac}, @ref{Trunc}.


@c ----------------------------------------------------------------------------


@node RunError
@unnumberedsec RunError
@cindex RunError

(Under construction.)

@subheading Synopsis

@smallexample
procedure RunError (ErrorCode: Integer);
@end smallexample

@subheading Description

@subheading Conforming to

@samp{RunError} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Seek
@unnumberedsec Seek
@cindex Seek

(Under construction.)

@subheading Synopsis

@smallexample
procedure Seek (var F: @var{typed_file}; NewPosition: @var{index_type});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Seek} is a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node SeekEOF
@unnumberedsec SeekEOF
@cindex SeekEOF

(Under construction.)

@subheading Synopsis

@smallexample
function SeekEOF ([var F: Text]): Boolean;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{SeekEOF} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node SeekEOLn
@unnumberedsec SeekEOLn
@cindex SeekEOLn

(Under construction.)

@subheading Synopsis

@smallexample
function SeekEOLn ([var F: Text]): Boolean;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{SeekEOLn} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node SeekRead
@unnumberedsec SeekRead
@cindex SeekRead

(Under construction.)

@subheading Synopsis

@smallexample
procedure SeekRead (var F: @var{typed_file}; NewPosition: @var{index_type});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{SeekRead} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node SeekUpdate
@unnumberedsec SeekUpdate
@cindex SeekUpdate

(Under construction.)

@subheading Synopsis

@smallexample
procedure SeekUpdate (var F: @var{typed_file}; NewPosition: @var{index_type});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{SeekUpdate} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node SeekWrite
@unnumberedsec SeekWrite
@cindex SeekWrite

(Under construction.)

@subheading Synopsis

@smallexample
procedure SeekWrite (var F: @var{typed_file}; NewPosition: @var{index_type});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{SeekWrite} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node segment
@unnumberedsec segment
@cindex segment

Not yet implemented.

@subheading Synopsis

@subheading Description

Segment specification.

@subheading Conforming to

@samp{segment} is a UCSD Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node Self
@unnumberedsec Self
@cindex Self

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{Self} is an Object Pascal and a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node set
@unnumberedsec set
@cindex set

@subheading Synopsis

In type definitions:
@smallexample
set of @var{ordinal_type}  @{ built-in type class @}
@end smallexample

@subheading Description

A set contains zero or more elements from an ordinal type, e.g.
Char, a subrange of Char, or a subrange of an enumerated type or
integers. The elements of a sets do not have any ordering (that is a
set containing 'B' and 'A' is the same as a set containing 'A' and
'B'), nor can an element be included more than once. Sets simply
store the information about which elements are included in the set.

@subheading Conforming to

@samp{set} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@smallexample
program SetDemo;

type
  TCharSet = set of Char;

var
  Ch: Char;
  MyCharSet: TCharSet;
begin
  MyCharSet := ['P','N','L'];
  if 'A' in MyCharSet then
    WriteLn ('Wrong: A in set MyCharSet')
  else
    WriteLn ('Right: A is not in set MyCharSet');
  Include (MyCharSet, 'A');  @{ A, L, N, P @}
  Exclude (MyCharSet, 'N');  @{ A, L, P @}
  MyCharSet := MyCharSet + ['B','C'];  @{ A, B, C, L, P @}
  MyCharSet := MyCharSet - ['C','D'];  @{ A, B, L, P @}
  WriteLn ('set MyCharSet contains:');
  for Ch in MyCharSet do
    WriteLn (Ch);
end.
@end smallexample

Set also @ref{Set Operations} or examples of some of the many
set operations.

@subheading See also

@ref{Keywords}, @ref{Set Operations}, @ref{in},
@ref{Exclude}, @ref{Include}.


@c ----------------------------------------------------------------------------


@node SetFileTime
@unnumberedsec SetFileTime
@cindex SetFileTime

@smallexample
procedure SetFileTime (var f: @var{any_file};
                       AccessTime, ModificationTime: UnixTimeType);
@end smallexample

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{SetFileTime} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node SetLength
@unnumberedsec SetLength
@cindex SetLength

@subheading Synopsis

@smallexample
procedure SetLength (var S: String; NewLength: Integer);
@end smallexample

@subheading Description

@samp{SetLength} explicitly assigns a new length @samp{NewLength} to
the string parameter @samp{S}. The contents of the string elements
(characters) are @emph{not} changed; if the operation increases the
length of the string, the characters appended at the end are
@emph{undefined}.

@subheading Conforming to

@samp{SetLength} is a Borland Delphi 2.0 extension.

@subheading Example

@smallexample
program SetLengthDemo;

var
  S: String (26);

begin
  S := 'Hello, world!';
  SetLength (S, Length ('Hello'));
  WriteLn (S);                                           @{ 'Hello' @}

  SetLength (S, 26);
  WriteLn (S);                     @{ 'Hello, world!(%$xy"!#&~+(/]' @}
                            @{ undefined characters ^^^^^^^^^^^^^^  @}

  @{ SetLength (S, 42);  GPC detects this overflow at compile time. @}
end.
@end smallexample

@subheading See also

@ref{Length}, @ref{String}.


@c ----------------------------------------------------------------------------


@node SetType
@unnumberedsec SetType
@cindex SetType

@subheading Synopsis

@smallexample
procedure SetType (var SomeObject; VMT: PObjectType);
@end smallexample

@subheading Description

The procedure @samp{SetType} explicitly assigns a value to the
implicit VMT field of an object. This is normally done implicitly
when a constructor is called.

You can use this to write a polymorphic I/O routine which reads an
object from a file. In this case, you cannot reasonably use
@samp{New} to allocate the storage, but you @samp{GetMem} it and
initialize the object manually using @samp{SetType} before calling
the constructor explicitly.

The only values you should assign to an object via @samp{SetType}
are actual VMT pointers that were obtained via @samp{TypeOf}. In
particular, declaring a record like the one shown in the description
of @samp{PObjectType} and assigning a pointer to it to an object via
@samp{SetType} will usually not work because the virtual method
pointers are missing.

Since @samp{SetType} is a dangerous feature, it yields a warning
unless @samp{@{$X+@}} is given.

@subheading Conforming to

@samp{SetType} is a GNU Pascal extension.

@subheading Example

@smallexample
program SetTypeDemo;

type
  BasePtr = ^BaseObj;

  BaseObj = object
    constructor Load;
  end;

  ChildObj = object (BaseObj)
    constructor Load;
  end;

constructor BaseObj.Load;
begin
end;

constructor ChildObj.Load;
begin
end;

@{$X+@}

@{ This is somewhat fragmentary code. @}
function GetObject (var InputFile: File) = Result: BasePtr;
const
  VMTTable: array [1 .. 2] of PObjectType =
    (TypeOf (BaseObj), TypeOf (ChildObj));
var
  Size: Cardinal;
  TypeID: Integer;
  VMT: PObjectType;
begin
  @{ Read the size of the object from some file and store it in `Size'. @}
  BlockRead (InputFile, Size, SizeOf (Size));

  @{ Allocate memory for the object. @}
  GetMem (Result, Size);

  @{ Read some ID from some file. @}
  BlockRead (InputFile, TypeID, SizeOf (TypeID));

  @{ Look up the `VMT' from some table. @}
  @{ Explicit range checking wouldn't be a bad idea here ... @}
  @{ Without it, a wrong value just leads to a runtime error. @}
  VMT := VMTTable[TypeID];

  SetType (Result^, VMT);

  @{ Now the object is ready, and the constructor can be called. @}
  @{ Look up the correct constructor from some table and call it. @}
end;

begin
end.
@end smallexample

@subheading See also

@ref{PObjectType}, @ref{TypeOf}, @ref{OOP}.


@c ----------------------------------------------------------------------------


@node shl
@unnumberedsec shl
@cindex shl

@subheading Synopsis

@smallexample
operator shl (operand1, operand2: @var{integer_type}) = Result: @var{integer_type};
@end smallexample
or
@smallexample
procedure shl (var operand1: @var{integer_type}; operand2: @var{integer_type});
@end smallexample

@subheading Description

In GNU Pascal, @samp{shl} has two built-in meanings:

@enumerate

@item
Bitwise shift left of an integer-type expression by another integer value.
The result is of the type of the first operand.

@item
Use as a ``procedure'': @samp{operand1} is shifted left by
@samp{operand2}; the result is stored in @samp{operand1}.

@end enumerate

@subheading Conforming to

@samp{shl} is a Borland Pascal extension.

Use of @samp{shl} as a ``procedure'' is a GNU Pascal extension.

@subheading Example

@smallexample
program ShlDemo;
var
  a: Integer;
begin
  a := 1 shl 7;  @{ yields 128 = 2 pow 7 @}
  shl (a, 4)  @{ same as `a := a shl 4' @}
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{shr}, @ref{Operators}.


@c ----------------------------------------------------------------------------


@node ShortBool
@unnumberedsec ShortBool
@cindex ShortBool

@subheading Synopsis

@smallexample
type
  ShortBool = Boolean attribute (Size = BitSizeOf (ShortInt));
@end smallexample

@subheading Description

The intrinsic @samp{ShortBool} represents boolean values, but
occupies the same memory space as a @samp{ShortInt}.  It is used
when you need to define a parameter or record that conforms to some
external library or system specification.

@subheading Conforming to

@samp{ShortBool} is a GNU Pascal extension.

@subheading Example

@smallexample
program ShortBoolDemo;
var
  a: ShortBool;
begin
  ShortInt (a) := 1;
  if a then WriteLn ('Ord (True) = 1')
end.
@end smallexample

@subheading See also

@ref{Boolean (Intrinsic)}, @ref{Boolean}, @ref{True}, @ref{False},
@ref{CBoolean}, @ref{ByteBool}, @ref{MedBool}, @ref{WordBool},
@ref{LongBool}, @ref{LongestBool}.

@c ----------------------------------------------------------------------------


@node ShortCard
@unnumberedsec ShortCard
@cindex ShortCard

@subheading Synopsis

@smallexample
type
  ShortCard = Cardinal attribute (Size = BitSizeOf (ShortInt));
@end smallexample

@subheading Description

@samp{ShortCard} is an unsigned integer type which is not larger than
@samp{Cardinal}. On some platforms it is 16 bits wide and thus has a
range of @samp{0 .. 65535}.

@samp{ShortCard} in GNU Pascal is compatible to @samp{short unsigned int}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{ShortCard} is a GNU Pascal extension.

@subheading Example

@smallexample
program ShortCardDemo;
var
  a: ShortCard;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node ShortInt
@unnumberedsec ShortInt
@cindex ShortInt

@subheading Synopsis

@smallexample
type
  ShortInt  @{ built-in type @}
@end smallexample

@subheading Description

@samp{ShortInt} is a signed integer type which is not larger than
@samp{Integer}. On some platforms it is 16 bits wide and thus has a
range of @samp{-32768 .. 32767}.

@samp{ShortInt} in GNU Pascal is compatible to @samp{short int}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{ShortInt} is a Borland Pascal extension. In Borland
Pascal, @samp{ShortInt} is an 8-bit signed integer type
(@samp{ByteInt} in GNU Pascal).

@subheading Example

@smallexample
program ShortIntDemo;
var
  a: ShortInt;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Integer Types},
@ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node ShortReal
@unnumberedsec ShortReal
@cindex ShortReal

(Under construction.)

@subheading Synopsis

@smallexample
type
  ShortReal  @{ built-in type @}
@end smallexample

@subheading Description

@subheading Conforming to

@samp{ShortReal} is a GNU Pascal extension.

@subheading Example

@smallexample
program ShortRealDemo;
var
  a: ShortReal;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample


@subheading See also


@c ----------------------------------------------------------------------------


@node ShortWord
@unnumberedsec ShortWord
@cindex ShortWord

@subheading Synopsis

@smallexample
type
  ShortWord = ShortCard;
@end smallexample

@subheading Description

@samp{ShortWord} is an unsigned integer type which is not larger than
@samp{Word}. On some platforms it is 16 bits wide and thus has a range
of @samp{0 .. 65535}. It is the same as @ref{ShortCard}.

@samp{ShortWord} in GNU Pascal is compatible to @samp{short unsigned int}
in GNU C.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{ShortWord} is a GNU Pascal extension.

@samp{ShortWord} in GNU Pascal essentially corresponds to @samp{Word} in
Borland Pascal and Delphi where it is a 16-bit unsigned integer type.

@subheading Example

@smallexample
program ShortWordDemo;
var
  a: ShortWord;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{ShortCard}, @ref{Integer Types}, @ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node shr
@unnumberedsec shr
@cindex shr

@subheading Synopsis

@smallexample
operator shr (operand1, operand2: @var{integer_type}) = Result: @var{integer_type};
@end smallexample
or
@smallexample
procedure shr (var operand1: @var{integer_type}; operand2: @var{integer_type});
@end smallexample

@subheading Description

In GNU Pascal, @samp{shr} has two built-in meanings:

@enumerate

@item
Bitwise shift right of an integer-type expression by another integer value.
The result is of the type of the first operand.

@item
Use as a ``procedure'': @samp{operand1} is shifted right by
@samp{operand2}; the result is stored in @samp{operand1}.

@end enumerate

@subheading Conforming to

@samp{shr} is a Borland Pascal extension.

Unlike the Borland compilers, GNU Pascal cares about the
signedness of the first operand: If a signed integer with a
negative value is shifted right, ``one'' bits are filled in from
the left.

Use of @samp{shr} as a ``procedure'' is a GNU Pascal extension.

@subheading Example

@smallexample
program ShrDemo;
var
  a: Integer;
begin
  a := 1024 shr 4;  @{ yields 64 @}
  a := -127 shr 4;  @{ yields -8 @}
  shr (a, 2)  @{ same as `a := a shr 2' @}
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{shl}, @ref{Operators}.


@c ----------------------------------------------------------------------------


@node Sin
@unnumberedsec Sin
@cindex Sin

@subheading Synopsis

@smallexample
function Sin (x: Real): Real;
@end smallexample
or
@smallexample
function Sin (z: Complex): Complex;
@end smallexample

@subheading Description

@samp{Sin} returns the sine of the argument.
The result is in the range @samp{-1 <= Sin (x) <= 1} for real arguments.

@subheading Conforming to

The function @samp{Sin} is defined in ISO 7185 Pascal;
its application to complex values is defined in ISO 10206 Extended Pascal.

@subheading Example

@smallexample
program SinDemo;
begin
  @{ yields 0.5 since Sin (Pi / 6) = 0.5 @}
  WriteLn (Sin (Pi / 6) : 0 : 5)
end.
@end smallexample

@subheading See also

@ref{ArcTan}, @ref{Cos}, @ref{Ln}, @ref{Arg}.


@c ----------------------------------------------------------------------------


@node Single
@unnumberedsec Single
@cindex Single

(Under construction.)

@subheading Synopsis

@smallexample
type
  Single = ShortReal;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Single} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node SizeOf
@unnumberedsec SizeOf
@cindex SizeOf

@subheading Synopsis

@smallexample
function SizeOf (var x): SizeType;
@end smallexample

@subheading Description

Returns the size of a type or variable in bytes.

@samp{SizeOf} can be applied to expressions and type names. If the
argument is a polymorphic object, the size of its actual type is
returned.

@subheading Conforming to

@samp{SizeOf} is a UCSD Pascal extension.

@subheading Example

@smallexample
program SizeOfDemo;
var
  a: Integer;
  b: array [1 .. 8] of Char;
begin
  WriteLn (SizeOf (a));        @{ Size of an `Integer'; often 4 bytes. @}
  WriteLn (SizeOf (Integer));  @{ The same. @}
  WriteLn (SizeOf (b))         @{ Size of eight `Char's; usually 8 bytes. @}
end.
@end smallexample

@subheading See also

@ref{BitSizeOf}, @ref{AlignOf}, @ref{TypeOf}.


@c ----------------------------------------------------------------------------


@node SizeType
@unnumberedsec SizeType
@cindex SizeType

@subheading Synopsis

@smallexample
type
  SizeType  @{ built-in type @}
@end smallexample

@subheading Description

@samp{SizeType} is an integer type (usually unsigned) to represent
the size of objects in memory.

@subheading Conforming to

@samp{SizeType} is a GNU Pascal extension.

@subheading Example

@smallexample
program SizeTypeDemo;
var
  a: array [1 .. 10] of Integer;
  Size: SizeType;
begin
  Size := SizeOf (a);
  WriteLn (Size)
end.
@end smallexample

@subheading See also


@c ----------------------------------------------------------------------------


@node SmallInt
@unnumberedsec SmallInt
@cindex SmallInt

@subheading Synopsis

@smallexample
type
  SmallInt = ShortInt;
@end smallexample

@subheading Description

@samp{SmallInt} is a signed integer type which is not larger than
@samp{Integer}. On some platforms it is 16 bits wide and thus has a
range of @samp{-32768 .. 32767}. It is the same as @samp{ShortInt}
(see @ref{ShortInt}).

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{SmallInt} is a Borland Delphi 2.0 extension.

@subheading Example

@smallexample
program SmallIntDemo;
var
  a: SmallInt;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{ShortInt}, @ref{Integer Types}, @ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node Sqr
@unnumberedsec Sqr
@cindex Sqr

@subheading Synopsis

@smallexample
function Sqr (i: @var{integer_type}): @var{integer_type};
@end smallexample
or
@smallexample
function Sqr (x: @var{real_type}): @var{real_type};
@end smallexample
or
@smallexample
function Sqr (z: @var{complex_type}): @var{complex_type};
@end smallexample

@subheading Description

Returns the square of the argument:

@smallexample
function Sqr (x: @var{some_type}): @var{some_type};
begin
  Sqr := x * x  @{ or: x pow 2 @}
end;
@end smallexample

@subheading Conforming to

The function @samp{Sqr} is defined in ISO 7185 Pascal;
its application to complex values is defined in ISO 10206 Extended Pascal.

@subheading Example

@smallexample
program SqrDemo;

var
  i: Complex;

begin
  i := Cmplx (0, 1);
  WriteLn (Re (Sqr (i)) : 0 : 3)  @{ yields -1.000 @}
end.
@end smallexample

@subheading See also

@ref{pow}, @ref{SqRt}, @ref{Abs}, @ref{Operators}.


@c ----------------------------------------------------------------------------


@node SqRt
@unnumberedsec SqRt
@cindex SqRt

@subheading Synopsis

@smallexample
function SqRt (x: @var{real_type}): @var{real_type};
@end smallexample
or
@smallexample
function SqRt (z: @var{complex_type}): @var{complex_type};
@end smallexample

@subheading Description

Returns the positive square root of the argument.

For real arguments, it is an error if the argument is negative.

For complex arguments, @samp{SqRt} returns the principal value of
the root of the argument, i.e.@: the root with positive real part,
or, if the real part is zero, that one with positive imaginary part.

@subheading Conforming to

The function @samp{SqRt} is defined in ISO 7185 Pascal;
its application to complex values is defined in ISO 10206 Extended Pascal.

@subheading Example

@smallexample
program SqRtDemo;

var
  m1: Complex;

begin
  m1 := Cmplx (-1, 0);  @{ -1 @}
  WriteLn (Re (SqRt (m1)) : 6 : 3, Im (SqRt (m1)) : 6 : 3);
    @{ yields 1.000 -1.000, i.e. the imaginary unit, i @}
end.
@end smallexample

@subheading See also

@ref{pow}, @ref{Sqr}, @ref{Operators}.


@c ----------------------------------------------------------------------------


@node StandardError
@unnumberedsec StandardError
@cindex StandardError

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{StandardError} is a GNU Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node StandardInput
@unnumberedsec StandardInput
@cindex StandardInput

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{StandardInput} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node StandardOutput
@unnumberedsec StandardOutput
@cindex StandardOutput

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{StandardOutput} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node StdErr
@unnumberedsec StdErr
@cindex StdErr

@subheading Synopsis

@smallexample
var
  StdErr: Text;
@end smallexample

@subheading Description

The @samp{StdErr} variable is connected to the standard error file
handle. To report errors, you should prefer
@samp{WriteLn (StdErr, 'everything wrong')} over
@samp{WriteLn ('everything wrong')}.

@subheading Conforming to

@samp{StdErr} is a GNU Pascal extension.

@subheading Example

@smallexample
program StdErrDemo;
var
  Denominator: Integer;
begin
  ReadLn (Denominator);
  if Denominator = 0 then
    WriteLn (StdErr, ParamStr (0), ': division by zero')
  else
    WriteLn ('1 / ', Denominator, ' = ', 1 / Denominator)
end.
@end smallexample

@subheading See also

@ref{StandardError}, @ref{Output}, @ref{Input}.


@c ----------------------------------------------------------------------------


@node Str
@unnumberedsec Str
@cindex Str

(Under construction.)

@subheading Synopsis

@smallexample
procedure Str (x: @var{integer_or_real}; var Dest: String);
@end smallexample
or
@smallexample
procedure Str (x: @var{integer_or_real} : @var{field_width}; var Dest: String);
@end smallexample
or
@smallexample
procedure Str (x: Real : @var{field_width} : @var{precision}; var Dest: String);
@end smallexample
or
@smallexample
procedure Str (@var{repeated_constructs_as_described_above}; var Dest: String);
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Str} is a UCSD Pascal extension, generalized by Borland
Pascal. The possibility to handle more than one variable in one
@samp{Str} statement is a GNU Pascal extension.

ISO 10206 Extended Pascal defines @samp{WriteStr} instead of
@samp{Str}.

@subheading Example

@subheading See also

@ref{WriteStr}.


@c ----------------------------------------------------------------------------


@node String
@unnumberedsec String
@cindex String

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{String} is an Extended Pascal and a UCSD Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node String2CString
@unnumberedsec String2CString
@cindex String2CString

(Under construction.)

@subheading Synopsis

@smallexample
function String2CString (const S: String): CString;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{String2CString} is a GNU Pascal extension.

@subheading Example

@subheading See also

@c ----------------------------------------------------------------------------


@node StringOf
@unnumberedsec StringOf
@cindex StringOf

@subheading Synopsis

@smallexample
function StringOf (@var{values_and_format_specifications}): String;
@end smallexample

@subheading Description

@samp{StringOf} prints its arguments to an internal buffer and returns
resulting string. Value and format specifications are handled exactly
the same as in @samp{Write} or @samp{WriteStr}.

@subheading Conforming to

@samp{StringOf} is a Mac Pascal extension.

@subheading Example
@smallexample
program StringOfDemo;
begin
  writeln(StringOf('2 * 2 = ', 2 * 2))
end.
@end smallexample

@subheading See also

@ref{Write} @ref{WriteStr}.

@c ----------------------------------------------------------------------------


@node SubStr
@unnumberedsec SubStr
@cindex SubStr

@subheading Synopsis

@smallexample
function SubStr (S: String; FirstChar: Integer): String;
@end smallexample
or
@smallexample
function SubStr (S: String; FirstChar, Count: Integer): String;
@end smallexample

@subheading Description

@samp{SubStr} returns a sub-string of @var{S} starting with the
character at position @var{FirstChar}. If @var{Count} is given, such
many characters will be copied into the sub-string. If @var{Count} is
omitted, the sub-string will range to the end of @var{S}.

If @samp{Count} is too large for the sub-string to fit in @var{S} or if
@samp{FirstChar} exceeds the length of @var{S}, @samp{SubStr} triggers a
runtime error. (For a function returning the empty string instead, see
@ref{Copy}.)

@subheading Conforming to

@samp{SubStr} is an ISO 10206 Extended Pascal extension.

@subheading Example

@smallexample
program SubStrDemo;
var
  S: String (42);
begin
  S := 'Hello';
  WriteLn (SubStr (S, 2, 3));   @{ yields `ell' @}
  WriteLn (SubStr (S, 3));      @{ yields `llo' @}
  WriteLn (SubStr (S, 4, 7));   @{ yields a runtime error @}
  WriteLn (SubStr (S, 42));     @{ yields a runtime error @}
end.
@end smallexample

@subheading See also

@ref{Copy}, @ref{String Slice Access}.


@c ----------------------------------------------------------------------------


@node Succ
@unnumberedsec Succ
@cindex Succ

@subheading Synopsis

@smallexample
function Succ (i: @var{ordinal_type}): @var{ordinal_type};
@end smallexample
or
@smallexample
function Succ (i: @var{ordinal_type}; j: @var{and_integer_type}): @var{ordinal_type};
@end smallexample

or, with extended syntax (@samp{--extended-syntax} or @samp{@{$X+@}}),

@smallexample
function Succ (p: @var{Pointer_type}): @var{Pointer_type};
@end smallexample
or
@smallexample
function Succ (p: @var{Pointer_type}; j: @var{and_integer_type}): @var{Pointer_type};
@end smallexample

@subheading Description

Returns the successor of the @var{ordinal_type} value @samp{i}, or,
if the second argument @samp{j} is given, its @samp{j}th successor.
For integer values @samp{i}, this is @samp{i + 1} (or @samp{i + j}).
(No, @samp{Succ} does @emph{not} work faster than plain addition.
Both are optimized the same way, often to a single machine
instruction.)

If extended syntax is on, the argument may also be a pointer value.
In this case, the address is incremented by the size of the variable
pointed to, or, if @samp{j} is given, by @samp{j} times the size of
the variable pointed to. If @samp{p} points to an element of an
array, the returned pointer will point to the (@samp{j}th) next
element of the array.

@subheading Conforming to

The @samp{Succ} function is defined in ISO 7185 Pascal. The optional
second parameter is defined in ISO 10206 Extended Pascal.
Application of @samp{Succ} to pointers is defined in Borland Pascal.
The combination of the second argument with application to pointers
is a GNU Pascal extension.

@subheading Example

@smallexample
program SuccDemo;

type
  Metasyntactical = (foo, bar, baz);

var
  m: Metasyntactical;
  c: Char;
  a: array [1 .. 7] of Integer;
  p: ^Integer;

begin
  m := Succ (foo);     @{ bar @}
  c := Succ ('A', 4);  @{ 'E' @}
  a[1] := 42;
  a[2] := Succ (a[1]);     @{ 43 @}
  a[5] := Succ (a[2], 7);  @{ 50 @}
  @{$X+@}
  p := @@a[1];
  p := Succ (p);     @{ points to `a[2]' now @}
  p := Succ (p, 3);  @{ points to `a[5]' now @}
end.
@end smallexample

@subheading See also

@ref{Pred}, @ref{Inc}, @ref{Pointer Arithmetics}.


@c ----------------------------------------------------------------------------


@node Text
@unnumberedsec Text
@cindex Text

(Under construction.)

@subheading Synopsis

@smallexample
type
  Text  @{ built-in type @}
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Text} is defined in ISO 7185 Pascal and supported by all known
Pascal variants.

@subheading Example

@smallexample
program TextDemo;
var
  t: Text;
begin
  Rewrite (t, 'hello.txt');
  WriteLn (t, 'Hello, world!')
end.
@end smallexample

@subheading See also

@ref{file}, @ref{AnyFile}.


@c ----------------------------------------------------------------------------


@node then
@unnumberedsec then
@cindex then

(Under construction.)

@subheading Synopsis

@subheading Description

Part of an @samp{if} statement or part of the @samp{and then} operator.

@subheading Conforming to

@samp{then} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@smallexample
program ThenDemo;
var
  i: Integer;
begin
  Write ('Enter a number: ');
  ReadLn (i);
  if i > 42 then
    WriteLn ('The number is greater than 42')
end.
@end smallexample

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node Time
@unnumberedsec Time
@cindex Time

@subheading Synopsis

@smallexample
function Time (T: TimeStamp): packed array [1 .. @var{Time_Length}] of Char;
@end smallexample

@subheading Description

Date takes a @code{TimeStamp} parameter and returns the time as a
string (in the form of a packed array of @code{Char}).
@var{Time_length} is an implementation defined invisible constant.

@subheading Conforming to

@samp{Time} is an ISO 10206 Extended Pascal extension.

@subheading Example

Set @ref{TimeStamp}.

@subheading See also

@ref{TimeStamp}, @ref{GetTimeStamp}, @ref{Date},
@ref{Date And Time Routines}.


@c ----------------------------------------------------------------------------


@node TimeStamp
@unnumberedsec TimeStamp
@cindex TimeStamp

@subheading Synopsis

@smallexample
type
  TimeStamp = packed record
    DateValid,
    TimeValid  : Boolean;
    Year       : Integer;
    Month      : 1 .. 12;
    Day        : 1 .. 31;
    DayOfWeek  : 0 .. 6;   @{ 0 means Sunday @}
    Hour       : 0 .. 23;
    Minute     : 0 .. 59;
    Second     : 0 .. 61;  @{ to allow for leap seconds @}
    MicroSecond: 0 .. 999999;
    TimeZone   : Integer;  @{ in seconds east of UTC @}
    DST        : Boolean;
    TZName1,
    TZName2    : String (32);
  end;
@end smallexample

@subheading Description

The @code{TimeStamp} record holds all the information about a
particular time. You can get the current time with
@code{GetTimeStamp} and you can get the date or time in a printable
form using the @code{Date} and @code{Time} functions.

@subheading Conforming to

@samp{TimeStamp} is an ISO 10206 Extended Pascal extension. The
fields @samp{DateValid}, @samp{TimeValid}, @samp{Year},
@samp{Month}, @samp{Day}, @samp{Hour}, @samp{Minute}, @samp{Second}
are required by Extended Pascal, the other ones are GNU Pascal
extensions.

@subheading Example

@smallexample
program TimeStampDemo;

var
  t: TimeStamp;

begin
  GetTimeStamp (t);
  WriteLn ('DateValid: ', t.DateValid);
  WriteLn ('TimeValid: ', t.TimeValid);
  WriteLn ('Year: ', t.Year);
  WriteLn ('Month: ', t.Month);
  WriteLn ('Day: ', t.Day);
  WriteLn ('DayOfWeek (0 .. 6, 0=Sunday): ', t.DayOfWeek);
  WriteLn ('Hour (0 .. 23): ', t.Hour);
  WriteLn ('Minute (0 .. 59): ', t.Minute);
  WriteLn ('Second (0 .. 61): ', t.Second);
  WriteLn ('MicroSecond (0 .. 999999): ', t.MicroSecond);
  WriteLn ('TimeZone (in seconds east of UTC): ', t.TimeZone);
  WriteLn ('DST: ', t.DST);
  WriteLn ('TZName1: ', t.TZName1);
  WriteLn ('TZName2: ', t.TZName2);
  WriteLn;
  WriteLn ('Date is: ', Date (t));
  WriteLn ('Time is: ', Time (t));
end.
@end smallexample

@subheading See also

@ref{GetTimeStamp}, @ref{Date}, @ref{Time}, @ref{Date And Time Routines}.

@c ----------------------------------------------------------------------------


@node to
@unnumberedsec to
@cindex to

(Under construction.)

@subheading Synopsis

@subheading Description

Part of a @samp{for} loop counting upwards or a @samp{to begin do}
or @samp{to end do} module constructor or destructor.

@subheading Conforming to

@samp{to} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node to begin do
@unnumberedsec to begin do
@cindex to begin do

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{to begin do} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node to end do
@unnumberedsec to end do
@cindex to end do

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@samp{to begin end} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node Trim
@unnumberedsec Trim
@cindex Trim

(Under construction.)

@subheading Synopsis

@smallexample
function Trim (S: String): String;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Trim} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node True
@unnumberedsec True
@cindex True

@subheading Synopsis

@smallexample
type
  Boolean = (False, True);  @{ built-in type @}
@end smallexample

@subheading Description

@samp{True} is one of the two Boolean values and is used to
represent a condition which is always fullfilled. For example, the
expression @code{1 = 1} always yields the value @samp{True}. It is
the opposite of @samp{False}. @samp{True} has the ordinal value 1.

@subheading Conforming to

@samp{True} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@smallexample
program TrueDemo;

var
  a: Boolean;

begin
  a := 1 = 1;  @{ yields True @}
  WriteLn (Ord (True));  @{ 1 @}
  WriteLn (a);  @{ True @}
  if True then WriteLn ('This is executed.')
end.
@end smallexample

@subheading See also

@ref{Boolean (Intrinsic)}, @ref{False}, @ref{Boolean}.

@c ----------------------------------------------------------------------------


@node Trunc
@unnumberedsec Trunc
@cindex Trunc

@subheading Synopsis

@smallexample
function Trunc (x: Real): Integer;
@end smallexample

@subheading Description

@samp{Trunc} returns the integer part of a floating point number as
an integer. Use @samp{Int} to get the integer part as
a floating point number.

@subheading Conforming to

@samp{Trunc} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@smallexample
program TruncDemo;

begin
  WriteLn (Frac (12.345) : 1 : 5);  @{ 0.34500 @}
  WriteLn (Int (12.345) : 1 : 5);  @{ 12.00000 @}
  WriteLn (Round (12.345) : 1);  @{ 12 @}
  WriteLn (Trunc (12.345) : 1);  @{ 12 @}

  WriteLn (Frac (-12.345) : 1 : 5);  @{ -0.34500 @}
  WriteLn (Int (-12.345) : 1 : 5);  @{ -12.00000 @}
  WriteLn (Round (-12.345) : 1);  @{ -12 @}
  WriteLn (Trunc (-12.345) : 1);  @{ -12 @}

  WriteLn (Frac (12.543) : 1 : 5);  @{ 0.54300 @}
  WriteLn (Int (12.543) : 1 : 5);  @{ 12.00000 @}
  WriteLn (Round (12.543) : 1);  @{ 13 @}
  WriteLn (Trunc (12.543) : 1);  @{ 12 @}

  WriteLn (Frac (-12.543) : 1 : 5);  @{ -0.54300 @}
  WriteLn (Int (-12.543) : 1 : 5);  @{ -12.00000 @}
  WriteLn (Round (-12.543) : 1);  @{ -13 @}
  WriteLn (Trunc (-12.543) : 1);  @{ -12 @}
end.
@end smallexample

@subheading See also

@ref{Real Types}, @ref{Real}, @ref{Int}, @ref{Frac}, @ref{Round}.


@c ----------------------------------------------------------------------------


@node Truncate
@unnumberedsec Truncate
@cindex Truncate

(Under construction.)

@subheading Synopsis

@smallexample
procedure Truncate (var F: @var{any_file});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Truncate} is a Borland Pascal extension.

@subheading Example

@subheading See also

@c ----------------------------------------------------------------------------


@node try
@unnumberedsec try
@cindex try

Not yet implemented.

@subheading Synopsis

@subheading Conforming to

@samp{try} is a Borland Delphi extension.

@subheading Example

@subheading See also

@ref{Keywords}.

@c ----------------------------------------------------------------------------


@node type
@unnumberedsec type
@cindex type

@subheading Synopsis

As a type declaration:
@smallexample
type
  @var{type_indentifier} = @var{type_definition};
@end smallexample
or with initialization:
@smallexample
type
  @var{type_indentifier} = @var{type_definition} value @var{constant_expression};
@end smallexample


@subheading Description

The reserved word @samp{type} starts the declaration of a @var{type
identifier} which is defined by @var{type_definition}. For further
description see @ref{Type Declaration}, @ref{Type Declaration},
@ref{Type Definition}, @ref{Data Types}.

@subheading Conforming to

@samp{type} is defined in ISO 7185 Pascal and supported
by all known Pascal variants. Initializers are an ISO 10206 Extended
Pascal extension.

@subheading Example

@smallexample
program TypeDemo;
type
  @{ This side is the @}    @{ That side is the @}
  @{ type declaration @}    @{ type definition  @}

  @{ array type @}
  ArrayType                  = array [0 .. 9] of Integer;

  @{ record type @}
  RecordType                 = record
                                 Bar: Integer
                               end;

  @{ subrange type @}
  SubrangeType               = -123 .. 456;

  @{ enumeration type @}
  EnumeratedType             = (Mon, Tue, Wed, Thu, Fri, Sat, Sun);

  @{ set type @}
  CharSetType                = set of Char;

  @{ object type @}
  ObjectType                 = object
                                 constructor Init;
                                 procedure Method;
                                 destructor Done
                               end;

  @{ pointer type to another type identifier @}
  PArrayType                 = ^ArrayType;

  @{ an alias name for another type identifier @}
  IntegerType                = Integer;

  @{ an integer which is initialized by 123 @}
  InitializedInt             = Integer value 123;

  @{ a schema with discriminants x and y of type Integer @}
  SchemaType (x, y: Integer) = array [x .. y] of Integer;

@{ Dummy methods of the object type @}
constructor ObjectType.Init;
begin
end;

procedure ObjectType.Method;
begin
end;

destructor ObjectType.Done;
begin
end;

begin
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{Type Declaration}, @ref{Type Definition},
@ref{Data Types}, @ref{Variable Declaration}, @ref{array},
@ref{record}, @ref{object}, @ref{set}, @ref{Pointer}, @ref{value}.


@c ----------------------------------------------------------------------------


@node type of
@unnumberedsec type of
@cindex type of

(Under construction.)

@subheading Synopsis

@subheading Description

@subheading Conforming to

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node TypeOf
@unnumberedsec TypeOf
@cindex TypeOf

@subheading Synopsis

@smallexample
function TypeOf (var x): PObjectType;
@end smallexample

@subheading Description

Returns a pointer to the VMT of an @emph{object} type or variable.
This pointer can be used to identify the type of an object.

@samp{TypeOf} can be applied to expressions of object type and to
object type names. In the former case, the actual type of
polymorphic objects is returned.

@subheading Conforming to

@samp{TypeOf} is a Borland Pascal extension.

@subheading Example

@smallexample
program TypeOfDemo;
type
  FooPtr = ^Foo;
  BarPtr = ^Bar;

  Foo = object         @{ Has a VMT, though it doesn't @}
    x: Integer;        @{ contain virtual methods.     @}
    constructor Init;
  end;

  Bar = object (Foo)
    y: Integer;
  end;

constructor Foo.Init;
begin
end;

var
  MyFoo: FooPtr;

begin
  MyFoo := New (BarPtr, Init);
  if TypeOf (MyFoo^) = TypeOf (Bar) then  @{ True @}
    WriteLn ('OK')
end.
@end smallexample

@subheading See also

@ref{BitSizeOf}, @ref{AlignOf}, @ref{PObjectType}, @ref{SetType},
@ref{SizeOf}, @ref{OOP}.


@c ----------------------------------------------------------------------------


@node Unbind
@unnumberedsec Unbind
@cindex Unbind

(Under construction.)

@subheading Synopsis

@smallexample
procedure Unbind (var F: @var{any_file});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Unbind} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also

@ref{Bind}, @ref{Binding}, @ref{BindingType}, @ref{bindable}.


@c ----------------------------------------------------------------------------


@node unit
@unnumberedsec unit
@cindex unit

(Under construction.)

@subheading Synopsis

@subheading Description

UCSD and BP style unit declaration.

@subheading Conforming to

@samp{unit} is a UCSD Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node Unpack
@unnumberedsec Unpack
@cindex Unpack

(Under construction.)

@subheading Synopsis

@smallexample
procedure Unpack (Source: @var{packed_array};
                  var Dest: @var{unpacked_array};
                  FirstElement: @var{index_type});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Unpack} is defined in ISO 7185 Pascal and supported by all
known Pascal variants except UCSD/Borland Pascal and its variants.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node until
@unnumberedsec until
@cindex until

(Under construction.)

@subheading Synopsis

@subheading Description

@samp{until} is part of the @samp{repeat @dots{} until} loop statement.

@subheading Conforming to

@samp{until} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also

@ref{Keywords}, @ref{repeat}, @ref{while}, @ref{for}.


@c ----------------------------------------------------------------------------


@node UpCase
@unnumberedsec UpCase
@cindex UpCase

(Under construction.)

@subheading Synopsis

@smallexample
function UpCase (Ch: Char): Char;
@end smallexample

@subheading Description

@subheading Conforming to

@samp{UpCase} is a Borland Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node Update
@unnumberedsec Update
@cindex Update

(Under construction.)

@subheading Synopsis

@smallexample
procedure Update (var F: @var{any_file});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Update} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node uses
@unnumberedsec uses
@cindex uses

@subheading Synopsis

In a program:

@smallexample
program @@@@fragment foo;

uses
  bar1,
  bar2 in 'baz.pas',
  bar3;

[...]
@end smallexample

In a unit:

@smallexample
unit @@@@fragment Bar3;

interface

uses
  bar1,
  bar2 in 'baz.pas';

[...]

implementation

uses
  bar3,
  bar4 in 'qux.pas';

[...]
@end smallexample

@subheading Description

The reserved word @samp{uses} in the @emph{import part} of a program
or unit makes the program or unit import an interface.

The keyword @samp{in} tells GPC to look for the @samp{unit} in the
specified file; otherwise the file name is derived from the name of
the interface, coverted to lower-case, by adding first @file{.p},
then @file{.pas}.

In BP, there must be at most one @samp{uses} part in a program, and
in a unit, there can be one import part in the interface part and
one in the implementation part. GPC, as an extention, allows for
several @samp{uses} parts, and also allows @samp{uses} parts in a
module.

The imported interface needn't be a UCSD/Borland Pascal unit, it
may be an interface exported by an Extended Pascal module as well.

@subheading Conforming to

ISO Pascal does not define @samp{uses} and units at all. UCSD and
Borland Pascal do, but without the @samp{in} extension. Delphi
supports @samp{uses} like described above.

@subheading Example

@subheading See also

@ref{Keywords}, @ref{unit}, @ref{module}, @ref{import}.


@c ----------------------------------------------------------------------------


@node Val
@unnumberedsec Val
@cindex Val

(Under construction.)

@subheading Synopsis

@smallexample
procedure Val (const Source: String; var x: @var{integer_or_real};
               var ErrorPosition: Integer);
@end smallexample

@subheading Description

@samp{Val} converts the integer or real number that is represented
by the characters in the string @samp{Source} and places it into
@samp{x}.

The @samp{Source} string can have a base prefix (@samp{$} for
hexadecimal or @samp{Base#}). The optional @samp{ErrorCode} will be
set to the position of the first invalid character, or to a 0 if the
entire string represents a valid number. In case an invalid
character occurrs in @samp{Source}, @samp{x} will be undefined.

@subheading Conforming to

@samp{Val} is a Borland Pascal extension.

@subheading Example

@smallexample
program ValDemo;
var
  x, ec: Integer;
  l: LongInt;
  r: Real;
begin
  Val ('123', x, ec);                @{ x :=            123; ec := 0; @}
  Val ('-123', x, ec);               @{ x :=           -123; ec := 0; @}
  Val ('123.456', r, ec);            @{ r :=        123.456; ec := 0; @}
  Val ('$ffff', x, ec);              @{ x :=          65535; ec := 0; @}
  Val ('$F000', x, ec);              @{ x :=          61440; ec := 0; @}
  Val ('-$ffff', x, ec);             @{ x :=         -65535; ec := 0; @}
  Val ('12#100', x, ec);             @{ x :=            144; ec := 0; @}
  Val ('-2#11111111', x, ec);        @{ x :=           -255; ec := 0; @}
  @{ here we have the invalid character 'X' for base 16 @}
  Val ('$fffeX', x, ec);             @{ x :=    <undefined>; ec := 6; @}
  Val ('12#100invalid', x, ec);      @{ x :=    <undefined>; ec := 7; @}
  Val ('36#Jerusalem', l, ec);       @{ l := 54758821170910; ec := 0; @}
end.
@end smallexample

@subheading See also

@ref{ReadLn}, @ref{ReadStr}, @ref{WriteLn}, @ref{WriteStr}, @ref{Str}.


@c ----------------------------------------------------------------------------


@node value
@unnumberedsec value
@cindex value

@subheading Synopsis

@subheading Description

The reserved word @samp{value} is part of a type or var declaration.
It can be replaced by @samp{:=} or @samp{=}.

@subheading Conforming to

@samp{value} is an ISO 10206 Extended Pascal extension. @samp{:=} in
this context is a VAX Pascal extension, and @samp{=} is a Borland
Delphi extension.

@subheading Example

@subheading See also

@ref{Keywords}, @ref{var}, @ref{type}, @ref{Variable Declaration},
@ref{Type Declaration}.


@c ----------------------------------------------------------------------------


@node var
@unnumberedsec var
@cindex var

@subheading Synopsis

As part of a variable declaration part or in a statement block:
@smallexample
var @var{variable_identifier}: @var{type_identifier};
@end smallexample
or
@smallexample
var @var{variable_identifier}: @var{type_definition};
@end smallexample
and with initializing value:
@smallexample
var @var{variable_identifier}: @var{type_identifier} value @var{constant_expression};
@end smallexample
or
@smallexample
var @var{variable_identifier}: @var{type_definition} value @var{constant_expression};
@end smallexample

@noindent
As part of a parameter list (passing by reference):
@smallexample
var @var{var_parameter}: @var{type_identifier};
@end smallexample
or without type declaration
@smallexample
var @var{var_parameter};
@end smallexample

@noindent
or protected (i.e., the called routine can't modify the parameter):
@smallexample
protected var @var{var_parameter}: @var{type_identifier};
@end smallexample
or without type declaration
@smallexample
protected var @var{var_parameter};
@end smallexample

@subheading Description

In a declaration part: The reserved word @samp{var} declares a
@var{variable_identifier} whose type is of @var{type_identifier} or
which is defined by @var{type_definition}. For further description
see @ref{Variable Declaration}, @ref{Type Declaration},
@ref{Type Definition}, @ref{Data Types}.

In a parameter list: see @ref{Subroutine Parameter List Declaration}.

@subheading Conforming to

@samp{var} is defined in ISO 7185 Pascal and supported by
all known Pascal variants. Untyped @samp{var} parameters in
parameter lists are a UCSD Pascal extension. The ability to do
@samp{var} declarations in a statement block is a GNU Pascal
extension.

@subheading Example

@smallexample
program VarDemo;

type
  FooType = Integer;

var
  Bar: FooType;
  ArrayFoo: array [0 .. 9] of Integer;   @{ array var definition @}
  FecordFoo: record                      @{ record var definition @}
               Bar: Integer
             end;
  CharsetFoo: set of Char;               @{ set var @}
  SubrangeFoo: -123 .. 456;              @{ subrange var @}
  EnumeratedFoo: (Mon, Tue, Wed, Thu, Fri, Sat, Sun);  @{enumerated var @}
  PointerBar: ^FooType;                  @{ pointer var @}

procedure ReadFoo (var Foo: FooType);
begin
  ReadLn (Foo)
end;

begin
  var Bar: Integer;  @{ GNU Pascal extension @}
  Bar := 42
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{type}, @ref{array}, @ref{record}, @ref{set},
@ref{Subrange Types}, @ref{Pointer}, @ref{protected}.


@c ----------------------------------------------------------------------------


@node view
@unnumberedsec view
@cindex view

(Under construction.)

@subheading Synopsis

@subheading Description

Object class view.

@subheading Conforming to

@samp{view} is an Object Pascal extension. Currently GPC only supports
views without parents.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node virtual
@unnumberedsec virtual
@cindex virtual

(Under construction.)

@subheading Synopsis

@subheading Description

Virtual object method declaration.

@subheading Conforming to

@samp{virtual} is an Object Pascal and a Borland Pascal extension.

@subheading Example

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node Void
@unnumberedsec Void
@cindex Void

(Under construction.)

@subheading Synopsis

@smallexample
type
  Void  @{ built-in type @}
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Void} is a GNU Pascal extension.

@subheading Example

@smallexample
program VoidDemo;

procedure p (var x: Void);
begin
end;

var
  i: Integer;
  s: String (42);

begin
  p (i);
  p (s)
end.
@end smallexample

@subheading See also


@c ----------------------------------------------------------------------------


@node while
@unnumberedsec while
@cindex while

@subheading Synopsis

@smallexample
while @var{boolean_expression} do
  @var{statement}
@end smallexample

@subheading Description

The @samp{while} statement declares a loop. For further description see
@ref{while Statement}.

@subheading Conforming to

@samp{while} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@smallexample
program WhileDemo;
var
  Foo, Bar: Integer;
begin
  WriteLn ('Enter an descending series of integer numbers.');
  WriteLn ('Terminate by breaking this rule.');
  WriteLn ('Enter start number: ');
  Bar := MaxInt;
  ReadLn (Foo);
  while Foo < Bar do
    begin
      Bar := Foo;
      ReadLn (Foo)
    end;
  WriteLn ('The last number of your series was: ', Bar)
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{repeat Statement}, @ref{for Statement}.


@c ----------------------------------------------------------------------------


@node with
@unnumberedsec with
@cindex with

(Under construction.)

@subheading Synopsis

@subheading Description

Automatic @samp{record} or object field access.

@subheading Conforming to

@samp{with} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

 ...

     @{ Note bar is shadowed by foo.bar @}
 ...

@subheading See also

@ref{Keywords}.


@c ----------------------------------------------------------------------------


@node Word
@unnumberedsec Word
@cindex Word

@subheading Synopsis

@smallexample
type
  Word = Cardinal;
@end smallexample

@subheading Description

@samp{Word} is the ``natural'' unsigned integer type in GNU Pascal.
On some platforms it is 32 bits wide and thus has a range of
@samp{0 .. 4294967295}. It is the same as @ref{Cardinal}, introduced for
compatibility with other Pascal compilers.

There are lots of other integer types in GPC, see @ref{Integer Types}.

@subheading Conforming to

@samp{Word} is defined in Borland Pascal and Borland Delphi, where
it is a 16-bit unsigned integer type.

@subheading Example

@smallexample
program WordDemo;
var
  a: Word;
begin
  a := 42;
  WriteLn (a)
end.
@end smallexample

@subheading See also

@ref{Cardinal}, @ref{Integer Types}, @ref{Subrange Types}.


@c ----------------------------------------------------------------------------


@node WordBool
@unnumberedsec WordBool
@cindex WordBool

@subheading Synopsis

@smallexample
type
  WordBool = Boolean attribute (Size = BitSizeOf (Word));
@end smallexample

@subheading Description

The intrinsic @samp{WordBool} represents boolean values, but
occupies the same memory space as a @samp{Word}.  It is used when
you need to define a parameter or record that conforms to some
external library or system specification.

@subheading Conforming to

@samp{WordBool} is a Borland Pascal extension.

@subheading Example

@smallexample
program WordBoolDemo;
var
  a: WordBool;
begin
  Word (a) := 1;
  if a then WriteLn ('Ord (True) = 1')
end.
@end smallexample

@subheading See also

@ref{Boolean (Intrinsic)}, @ref{Boolean}, @ref{True}, @ref{False},
@ref{CBoolean}, @ref{ByteBool}, @ref{ShortBool}, @ref{MedBool},
@ref{LongBool}, @ref{LongestBool}.


@c ----------------------------------------------------------------------------


@node Write
@unnumberedsec Write
@cindex Write

(Under construction.)

@subheading Synopsis

@smallexample
procedure Write (var F: @var{typed_file}; @var{variable});
@end smallexample
or
@smallexample
procedure Write (var F: Text; @var{values_and_format_specifications});
@end smallexample
or
@smallexample
procedure Write (@var{values_and_format_specifications});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{Write} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node WriteLn
@unnumberedsec WriteLn
@cindex WriteLn

(Under construction.)

@subheading Synopsis

@smallexample
procedure WriteLn (var F: Text; @var{values_and_format_specifications});
@end smallexample
or
@smallexample
procedure WriteLn (@var{values_and_format_specifications});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{WriteLn} is defined in ISO 7185 Pascal and supported
by all known Pascal variants.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node WriteStr
@unnumberedsec WriteStr
@cindex WriteStr

(Under construction.)

@subheading Synopsis

@smallexample
procedure WriteStr (var Dest: String; @var{values_and_format_specifications});
@end smallexample

@subheading Description

@subheading Conforming to

@samp{WriteStr} is an ISO 10206 Extended Pascal extension.

@subheading Example

@subheading See also


@c ----------------------------------------------------------------------------


@node xor
@unnumberedsec xor
@cindex xor

@subheading Synopsis

@smallexample
operator xor (operand1, operand2: Boolean) = Result: Boolean;
@end smallexample
or
@smallexample
operator xor (operand1, operand2: @var{integer_type}) = Result: @var{integer_type};
@end smallexample
or
@smallexample
procedure xor (var operand1: @var{integer_type}; operand2: @var{integer_type});
@end smallexample

@subheading Description

In GNU Pascal, @samp{xor} has three built-in meanings:

@enumerate

@item
Logical ``exclusive or'' between two @samp{Boolean}-type
expressions. The result of the operation is of @samp{Boolean} type.
(Logical @samp{foo xor bar} in fact has the same effect as
@samp{foo <> bar}.)

@item
Bitwise ``exclusive or'' between two integer-type expressions.
The result is of the common integer type of both expressions.

@item
Use as a ``procedure'': @samp{operand1} is ``xor''ed bitwise with
@samp{operand2}; the result is stored in @samp{operand1}.

@end enumerate

@subheading Conforming to

ISO Pascal does not define the @samp{xor} operator;
Borland Pascal and Delphi do.

Use of @samp{xor} as a ``procedure'' is a GNU Pascal extension.

@subheading Example

@smallexample
program XorDemo;
var
  a, b, c: Integer;
begin
  if (a = 0) xor (b = 0) then
    c := 1  @{ happens if either `a' or `b' is zero,    @}
            @{ but not if both are zero or both nonzero @}
  else if (a xor b) = 0 then  @{ bitwise xor @}
    c := 2  @{ happens if a = b @}
  else
    xor (c, a)  @{ same as `c := c xor a' @}
end.
@end smallexample

@subheading See also

@ref{Keywords}, @ref{and}, @ref{or}, @ref{Operators}.


@c ============================================================================
